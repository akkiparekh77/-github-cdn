/*! For license information please see index.bundle.js.LICENSE.txt */
!(function (e, t) { typeof exports === 'object' && typeof module === 'object' ? module.exports = t() : typeof define === 'function' && define.amd ? define('azure-storage-blob-browser', [], t) : typeof exports === 'object' ? exports['azure-storage-blob-browser'] = t() : e['azure-storage-blob-browser'] = t(); }(this, (function () {
    return (()=>{
      var e = {
          697: ()=>{
            void 0 !== typeof Symbol && Symbol.asyncIterator || (Symbol.asyncIterator = Symbol.for('Symbol.asyncIterator'));
          },
          590: e=>{
            var t,
              a = typeof Reflect === 'object' ? Reflect : null,
              r = a && typeof a.apply === 'function' ? a.apply : function (e, t, a) { return Function.prototype.apply.call(e, t, a); }; t = a && typeof a.ownKeys === 'function' ? a.ownKeys : Object.getOwnPropertySymbols ? function (e) { return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e)); } : function (e) { return Object.getOwnPropertyNames(e); }; var s = Number.isNaN || function (e) { return e != e; }; function i() { i.init.call(this); }e.exports = i, e.exports.once = function (e, t) { return new Promise((function (a, r) { function s(a) { e.removeListener(t, i), r(a); } function i() { typeof e.removeListener === 'function' && e.removeListener('error', s), a([].slice.call(arguments)); }g(e, t, i, { once: !0 }), t !== 'error' && (function (e, t, a) { typeof e.on === 'function' && g(e, 'error', t, { once: !0 }); }(e, s)); })); }, i.EventEmitter = i, i.prototype._events = void 0, i.prototype._eventsCount = 0, i.prototype._maxListeners = void 0; var n = 10; function o(e) { if (typeof e !== 'function') throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e); } function m(e) { return void 0 === e._maxListeners ? i.defaultMaxListeners : e._maxListeners; } function l(e, t, a, r) {
              var s,
                i,
                n,
                l; if (o(a), void 0 === (i = e._events) ? (i = e._events = Object.create(null), e._eventsCount = 0) : (void 0 !== i.newListener && (e.emit('newListener', t, a.listener ? a.listener : a), i = e._events), n = i[t]), void 0 === n)n = i[t] = a, ++e._eventsCount; else if (typeof n === 'function' ? n = i[t] = r ? [a, n] : [n, a] : r ? n.unshift(a) : n.push(a), (s = m(e)) > 0 && n.length > s && !n.warned) { n.warned = !0; var d = new Error('Possible EventEmitter memory leak detected. ' + n.length + ' ' + String(t) + ' listeners added. Use emitter.setMaxListeners() to increase limit'); d.name = 'MaxListenersExceededWarning', d.emitter = e, d.type = t, d.count = n.length, l = d, console && console.warn && console.warn(l); } return e;
            } function d() { if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments); } function c(e, t, a) {
              var r = {
                  fired: !1, wrapFn: void 0, target: e, type: t, listener: a
                },
                s = d.bind(r); return s.listener = a, r.wrapFn = s, s;
            } function p(e, t, a) { var r = e._events; if (void 0 === r) return []; var s = r[t]; return void 0 === s ? [] : typeof s === 'function' ? a ? [s.listener || s] : [s] : a ? (function (e) { for (var t = new Array(e.length), a = 0; a < t.length; ++a)t[a] = e[a].listener || e[a]; return t; }(s)) : y(s, s.length); } function u(e) { var t = this._events; if (void 0 !== t) { var a = t[e]; if (typeof a === 'function') return 1; if (void 0 !== a) return a.length; } return 0; } function y(e, t) { for (var a = new Array(t), r = 0; r < t; ++r)a[r] = e[r]; return a; } function g(e, t, a, r) { if (typeof e.on === 'function')r.once ? e.once(t, a) : e.on(t, a); else { if (typeof e.addEventListener !== 'function') throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e); e.addEventListener(t, (function s(i) { r.once && e.removeEventListener(t, s), a(i); })); } }Object.defineProperty(i, 'defaultMaxListeners', { enumerable: !0, get: function () { return n; }, set: function (e) { if (typeof e !== 'number' || e < 0 || s(e)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + '.'); n = e; } }), i.init = function () { void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0; }, i.prototype.setMaxListeners = function (e) { if (typeof e !== 'number' || e < 0 || s(e)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + '.'); return this._maxListeners = e, this; }, i.prototype.getMaxListeners = function () { return m(this); }, i.prototype.emit = function (e) {
              for (var t = [], a = 1; a < arguments.length; a++)t.push(arguments[a]); var s = e === 'error',
                i = this._events; if (void 0 !== i)s = s && void 0 === i.error; else if (!s) return !1; if (s) { var n; if (t.length > 0 && (n = t[0]), n instanceof Error) throw n; var o = new Error('Unhandled error.' + (n ? ' (' + n.message + ')' : '')); throw o.context = n, o; } var m = i[e]; if (void 0 === m) return !1; if (typeof m === 'function')r(m, this, t); else {
                var l = m.length,
                  d = y(m, l); for (a = 0; a < l; ++a)r(d[a], this, t);
              } return !0;
            }, i.prototype.addListener = function (e, t) { return l(this, e, t, !1); }, i.prototype.on = i.prototype.addListener, i.prototype.prependListener = function (e, t) { return l(this, e, t, !0); }, i.prototype.once = function (e, t) { return o(t), this.on(e, c(this, e, t)), this; }, i.prototype.prependOnceListener = function (e, t) { return o(t), this.prependListener(e, c(this, e, t)), this; }, i.prototype.removeListener = function (e, t) {
              var a,
                r,
                s,
                i,
                n; if (o(t), void 0 === (r = this._events)) return this; if (void 0 === (a = r[e])) return this; if (a === t || a.listener === t)--this._eventsCount == 0 ? this._events = Object.create(null) : (delete r[e], r.removeListener && this.emit('removeListener', e, a.listener || t)); else if (typeof a !== 'function') { for (s = -1, i = a.length - 1; i >= 0; i--) if (a[i] === t || a[i].listener === t) { n = a[i].listener, s = i; break; } if (s < 0) return this; s === 0 ? a.shift() : (function (e, t) { for (;t + 1 < e.length; t++)e[t] = e[t + 1]; e.pop(); }(a, s)), a.length === 1 && (r[e] = a[0]), void 0 !== r.removeListener && this.emit('removeListener', e, n || t); } return this;
            }, i.prototype.off = i.prototype.removeListener, i.prototype.removeAllListeners = function (e) {
              var t,
                a,
                r; if (void 0 === (a = this._events)) return this; if (void 0 === a.removeListener) return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== a[e] && (--this._eventsCount == 0 ? this._events = Object.create(null) : delete a[e]), this; if (arguments.length === 0) {
                var s,
                  i = Object.keys(a); for (r = 0; r < i.length; ++r)(s = i[r]) !== 'removeListener' && this.removeAllListeners(s); return this.removeAllListeners('removeListener'), this._events = Object.create(null), this._eventsCount = 0, this;
              } if (typeof (t = a[e]) === 'function') this.removeListener(e, t); else if (void 0 !== t) for (r = t.length - 1; r >= 0; r--) this.removeListener(e, t[r]); return this;
            }, i.prototype.listeners = function (e) { return p(this, e, !0); }, i.prototype.rawListeners = function (e) { return p(this, e, !1); }, i.listenerCount = function (e, t) { return typeof e.listenerCount === 'function' ? e.listenerCount(t) : u.call(e, t); }, i.prototype.listenerCount = u, i.prototype.eventNames = function () { return this._eventsCount > 0 ? t(this._events) : []; };
          },
          598: ()=>{}
        },
        t = {}; function a(r) { var s = t[r]; if (void 0 !== s) return s.exports; var i = t[r] = { exports: {} }; return e[r](i, i.exports, a), i.exports; }a.d = (e, t)=>{ for (var r in t)a.o(t, r) && !a.o(e, r) && Object.defineProperty(e, r, { enumerable: !0, get: t[r] }); }, a.g = (function () { if (typeof globalThis === 'object') return globalThis; try { return this || new Function('return this')(); } catch (e) { if (typeof window === 'object') return window; } }()), a.o = (e, t)=>Object.prototype.hasOwnProperty.call(e, t), a.r = e=>{ typeof Symbol !== 'undefined' && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' }), Object.defineProperty(e, '__esModule', { value: !0 }); }; var r = {}; return (()=>{
        a.d(r, { default: ()=>Dc }); var e,
          t = {}; a.r(t), a.d(t, {
          AccessPolicy: ()=>Ht, AppendBlobAppendBlockExceptionHeaders: ()=>us, AppendBlobAppendBlockFromUrlExceptionHeaders: ()=>gs, AppendBlobAppendBlockFromUrlHeaders: ()=>ys, AppendBlobAppendBlockHeaders: ()=>ps, AppendBlobCreateExceptionHeaders: ()=>cs, AppendBlobCreateHeaders: ()=>ds, AppendBlobSealExceptionHeaders: ()=>xs, AppendBlobSealHeaders: ()=>hs, ArrowConfiguration: ()=>ea, ArrowField: ()=>ta, BlobAbortCopyFromURLExceptionHeaders: ()=>Hr, BlobAbortCopyFromURLHeaders: ()=>Ir, BlobAcquireLeaseExceptionHeaders: ()=>br, BlobAcquireLeaseHeaders: ()=>Nr, BlobBreakLeaseExceptionHeaders: ()=>wr, BlobBreakLeaseHeaders: ()=>Rr, BlobChangeLeaseExceptionHeaders: ()=>zr, BlobChangeLeaseHeaders: ()=>Pr, BlobCopyFromURLExceptionHeaders: ()=>Tr, BlobCopyFromURLHeaders: ()=>Mr, BlobCreateSnapshotExceptionHeaders: ()=>qr, BlobCreateSnapshotHeaders: ()=>Er, BlobDeleteExceptionHeaders: ()=>rr, BlobDeleteHeaders: ()=>ar, BlobDeleteImmutabilityPolicyExceptionHeaders: ()=>ur, BlobDeleteImmutabilityPolicyHeaders: ()=>pr, BlobDownloadExceptionHeaders: ()=>Ya, BlobDownloadHeaders: ()=>Za, BlobFlatListSegment: ()=>kt, BlobGetAccountInfoExceptionHeaders: ()=>Dr, BlobGetAccountInfoHeaders: ()=>Lr, BlobGetPropertiesExceptionHeaders: ()=>tr, BlobGetPropertiesHeaders: ()=>er, BlobGetTagsExceptionHeaders: ()=>Vr, BlobGetTagsHeaders: ()=>Ur, BlobHierarchyListSegment: ()=>jt, BlobItemInternal: ()=>Lt, BlobPrefix: ()=>Ut, BlobPropertiesInternal: ()=>Dt, BlobQueryExceptionHeaders: ()=>jr, BlobQueryHeaders: ()=>_r, BlobReleaseLeaseExceptionHeaders: ()=>Sr, BlobReleaseLeaseHeaders: ()=>fr, BlobRenewLeaseExceptionHeaders: ()=>vr, BlobRenewLeaseHeaders: ()=>Cr, BlobServiceProperties: ()=>ht, BlobServiceStatistics: ()=>vt, BlobSetExpiryExceptionHeaders: ()=>or, BlobSetExpiryHeaders: ()=>nr, BlobSetHttpHeadersExceptionHeaders: ()=>lr, BlobSetHttpHeadersHeaders: ()=>mr, BlobSetImmutabilityPolicyExceptionHeaders: ()=>cr, BlobSetImmutabilityPolicyHeaders: ()=>dr, BlobSetLegalHoldExceptionHeaders: ()=>gr, BlobSetLegalHoldHeaders: ()=>yr, BlobSetMetadataExceptionHeaders: ()=>xr, BlobSetMetadataHeaders: ()=>hr, BlobSetTagsExceptionHeaders: ()=>$r, BlobSetTagsHeaders: ()=>Fr, BlobSetTierExceptionHeaders: ()=>kr, BlobSetTierHeaders: ()=>Ar, BlobStartCopyFromURLExceptionHeaders: ()=>Br, BlobStartCopyFromURLHeaders: ()=>Or, BlobTag: ()=>Tt, BlobTags: ()=>Mt, BlobUndeleteExceptionHeaders: ()=>ir, BlobUndeleteHeaders: ()=>sr, Block: ()=>$t, BlockBlobCommitBlockListExceptionHeaders: ()=>ws, BlockBlobCommitBlockListHeaders: ()=>Rs, BlockBlobGetBlockListExceptionHeaders: ()=>qs, BlockBlobGetBlockListHeaders: ()=>Es, BlockBlobPutBlobFromUrlExceptionHeaders: ()=>Ss, BlockBlobPutBlobFromUrlHeaders: ()=>fs, BlockBlobStageBlockExceptionHeaders: ()=>vs, BlockBlobStageBlockFromURLExceptionHeaders: ()=>zs, BlockBlobStageBlockFromURLHeaders: ()=>Ps, BlockBlobStageBlockHeaders: ()=>Cs, BlockBlobUploadExceptionHeaders: ()=>bs, BlockBlobUploadHeaders: ()=>Ns, BlockList: ()=>Ft, BlockLookupList: ()=>Vt, ClearRange: ()=>Qt, ContainerAcquireLeaseExceptionHeaders: ()=>ka, ContainerAcquireLeaseHeaders: ()=>Aa, ContainerBreakLeaseExceptionHeaders: ()=>Va, ContainerBreakLeaseHeaders: ()=>Ua, ContainerChangeLeaseExceptionHeaders: ()=>$a, ContainerChangeLeaseHeaders: ()=>Fa, ContainerCreateExceptionHeaders: ()=>ba, ContainerCreateHeaders: ()=>Na, ContainerDeleteExceptionHeaders: ()=>va, ContainerDeleteHeaders: ()=>Ca, ContainerGetAccessPolicyExceptionHeaders: ()=>wa, ContainerGetAccessPolicyHeaders: ()=>Ra, ContainerGetAccountInfoExceptionHeaders: ()=>Ja, ContainerGetAccountInfoHeaders: ()=>Wa, ContainerGetPropertiesExceptionHeaders: ()=>Sa, ContainerGetPropertiesHeaders: ()=>fa, ContainerItem: ()=>Rt, ContainerListBlobFlatSegmentExceptionHeaders: ()=>Ga, ContainerListBlobFlatSegmentHeaders: ()=>Ka, ContainerListBlobHierarchySegmentExceptionHeaders: ()=>Xa, ContainerListBlobHierarchySegmentHeaders: ()=>Qa, ContainerProperties: ()=>wt, ContainerReleaseLeaseExceptionHeaders: ()=>Da, ContainerReleaseLeaseHeaders: ()=>La, ContainerRenameExceptionHeaders: ()=>Ta, ContainerRenameHeaders: ()=>Ma, ContainerRenewLeaseExceptionHeaders: ()=>ja, ContainerRenewLeaseHeaders: ()=>_a, ContainerRestoreExceptionHeaders: ()=>Ba, ContainerRestoreHeaders: ()=>Oa, ContainerSetAccessPolicyExceptionHeaders: ()=>qa, ContainerSetAccessPolicyHeaders: ()=>Ea, ContainerSetMetadataExceptionHeaders: ()=>za, ContainerSetMetadataHeaders: ()=>Pa, ContainerSubmitBatchExceptionHeaders: ()=>Ha, ContainerSubmitBatchHeaders: ()=>Ia, CorsRule: ()=>ft, DelimitedTextConfiguration: ()=>Zt, FilterBlobItem: ()=>Bt, FilterBlobSegment: ()=>Ot, GeoReplication: ()=>Pt, JsonTextConfiguration: ()=>Yt, KeyInfo: ()=>Et, ListBlobsFlatSegmentResponse: ()=>At, ListBlobsHierarchySegmentResponse: ()=>_t, ListContainersSegmentResponse: ()=>zt, Logging: ()=>xt, Metrics: ()=>bt, PageBlobClearPagesExceptionHeaders: ()=>Jr, PageBlobClearPagesHeaders: ()=>Wr, PageBlobCopyIncrementalExceptionHeaders: ()=>ls, PageBlobCopyIncrementalHeaders: ()=>ms, PageBlobCreateExceptionHeaders: ()=>Gr, PageBlobCreateHeaders: ()=>Kr, PageBlobGetPageRangesDiffExceptionHeaders: ()=>rs, PageBlobGetPageRangesDiffHeaders: ()=>as, PageBlobGetPageRangesExceptionHeaders: ()=>ts, PageBlobGetPageRangesHeaders: ()=>es, PageBlobResizeExceptionHeaders: ()=>is, PageBlobResizeHeaders: ()=>ss, PageBlobUpdateSequenceNumberExceptionHeaders: ()=>os, PageBlobUpdateSequenceNumberHeaders: ()=>ns, PageBlobUploadPagesExceptionHeaders: ()=>Xr, PageBlobUploadPagesFromURLExceptionHeaders: ()=>Yr, PageBlobUploadPagesFromURLHeaders: ()=>Zr, PageBlobUploadPagesHeaders: ()=>Qr, PageList: ()=>Kt, PageRange: ()=>Gt, QueryFormat: ()=>Jt, QueryRequest: ()=>Xt, QuerySerialization: ()=>Wt, RetentionPolicy: ()=>Nt, ServiceFilterBlobsExceptionHeaders: ()=>xa, ServiceFilterBlobsHeaders: ()=>ha, ServiceGetAccountInfoExceptionHeaders: ()=>ua, ServiceGetAccountInfoHeaders: ()=>pa, ServiceGetPropertiesExceptionHeaders: ()=>ia, ServiceGetPropertiesHeaders: ()=>sa, ServiceGetStatisticsExceptionHeaders: ()=>oa, ServiceGetStatisticsHeaders: ()=>na, ServiceGetUserDelegationKeyExceptionHeaders: ()=>ca, ServiceGetUserDelegationKeyHeaders: ()=>da, ServiceListContainersSegmentExceptionHeaders: ()=>la, ServiceListContainersSegmentHeaders: ()=>ma, ServiceSetPropertiesExceptionHeaders: ()=>ra, ServiceSetPropertiesHeaders: ()=>aa, ServiceSubmitBatchExceptionHeaders: ()=>ga, ServiceSubmitBatchHeaders: ()=>ya, SignedIdentifier: ()=>It, StaticWebsite: ()=>St, StorageError: ()=>Ct, UserDelegationKey: ()=>qt
        }), (function (e) { e[e.OFF = 0] = 'OFF', e[e.ERROR = 1] = 'ERROR', e[e.WARNING = 2] = 'WARNING', e[e.INFO = 3] = 'INFO'; }(e || (e = {}))); class s {
          constructor(e, t) { this._nextPolicy = e, this._options = t; }
  
          shouldLog(e) { return this._options.shouldLog(e); }
  
          log(e, t) { this._options.log(e, t); }
        } class i {
          constructor(e) { this._logger = e; }
  
          shouldLog(t) { return !!this._logger && t !== e.OFF && t <= this._logger.minimumLogLevel; }
  
          log(e, t) { this._logger && this.shouldLog(e) && this._logger.log(e, t); }
        } class n extends s {
          sendRequest(e) { return this._nextPolicy.sendRequest(this.signRequest(e)); }
  
          signRequest(e) { return e; }
        } class o extends n {constructor(e, t) { super(e, t); }} class m {create(e, t) { throw new Error('Method should be implemented in children classes.'); }} class l extends m {create(e, t) { return new o(e, t); }} const d = '$',
          c = '_'; var p,
          u = new Uint8Array(16); function y() { if (!p && !(p = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto))) throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported'); return p(u); } const g = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i,
          h = function (e) { return typeof e === 'string' && g.test(e); }; for (var x = [], N = 0; N < 256; ++N)x.push((N + 256).toString(16).substr(1)); const b = function (e, t, a) {
            var r = (e = e || {}).random || (e.rng || y)(); if (r[6] = 15 & r[6] | 64, r[8] = 63 & r[8] | 128, t) { a = a || 0; for (var s = 0; s < 16; ++s)t[a + s] = r[s]; return t; } return (function (e) {
              var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                a = (x[e[t + 0]] + x[e[t + 1]] + x[e[t + 2]] + x[e[t + 3]] + '-' + x[e[t + 4]] + x[e[t + 5]] + '-' + x[e[t + 6]] + x[e[t + 7]] + '-' + x[e[t + 8]] + x[e[t + 9]] + '-' + x[e[t + 10]] + x[e[t + 11]] + x[e[t + 12]] + x[e[t + 13]] + x[e[t + 14]] + x[e[t + 15]]).toLowerCase(); if (!h(a)) throw TypeError('Stringified UUID is invalid'); return a;
            }(r));
          },
          f = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i,
          S = typeof process !== 'undefined' && !!process.version && !!process.versions && !!process.versions.node; function C() { return b(); } const v = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/; function P(e, t, a) { return e && t ? e.split(t).join(a || '') : e; } function z(e) { const t = e; return t && typeof t.getToken === 'function' && (void 0 === t.signRequest || t.getToken.length > 0); } const R = new Error('ProxyPolicy is not supported in browser environment'); function w(e) { return { create: (e, t)=>{ throw R; } }; } class E {
          constructor() { this._rawQuery = {}; }
  
          any() { return Object.keys(this._rawQuery).length > 0; }
  
          keys() { return Object.keys(this._rawQuery); }
  
          set(e, t) { const a = t; if (e) if (a != null) { const t = Array.isArray(a) ? a : a.toString(); this._rawQuery[e] = t; } else delete this._rawQuery[e]; }
  
          get(e) { return e ? this._rawQuery[e] : void 0; }
  
          toString() { let e = ''; for (const t in this._rawQuery) { e && (e += '&'); const a = this._rawQuery[t]; if (Array.isArray(a)) { const r = []; for (const e of a)r.push(`${t}=${e}`); e += r.join('&'); } else e += `${t}=${a}`; } return e; }
  
          static parse(e) {
            const t = new E(); if (e) {
              e.startsWith('?') && (e = e.substring(1)); let a = 'ParameterName',
                r = '',
                s = ''; for (let i = 0; i < e.length; ++i) { const n = e[i]; switch (a) { case 'ParameterName': switch (n) { case '=': a = 'ParameterValue'; break; case '&': r = '', s = ''; break; default: r += n; } break; case 'ParameterValue': n === '&' ? (t.set(r, s), r = '', s = '', a = 'ParameterName') : s += n; break; default: throw new Error('Unrecognized URLQuery parse state: ' + a); } }a === 'ParameterValue' && t.set(r, s);
            } return t;
          }
        } class q {
          setScheme(e) { e ? this.set(e, 'SCHEME') : this._scheme = void 0; }
  
          getScheme() { return this._scheme; }
  
          setHost(e) { e ? this.set(e, 'SCHEME_OR_HOST') : this._host = void 0; }
  
          getHost() { return this._host; }
  
          setPort(e) { e == null || e === '' ? this._port = void 0 : this.set(e.toString(), 'PORT'); }
  
          getPort() { return this._port; }
  
          setPath(e) { if (e) { const t = e.indexOf('://'); if (t !== -1) { const a = e.lastIndexOf('/', t); this.set(a === -1 ? e : e.substr(a + 1), 'SCHEME'); } else this.set(e, 'PATH'); } else this._path = void 0; }
  
          appendPath(e) { if (e) { let t = this.getPath(); t && (t.endsWith('/') || (t += '/'), e.startsWith('/') && (e = e.substring(1)), e = t + e), this.set(e, 'PATH'); } }
  
          getPath() { return this._path; }
  
          setQuery(e) { this._query = e ? E.parse(e) : void 0; }
  
          setQueryParameter(e, t) { e && (this._query || (this._query = new E()), this._query.set(e, t)); }
  
          getQueryParameterValue(e) { return this._query ? this._query.get(e) : void 0; }
  
          getQuery() { return this._query ? this._query.toString() : void 0; }
  
          set(e, t) { const a = new B(e, t); for (;a.next();) { const e = a.current(); let t; if (e) switch (e.type) { case 'SCHEME': this._scheme = e.text || void 0; break; case 'HOST': this._host = e.text || void 0; break; case 'PORT': this._port = e.text || void 0; break; case 'PATH': t = e.text || void 0, this._path && this._path !== '/' && t === '/' || (this._path = t); break; case 'QUERY': this._query = E.parse(e.text); break; default: throw new Error(`Unrecognized URLTokenType: ${e.type}`); } } }
  
          toString() { let e = ''; return this._scheme && (e += `${this._scheme}://`), this._host && (e += this._host), this._port && (e += `:${this._port}`), this._path && (this._path.startsWith('/') || (e += '/'), e += this._path), this._query && this._query.any() && (e += `?${this._query.toString()}`), e; }
  
          replaceAll(e, t) { e && (this.setScheme(P(this.getScheme(), e, t)), this.setHost(P(this.getHost(), e, t)), this.setPort(P(this.getPort(), e, t)), this.setPath(P(this.getPath(), e, t)), this.setQuery(P(this.getQuery(), e, t))); }
  
          static parse(e) { const t = new q(); return t.set(e, 'SCHEME_OR_HOST'), t; }
        } class O {
          constructor(e, t) { this.text = e, this.type = t; }
  
          static scheme(e) { return new O(e, 'SCHEME'); }
  
          static host(e) { return new O(e, 'HOST'); }
  
          static port(e) { return new O(e, 'PORT'); }
  
          static path(e) { return new O(e, 'PATH'); }
  
          static query(e) { return new O(e, 'QUERY'); }
        } class B {
          constructor(e, t) { this._text = e, this._textLength = e ? e.length : 0, this._currentState = t != null ? t : 'SCHEME_OR_HOST', this._currentIndex = 0; }
  
          current() { return this._currentToken; }
  
          next() { if (M(this)) switch (this._currentState) { case 'SCHEME': !(function (e) { const t = (function (e) { return A(e, (e=>(function (e) { const t = e.charCodeAt(0); return t >= 48 && t <= 57 || t >= 65 && t <= 90 || t >= 97 && t <= 122; }(e)))); }(e)); e._currentToken = O.scheme(t), M(e) ? e._currentState = 'HOST' : e._currentState = 'DONE'; }(this)); break; case 'SCHEME_OR_HOST': !(function (e) { const t = k(e, ':', '/', '?'); M(e) ? T(e) === ':' ? H(e, 3) === '://' ? (e._currentToken = O.scheme(t), e._currentState = 'HOST') : (e._currentToken = O.host(t), e._currentState = 'PORT') : (e._currentToken = O.host(t), T(e) === '/' ? e._currentState = 'PATH' : e._currentState = 'QUERY') : (e._currentToken = O.host(t), e._currentState = 'DONE'); }(this)); break; case 'HOST': !(function (e) { H(e, 3) === '://' && I(e, 3); const t = k(e, ':', '/', '?'); e._currentToken = O.host(t), M(e) ? T(e) === ':' ? e._currentState = 'PORT' : T(e) === '/' ? e._currentState = 'PATH' : e._currentState = 'QUERY' : e._currentState = 'DONE'; }(this)); break; case 'PORT': !(function (e) { T(e) === ':' && I(e); const t = k(e, '/', '?'); e._currentToken = O.port(t), M(e) ? T(e) === '/' ? e._currentState = 'PATH' : e._currentState = 'QUERY' : e._currentState = 'DONE'; }(this)); break; case 'PATH': !(function (e) { const t = k(e, '?'); e._currentToken = O.path(t), M(e) ? e._currentState = 'QUERY' : e._currentState = 'DONE'; }(this)); break; case 'QUERY': !(function (e) { T(e) === '?' && I(e); const t = (function (e) { let t = ''; return e._currentIndex < e._textLength && (t = e._text.substring(e._currentIndex), e._currentIndex = e._textLength), t; }(e)); e._currentToken = O.query(t), e._currentState = 'DONE'; }(this)); break; default: throw new Error(`Unrecognized URLTokenizerState: ${this._currentState}`); } else this._currentToken = void 0; return !!this._currentToken; }
        } function M(e) { return e._currentIndex < e._textLength; } function T(e) { return e._text[e._currentIndex]; } function I(e, t) { M(e) && (t || (t = 1), e._currentIndex += t); } function H(e, t) { let a = e._currentIndex + t; return e._textLength < a && (a = e._textLength), e._text.substring(e._currentIndex, a); } function A(e, t) { let a = ''; for (;M(e);) { const r = T(e); if (!t(r)) break; a += r, I(e); } return a; } function k(e, ...t) { return A(e, (e=>t.indexOf(e) === -1)); } var L = typeof globalThis === 'object' ? globalThis : typeof self === 'object' ? self : typeof window === 'object' ? window : typeof a.g === 'object' ? a.g : {},
          D = '1.0.4',
          _ = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/,
          j = (function (e) {
            var t = new Set([e]),
              a = new Set(),
              r = e.match(_); if (!r) return function () { return !1; }; var s = +r[1],
              i = +r[2],
              n = +r[3]; if (r[4] != null) return function (t) { return t === e; }; function o(e) { return a.add(e), !1; } function m(e) { return t.add(e), !0; } return function (e) {
              if (t.has(e)) return !0; if (a.has(e)) return !1; var r = e.match(_); if (!r) return o(e); var l = +r[1],
                d = +r[2],
                c = +r[3]; return r[4] != null || s !== l ? o(e) : s === 0 ? i === d && n <= c ? m(e) : o(e) : i <= d ? m(e) : o(e);
            };
          }(D)),
          U = D.split('.')[0],
          V = Symbol.for('opentelemetry.js.api.' + U),
          F = L; function $(e, t, a, r) { var s; void 0 === r && (r = !1); var i = F[V] = (s = F[V]) !== null && void 0 !== s ? s : { version: D }; if (!r && i[e]) { var n = new Error('@opentelemetry/api: Attempted duplicate registration of API: ' + e); return a.error(n.stack || n.message), !1; } return i.version !== D ? (n = new Error('@opentelemetry/api: All API registration versions must match'), a.error(n.stack || n.message), !1) : (i[e] = t, a.debug('@opentelemetry/api: Registered a global for ' + e + ' v1.0.4.'), !0); } function K(e) {
          var t,
            a,
            r = (t = F[V]) === null || void 0 === t ? void 0 : t.version; if (r && j(r)) return (a = F[V]) === null || void 0 === a ? void 0 : a[e];
        } function G(e, t) { t.debug('@opentelemetry/api: Unregistering a global for ' + e + ' v1.0.4.'); var a = F[V]; a && delete a[e]; } var Q,
          X = (function () { function e(e) { this._namespace = e.namespace || 'DiagComponentLogger'; } return e.prototype.debug = function () { for (var e = [], t = 0; t < arguments.length; t++)e[t] = arguments[t]; return W('debug', this._namespace, e); }, e.prototype.error = function () { for (var e = [], t = 0; t < arguments.length; t++)e[t] = arguments[t]; return W('error', this._namespace, e); }, e.prototype.info = function () { for (var e = [], t = 0; t < arguments.length; t++)e[t] = arguments[t]; return W('info', this._namespace, e); }, e.prototype.warn = function () { for (var e = [], t = 0; t < arguments.length; t++)e[t] = arguments[t]; return W('warn', this._namespace, e); }, e.prototype.verbose = function () { for (var e = [], t = 0; t < arguments.length; t++)e[t] = arguments[t]; return W('verbose', this._namespace, e); }, e; }()); function W(e, t, a) { var r = K('diag'); if (r) return a.unshift(t), r[e].apply(r, a); }!(function (e) { e[e.NONE = 0] = 'NONE', e[e.ERROR = 30] = 'ERROR', e[e.WARN = 50] = 'WARN', e[e.INFO = 60] = 'INFO', e[e.DEBUG = 70] = 'DEBUG', e[e.VERBOSE = 80] = 'VERBOSE', e[e.ALL = 9999] = 'ALL'; }(Q || (Q = {}))); var J = (function () {
            function e() {
              function e(e) { return function () { for (var t = [], a = 0; a < arguments.length; a++)t[a] = arguments[a]; var r = K('diag'); if (r) return r[e].apply(r, t); }; } var t = this; t.setLogger = function (e, a) {
                var r,
                  s; if (void 0 === a && (a = Q.INFO), e === t) { var i = new Error('Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation'); return t.error((r = i.stack) !== null && void 0 !== r ? r : i.message), !1; } var n = K('diag'),
                  o = (function (e, t) {
                    function a(a, r) { var s = t[a]; return typeof s === 'function' && e >= r ? s.bind(t) : function () {}; } return e < Q.NONE ? e = Q.NONE : e > Q.ALL && (e = Q.ALL), t = t || {}, {
                      error: a('error', Q.ERROR), warn: a('warn', Q.WARN), info: a('info', Q.INFO), debug: a('debug', Q.DEBUG), verbose: a('verbose', Q.VERBOSE)
                    };
                  }(a, e)); if (n) { var m = (s = (new Error()).stack) !== null && void 0 !== s ? s : '<failed to generate stacktrace>'; n.warn('Current logger will be overwritten from ' + m), o.warn('Current logger will overwrite one already registered from ' + m); } return $('diag', o, t, !0);
              }, t.disable = function () { G('diag', t); }, t.createComponentLogger = function (e) { return new X(e); }, t.verbose = e('verbose'), t.debug = e('debug'), t.info = e('info'), t.warn = e('warn'), t.error = e('error');
            } return e.instance = function () { return this._instance || (this._instance = new e()), this._instance; }, e;
          }()),
          Z = (function () { function e(e) { this._entries = e ? new Map(e) : new Map(); } return e.prototype.getEntry = function (e) { var t = this._entries.get(e); if (t) return Object.assign({}, t); }, e.prototype.getAllEntries = function () { return Array.from(this._entries.entries()).map((function (e) { return [e[0], e[1]]; })); }, e.prototype.setEntry = function (t, a) { var r = new e(this._entries); return r._entries.set(t, a), r; }, e.prototype.removeEntry = function (t) { var a = new e(this._entries); return a._entries.delete(t), a; }, e.prototype.removeEntries = function () { for (var t = [], a = 0; a < arguments.length; a++)t[a] = arguments[a]; for (var r = new e(this._entries), s = 0, i = t; s < i.length; s++) { var n = i[s]; r._entries.delete(n); } return r; }, e.prototype.clear = function () { return new e(); }, e; }()); function Y(e) { return void 0 === e && (e = {}), new Z(new Map(Object.entries(e))); }Symbol('BaggageEntryMetadata'), J.instance(); var ee = { get: function (e, t) { if (e != null) return e[t]; }, keys: function (e) { return e == null ? [] : Object.keys(e); } },
          te = { set: function (e, t, a) { e != null && (e[t] = a); } }; function ae(e) { return Symbol.for(e); } var re,
          se = new function e(t) { var a = this; a._currentContext = t ? new Map(t) : new Map(), a.getValue = function (e) { return a._currentContext.get(e); }, a.setValue = function (t, r) { var s = new e(a._currentContext); return s._currentContext.set(t, r), s; }, a.deleteValue = function (t) { var r = new e(a._currentContext); return r._currentContext.delete(t), r; }; }(),
          ie = function (e, t) { for (var a = 0, r = t.length, s = e.length; a < r; a++, s++)e[s] = t[a]; return e; },
          ne = (function () { function e() {} return e.prototype.active = function () { return se; }, e.prototype.with = function (e, t, a) { for (var r = [], s = 3; s < arguments.length; s++)r[s - 3] = arguments[s]; return t.call.apply(t, ie([a], r)); }, e.prototype.bind = function (e, t) { return t; }, e.prototype.enable = function () { return this; }, e.prototype.disable = function () { return this; }, e; }()),
          oe = function (e, t) { for (var a = 0, r = t.length, s = e.length; a < r; a++, s++)e[s] = t[a]; return e; },
          me = 'context',
          le = new ne(),
          de = (function () { function e() {} return e.getInstance = function () { return this._instance || (this._instance = new e()), this._instance; }, e.prototype.setGlobalContextManager = function (e) { return $(me, e, J.instance()); }, e.prototype.active = function () { return this._getContextManager().active(); }, e.prototype.with = function (e, t, a) { for (var r, s = [], i = 3; i < arguments.length; i++)s[i - 3] = arguments[i]; return (r = this._getContextManager()).with.apply(r, oe([e, t, a], s)); }, e.prototype.bind = function (e, t) { return this._getContextManager().bind(e, t); }, e.prototype._getContextManager = function () { return K(me) || le; }, e.prototype.disable = function () { this._getContextManager().disable(), G(me, J.instance()); }, e; }()); !(function (e) { e[e.NONE = 0] = 'NONE', e[e.SAMPLED = 1] = 'SAMPLED'; }(re || (re = {}))); var ce = '0000000000000000',
          pe = '00000000000000000000000000000000',
          ue = { traceId: pe, spanId: ce, traceFlags: re.NONE },
          ye = (function () { function e(e) { void 0 === e && (e = ue), this._spanContext = e; } return e.prototype.spanContext = function () { return this._spanContext; }, e.prototype.setAttribute = function (e, t) { return this; }, e.prototype.setAttributes = function (e) { return this; }, e.prototype.addEvent = function (e, t) { return this; }, e.prototype.setStatus = function (e) { return this; }, e.prototype.updateName = function (e) { return this; }, e.prototype.end = function (e) {}, e.prototype.isRecording = function () { return !1; }, e.prototype.recordException = function (e, t) {}, e; }()),
          ge = ae('OpenTelemetry Context Key SPAN'); function he(e) { return e.getValue(ge) || void 0; } function xe(e, t) { return e.setValue(ge, t); } function Ne(e) { return e.deleteValue(ge); } function be(e, t) { return xe(e, new ye(t)); } function fe(e) { var t; return (t = he(e)) === null || void 0 === t ? void 0 : t.spanContext(); } var Se = /^([0-9a-f]{32})$/i,
          Ce = /^[0-9a-f]{16}$/i; function ve(e) {
          return a = e.traceId, Se.test(a) && a !== pe && (t = e.spanId, Ce.test(t) && t !== ce); var t,
            a;
        } function Pe(e) { return new ye(e); } var ze,
          Re,
          we,
          Ee = de.getInstance(),
          qe = (function () {
            function e() {} return e.prototype.startSpan = function (e, t, a) {
              if (t == null ? void 0 : t.root) return new ye(); var r,
                s = a && fe(a); return typeof (r = s) === 'object' && typeof r.spanId === 'string' && typeof r.traceId === 'string' && typeof r.traceFlags === 'number' && ve(s) ? new ye(s) : new ye();
            }, e.prototype.startActiveSpan = function (e, t, a, r) {
              var s,
                i,
                n; if (!(arguments.length < 2)) {
                arguments.length === 2 ? n = t : arguments.length === 3 ? (s = t, n = a) : (s = t, i = a, n = r); var o = i != null ? i : Ee.active(),
                  m = this.startSpan(e, s, o),
                  l = xe(o, m); return Ee.with(l, n, void 0, m);
              }
            }, e;
          }()),
          Oe = new qe(),
          Be = (function () { function e(e, t, a) { this._provider = e, this.name = t, this.version = a; } return e.prototype.startSpan = function (e, t, a) { return this._getTracer().startSpan(e, t, a); }, e.prototype.startActiveSpan = function (e, t, a, r) { var s = this._getTracer(); return Reflect.apply(s.startActiveSpan, s, arguments); }, e.prototype._getTracer = function () { if (this._delegate) return this._delegate; var e = this._provider.getDelegateTracer(this.name, this.version); return e ? (this._delegate = e, this._delegate) : Oe; }, e; }()),
          Me = new (function () { function e() {} return e.prototype.getTracer = function (e, t) { return new qe(); }, e; }())(),
          Te = (function () { function e() {} return e.prototype.getTracer = function (e, t) { var a; return (a = this.getDelegateTracer(e, t)) !== null && void 0 !== a ? a : new Be(this, e, t); }, e.prototype.getDelegate = function () { var e; return (e = this._delegate) !== null && void 0 !== e ? e : Me; }, e.prototype.setDelegate = function (e) { this._delegate = e; }, e.prototype.getDelegateTracer = function (e, t) { var a; return (a = this._delegate) === null || void 0 === a ? void 0 : a.getTracer(e, t); }, e; }()); !(function (e) { e[e.NOT_RECORD = 0] = 'NOT_RECORD', e[e.RECORD = 1] = 'RECORD', e[e.RECORD_AND_SAMPLED = 2] = 'RECORD_AND_SAMPLED'; }(ze || (ze = {}))), (function (e) { e[e.INTERNAL = 0] = 'INTERNAL', e[e.SERVER = 1] = 'SERVER', e[e.CLIENT = 2] = 'CLIENT', e[e.PRODUCER = 3] = 'PRODUCER', e[e.CONSUMER = 4] = 'CONSUMER'; }(Re || (Re = {}))), (function (e) { e[e.UNSET = 0] = 'UNSET', e[e.OK = 1] = 'OK', e[e.ERROR = 2] = 'ERROR'; }(we || (we = {}))); var Ie = 'trace',
          He = (function () { function e() { this._proxyTracerProvider = new Te(), this.wrapSpanContext = Pe, this.isSpanContextValid = ve, this.deleteSpan = Ne, this.getSpan = he, this.getSpanContext = fe, this.setSpan = xe, this.setSpanContext = be; } return e.getInstance = function () { return this._instance || (this._instance = new e()), this._instance; }, e.prototype.setGlobalTracerProvider = function (e) { var t = $(Ie, this._proxyTracerProvider, J.instance()); return t && this._proxyTracerProvider.setDelegate(e), t; }, e.prototype.getTracerProvider = function () { return K(Ie) || this._proxyTracerProvider; }, e.prototype.getTracer = function (e, t) { return this.getTracerProvider().getTracer(e, t); }, e.prototype.disable = function () { G(Ie, J.instance()), this._proxyTracerProvider = new Te(); }, e; }()),
          Ae = (function () { function e() {} return e.prototype.inject = function (e, t) {}, e.prototype.extract = function (e, t) { return e; }, e.prototype.fields = function () { return []; }, e; }()),
          ke = ae('OpenTelemetry Baggage Key'); function Le(e) { return e.getValue(ke) || void 0; } function De(e, t) { return e.setValue(ke, t); } function _e(e) { return e.deleteValue(ke); } var je,
          Ue = 'propagation',
          Ve = new Ae(),
          Fe = (function () { function e() { this.createBaggage = Y, this.getBaggage = Le, this.setBaggage = De, this.deleteBaggage = _e; } return e.getInstance = function () { return this._instance || (this._instance = new e()), this._instance; }, e.prototype.setGlobalPropagator = function (e) { return $(Ue, e, J.instance()); }, e.prototype.inject = function (e, t, a) { return void 0 === a && (a = te), this._getGlobalPropagator().inject(e, t, a); }, e.prototype.extract = function (e, t, a) { return void 0 === a && (a = ee), this._getGlobalPropagator().extract(e, t, a); }, e.prototype.fields = function () { return this._getGlobalPropagator().fields(); }, e.prototype.disable = function () { G(Ue, J.instance()); }, e.prototype._getGlobalPropagator = function () { return K(Ue) || Ve; }, e; }()),
          $e = de.getInstance(),
          Ke = He.getInstance(); function Ge(e, t) { return Ke.setSpan(e, t); }Fe.getInstance(), J.instance(), (function (e) { e[e.INTERNAL = 0] = 'INTERNAL', e[e.SERVER = 1] = 'SERVER', e[e.CLIENT = 2] = 'CLIENT', e[e.PRODUCER = 3] = 'PRODUCER', e[e.CONSUMER = 4] = 'CONSUMER'; }(je || (je = {}))); const Qe = $e; var Xe; !(function (e) { e[e.UNSET = 0] = 'UNSET', e[e.OK = 1] = 'OK', e[e.ERROR = 2] = 'ERROR'; }(Xe || (Xe = {}))); class We {
          constructor(e, t = {}) { this.originalResponse = e; }
  
          get acceptRanges() { return this.originalResponse.acceptRanges; }
  
          get cacheControl() { return this.originalResponse.cacheControl; }
  
          get contentDisposition() { return this.originalResponse.contentDisposition; }
  
          get contentEncoding() { return this.originalResponse.contentEncoding; }
  
          get contentLanguage() { return this.originalResponse.contentLanguage; }
  
          get blobSequenceNumber() { return this.originalResponse.blobSequenceNumber; }
  
          get blobType() { return this.originalResponse.blobType; }
  
          get contentLength() { return this.originalResponse.contentLength; }
  
          get contentMD5() { return this.originalResponse.contentMD5; }
  
          get contentRange() { return this.originalResponse.contentRange; }
  
          get contentType() { return this.originalResponse.contentType; }
  
          get copyCompletedOn() {}
  
          get copyId() { return this.originalResponse.copyId; }
  
          get copyProgress() { return this.originalResponse.copyProgress; }
  
          get copySource() { return this.originalResponse.copySource; }
  
          get copyStatus() { return this.originalResponse.copyStatus; }
  
          get copyStatusDescription() { return this.originalResponse.copyStatusDescription; }
  
          get leaseDuration() { return this.originalResponse.leaseDuration; }
  
          get leaseState() { return this.originalResponse.leaseState; }
  
          get leaseStatus() { return this.originalResponse.leaseStatus; }
  
          get date() { return this.originalResponse.date; }
  
          get blobCommittedBlockCount() { return this.originalResponse.blobCommittedBlockCount; }
  
          get etag() { return this.originalResponse.etag; }
  
          get errorCode() { return this.originalResponse.errorCode; }
  
          get isServerEncrypted() { return this.originalResponse.isServerEncrypted; }
  
          get blobContentMD5() { return this.originalResponse.blobContentMD5; }
  
          get lastModified() { return this.originalResponse.lastModified; }
  
          get metadata() { return this.originalResponse.metadata; }
  
          get requestId() { return this.originalResponse.requestId; }
  
          get clientRequestId() { return this.originalResponse.clientRequestId; }
  
          get version() { return this.originalResponse.version; }
  
          get encryptionKeySha256() { return this.originalResponse.encryptionKeySha256; }
  
          get contentCrc64() { return this.originalResponse.contentCrc64; }
  
          get blobBody() { throw Error('Quick query in browser is not supported yet.'); }
  
          get readableStreamBody() {}
  
          get _response() { return this.originalResponse._response; }
        } class Je {} var Ze = function (e, t) { return Ze = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) { e.__proto__ = t; } || function (e, t) { for (var a in t)Object.prototype.hasOwnProperty.call(t, a) && (e[a] = t[a]); }, Ze(e, t); }; function Ye(e) { return this instanceof Ye ? (this.v = e, this) : new Ye(e); } function et(e, t, a) {
          if (!Symbol.asyncIterator) throw new TypeError('Symbol.asyncIterator is not defined.'); var r,
            s = a.apply(e, t || []),
            i = []; return r = {}, n('next'), n('throw'), n('return'), r[Symbol.asyncIterator] = function () { return this; }, r; function n(e) { s[e] && (r[e] = function (t) { return new Promise((function (a, r) { i.push([e, t, a, r]) > 1 || o(e, t); })); }); } function o(e, t) { try { (a = s[e](t)).value instanceof Ye ? Promise.resolve(a.value.v).then(m, l) : d(i[0][2], a); } catch (e) { d(i[0][3], e); } var a; } function m(e) { o('next', e); } function l(e) { o('throw', e); } function d(e, t) { e(t), i.shift(), i.length && o(i[0][0], i[0][1]); }
        } function tt(e) {
          var t,
            a; return t = {}, r('next'), r('throw', (function (e) { throw e; })), r('return'), t[Symbol.iterator] = function () { return this; }, t; function r(r, s) { t[r] = e[r] ? function (t) { return (a = !a) ? { value: Ye(e[r](t)), done: r === 'return' } : s ? s(t) : t; } : s; }
        } function at(e) {
          if (!Symbol.asyncIterator) throw new TypeError('Symbol.asyncIterator is not defined.'); var t,
            a = e[Symbol.asyncIterator]; return a ? a.call(e) : (e = (function (e) {
            var t = typeof Symbol === 'function' && Symbol.iterator,
              a = t && e[t],
              r = 0; if (a) return a.call(e); if (e && typeof e.length === 'number') return { next: function () { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e }; } }; throw new TypeError(t ? 'Object is not iterable.' : 'Symbol.iterator is not defined.');
          }(e)), t = {}, r('next'), r('throw'), r('return'), t[Symbol.asyncIterator] = function () { return this; }, t); function r(a) { t[a] = e[a] && function (t) { return new Promise((function (r, s) { !(function (e, t, a, r) { Promise.resolve(r).then((function (t) { e({ value: t, done: a }); }), t); }(r, s, (t = e[a](t)).done, t.value)); })); }; }
        } function rt(e) {
          var t; const { requestOptions: a, tracingOptions: r } = e,
            s = (function (e, t) { var a = {}; for (var r in e)Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (a[r] = e[r]); if (e != null && typeof Object.getOwnPropertySymbols === 'function') { var s = 0; for (r = Object.getOwnPropertySymbols(e); s < r.length; s++)t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (a[r[s]] = e[r[s]]); } return a; }(e, ['requestOptions', 'tracingOptions'])); let i = s; return a && (i = Object.assign(Object.assign({}, i), a)), r && (i.tracingContext = r.tracingContext, i.spanOptions = (t = r) === null || void 0 === t ? void 0 : t.spanOptions), i;
        } function st(e) { let t = ''; for (let a = 0; a < e.length; a++)t += String.fromCharCode(e[a]); return btoa(t); } function it(e) {
          const t = atob(e),
            a = new Uint8Array(t.length); for (let e = 0; e < t.length; e++)a[e] = t.charCodeAt(e); return a;
        }Object.create, Object.create; class nt {
          constructor(e = {}, t) { this.modelMappers = e, this.isXML = t; }
  
          validateConstraints(e, t, a) {
            const r = (e, r)=>{ throw new Error(`"${a}" with value "${t}" should satisfy the constraint "${e}": ${r}.`); }; if (e.constraints && t != null) {
              const a = t,
                {
                  ExclusiveMaximum: s, ExclusiveMinimum: i, InclusiveMaximum: n, InclusiveMinimum: o, MaxItems: m, MaxLength: l, MinItems: d, MinLength: c, MultipleOf: p, Pattern: u, UniqueItems: y
                } = e.constraints; s != null && a >= s && r('ExclusiveMaximum', s), i != null && a <= i && r('ExclusiveMinimum', i), n != null && a > n && r('InclusiveMaximum', n), o != null && a < o && r('InclusiveMinimum', o); const g = t; if (m != null && g.length > m && r('MaxItems', m), l != null && g.length > l && r('MaxLength', l), d != null && g.length < d && r('MinItems', d), c != null && g.length < c && r('MinLength', c), p != null && a % p != 0 && r('MultipleOf', p), u) { const e = typeof u === 'string' ? new RegExp(u) : u; typeof t === 'string' && t.match(e) !== null || r('Pattern', u); }y && g.some(((e, t, a)=>a.indexOf(e) !== t)) && r('UniqueItems', y);
            }
          }
  
          serialize(e, t, a, r = {}) {
            var s,
              i,
              n; const o = { rootName: (s = r.rootName) !== null && void 0 !== s ? s : '', includeRoot: (i = r.includeRoot) !== null && void 0 !== i && i, xmlCharKey: (n = r.xmlCharKey) !== null && void 0 !== n ? n : c }; let m = {}; const l = e.type.name; a || (a = e.serializedName), l.match(/^Sequence$/i) !== null && (m = []), e.isConstant && (t = e.defaultValue); const { required: p, nullable: u } = e; if (p && u && void 0 === t) throw new Error(`${a} cannot be undefined.`); if (p && !u && t == null) throw new Error(`${a} cannot be null or undefined.`); if (!p && !1 === u && t === null) throw new Error(`${a} cannot be null.`); return t == null ? m = t : (this.validateConstraints(e, t, a), l.match(/^any$/i) !== null ? m = t : l.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i) !== null ? m = (function (e, t, a) { if (a != null) if (e.match(/^Number$/i) !== null) { if (typeof a !== 'number') throw new Error(`${t} with value ${a} must be of type number.`); } else if (e.match(/^String$/i) !== null) { if (typeof a.valueOf() !== 'string') throw new Error(`${t} with value "${a}" must be of type string.`); } else if (e.match(/^Uuid$/i) !== null) { if (typeof a.valueOf() !== 'string' || (r = a, !f.test(r))) throw new Error(`${t} with value "${a}" must be of type string and a valid uuid.`); } else if (e.match(/^Boolean$/i) !== null) { if (typeof a !== 'boolean') throw new Error(`${t} with value ${a} must be of type boolean.`); } else if (e.match(/^Stream$/i) !== null) { const e = typeof a; if (!(e === 'string' || e === 'function' || a instanceof ArrayBuffer || ArrayBuffer.isView(a) || (typeof Blob === 'function' || typeof Blob === 'object') && a instanceof Blob)) throw new Error(`${t} must be a string, Blob, ArrayBuffer, ArrayBufferView, or a function returning NodeJS.ReadableStream.`); } var r; return a; }(l, a, t)) : l.match(/^Enum$/i) !== null ? m = (function (e, t, a) { if (!t) throw new Error(`Please provide a set of allowedValues to validate ${e} as an Enum Type.`); if (!t.some((e=>typeof e.valueOf() === 'string' ? e.toLowerCase() === a.toLowerCase() : e === a))) throw new Error(`${a} is not a valid value for ${e}. The valid values are: ${JSON.stringify(t)}.`); return a; }(a, e.type.allowedValues, t)) : l.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) !== null ? m = (function (e, t, a) { if (t != null) if (e.match(/^Date$/i) !== null) { if (!(t instanceof Date || typeof t.valueOf() === 'string' && !isNaN(Date.parse(t)))) throw new Error(`${a} must be an instanceof Date or a string in ISO8601 format.`); t = t instanceof Date ? t.toISOString().substring(0, 10) : new Date(t).toISOString().substring(0, 10); } else if (e.match(/^DateTime$/i) !== null) { if (!(t instanceof Date || typeof t.valueOf() === 'string' && !isNaN(Date.parse(t)))) throw new Error(`${a} must be an instanceof Date or a string in ISO8601 format.`); t = t instanceof Date ? t.toISOString() : new Date(t).toISOString(); } else if (e.match(/^DateTimeRfc1123$/i) !== null) { if (!(t instanceof Date || typeof t.valueOf() === 'string' && !isNaN(Date.parse(t)))) throw new Error(`${a} must be an instanceof Date or a string in RFC-1123 format.`); t = t instanceof Date ? t.toUTCString() : new Date(t).toUTCString(); } else if (e.match(/^UnixTime$/i) !== null) { if (!(t instanceof Date || typeof t.valueOf() === 'string' && !isNaN(Date.parse(t)))) throw new Error(`${a} must be an instanceof Date or a string in RFC-1123/ISO8601 format for it to be serialized in UnixTime/Epoch format.`); t = (function (e) { if (e) return typeof e.valueOf() === 'string' && (e = new Date(e)), Math.floor(e.getTime() / 1e3); }(t)); } else if (e.match(/^TimeSpan$/i) !== null && !(function (e) { return v.test(e); }(t))) throw new Error(`${a} must be a string in ISO 8601 format. Instead was "${t}".`); return t; }(l, t, a)) : l.match(/^ByteArray$/i) !== null ? m = (function (e, t) { let a = ''; if (t != null) { if (!(t instanceof Uint8Array)) throw new Error(`${e} must be of type Uint8Array.`); a = st(t); } return a; }(a, t)) : l.match(/^Base64Url$/i) !== null ? m = (function (e, t) { let a = ''; if (t != null) { if (!(t instanceof Uint8Array)) throw new Error(`${e} must be of type Uint8Array.`); a = (function (e) { if (e) { if (!(e instanceof Uint8Array)) throw new Error('Please provide an input of type Uint8Array for converting to Base64Url.'); return (function (e, t) { let a = e.length; for (;a - 1 >= 0 && e[a - 1] === '=';)--a; return e.substr(0, a); }(st(e))).replace(/\+/g, '-').replace(/\//g, '_'); } }(t)) || ''; } return a; }(a, t)) : l.match(/^Sequence$/i) !== null ? m = (function (e, t, a, r, s, i) { if (!Array.isArray(a)) throw new Error(`${r} must be of type Array.`); const n = t.type.element; if (!n || typeof n !== 'object') throw new Error(`element" metadata for an Array must be defined in the mapper and it must of type "object" in ${r}.`); const o = []; for (let t = 0; t < a.length; t++) { const m = e.serialize(n, a[t], r, i); if (s && n.xmlNamespace) { const e = n.xmlNamespacePrefix ? `xmlns:${n.xmlNamespacePrefix}` : 'xmlns'; n.type.name === 'Composite' ? (o[t] = Object.assign({}, m), o[t][d] = { [e]: n.xmlNamespace }) : (o[t] = {}, o[t][i.xmlCharKey] = m, o[t][d] = { [e]: n.xmlNamespace }); } else o[t] = m; } return o; }(this, e, t, a, Boolean(this.isXML), o)) : l.match(/^Dictionary$/i) !== null ? m = (function (e, t, a, r, s, i) {
              if (typeof a !== 'object') throw new Error(`${r} must be of type object.`); const n = t.type.value; if (!n || typeof n !== 'object') throw new Error(`"value" metadata for a Dictionary must be defined in the mapper and it must of type "object" in ${r}.`); const o = {}; for (const t of Object.keys(a)) { const m = e.serialize(n, a[t], r, i); o[t] = dt(n, m, s, i); } if (s && t.xmlNamespace) {
                const e = t.xmlNamespacePrefix ? `xmlns:${t.xmlNamespacePrefix}` : 'xmlns',
                  a = o; return a[d] = { [e]: t.xmlNamespace }, a;
              } return o;
            }(this, e, t, a, Boolean(this.isXML), o)) : l.match(/^Composite$/i) !== null && (m = (function (e, t, a, r, s, i) {
              if (ut(e, t) && (t = pt(e, t, a, 'clientName')), a != null) {
                const n = {},
                  o = lt(e, t, r); for (const m of Object.keys(o)) {
                  const l = o[m]; if (l.readOnly) continue; let c,
                    p = n; if (e.isXML)c = l.xmlIsWrapped ? l.xmlName : l.xmlElementName || l.xmlName; else { const e = ot(l.serializedName); c = e.pop(); for (const t of e)p[t] != null || a[m] == null && void 0 === l.defaultValue || (p[t] = {}), p = p[t]; } if (p != null) { if (s && t.xmlNamespace) { const e = t.xmlNamespacePrefix ? `xmlns:${t.xmlNamespacePrefix}` : 'xmlns'; p[d] = Object.assign(Object.assign({}, p[d]), { [e]: t.xmlNamespace }); } const n = l.serializedName !== '' ? r + '.' + l.serializedName : r; let o = a[m]; const u = ut(e, t); u && u.clientName === m && o == null && (o = t.serializedName); const y = e.serialize(l, o, n, i); if (void 0 !== y && c != null) { const e = dt(l, y, s, i); s && l.xmlIsAttribute ? (p[d] = p[d] || {}, p[d][c] = y) : s && l.xmlIsWrapped ? p[c] = { [l.xmlElementName]: e } : p[c] = e; } }
                } const m = (function (e, t, a) { const r = t.type.additionalProperties; if (!r && t.type.className) { const r = mt(e, t, a); return r == null ? void 0 : r.type.additionalProperties; } return r; }(e, t, r)); if (m) { const t = Object.keys(o); for (const s in a)t.every((e=>e !== s)) && (n[s] = e.serialize(m, a[s], r + '["' + s + '"]', i)); } return n;
              } return a;
            }(this, e, t, a, Boolean(this.isXML), o)))), m;
          }
  
          deserialize(e, t, a, r = {}) {
            var s,
              i,
              n; const o = { rootName: (s = r.rootName) !== null && void 0 !== s ? s : '', includeRoot: (i = r.includeRoot) !== null && void 0 !== i && i, xmlCharKey: (n = r.xmlCharKey) !== null && void 0 !== n ? n : c }; if (t == null) return this.isXML && e.type.name === 'Sequence' && !e.xmlIsWrapped && (t = []), void 0 !== e.defaultValue && (t = e.defaultValue), t; let m; const l = e.type.name; if (a || (a = e.serializedName), l.match(/^Composite$/i) !== null) {
              m = (function (e, t, a, r, s) {
                var i; ut(e, t) && (t = pt(e, t, a, 'serializedName')); const n = lt(e, t, r); let o = {}; const m = []; for (const l of Object.keys(n)) {
                  const c = n[l],
                    p = ot(n[l].serializedName); m.push(p[0]); const { serializedName: u, xmlName: y, xmlElementName: g } = c; let h = r; u !== '' && void 0 !== u && (h = r + '.' + u); const x = c.headerCollectionPrefix; if (x) { const t = {}; for (const r of Object.keys(a))r.startsWith(x) && (t[r.substring(x.length)] = e.deserialize(c.type.value, a[r], h, s)), m.push(r); o[l] = t; } else if (e.isXML) {
                    if (c.xmlIsAttribute && a[d])o[l] = e.deserialize(c, a[d][y], h, s); else {
                      const t = g || y || u; if (c.xmlIsWrapped) {
                        const t = a[y],
                          r = (i = t == null ? void 0 : t[g]) !== null && void 0 !== i ? i : []; o[l] = e.deserialize(c, r, h, s);
                      } else { const r = a[t]; o[l] = e.deserialize(c, r, h, s); }
                    }
                  } else {
                    let r,
                      i = a; for (const e of p) { if (!i) break; i = i[e]; }r = i; const m = t.type.polymorphicDiscriminator; let d; if (m && l === m.clientName && r == null && (r = t.serializedName), Array.isArray(a[l]) && n[l].serializedName === '') { r = a[l]; const t = e.deserialize(c, r, h, s); for (const [e, a] of Object.entries(o))Object.prototype.hasOwnProperty.call(t, e) || (t[e] = a); o = t; } else void 0 === r && void 0 === c.defaultValue || (d = e.deserialize(c, r, h, s), o[l] = d);
                  }
                } const l = t.type.additionalProperties; if (l) { const t = e=>{ for (const t in n) if (ot(n[t].serializedName)[0] === e) return !1; return !0; }; for (const i in a)t(i) && (o[i] = e.deserialize(l, a[i], r + '["' + i + '"]', s)); } else if (a) for (const e of Object.keys(a)) void 0 !== o[e] || m.includes(e) || ct(e, s) || (o[e] = a[e]); return o;
              }(this, e, t, a, o));
            } else {
              if (this.isXML) {
                const e = o.xmlCharKey,
                  a = t; a[d] != null && a[e] != null && (t = a[e]);
              }l.match(/^Number$/i) !== null ? (m = parseFloat(t), isNaN(m) && (m = t)) : l.match(/^Boolean$/i) !== null ? m = t === 'true' || t !== 'false' && t : l.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) !== null ? m = t : l.match(/^(Date|DateTime|DateTimeRfc1123)$/i) !== null ? m = new Date(t) : l.match(/^UnixTime$/i) !== null ? m = (function (e) { if (e) return new Date(1e3 * e); }(t)) : l.match(/^ByteArray$/i) !== null ? m = it(t) : l.match(/^Base64Url$/i) !== null ? m = (function (e) { if (e) { if (e && typeof e.valueOf() !== 'string') throw new Error('Please provide an input of type string for converting to Uint8Array'); return it(e = e.replace(/-/g, '+').replace(/_/g, '/')); } }(t)) : l.match(/^Sequence$/i) !== null ? m = (function (e, t, a, r, s) { const i = t.type.element; if (!i || typeof i !== 'object') throw new Error(`element" metadata for an Array must be defined in the mapper and it must of type "object" in ${r}`); if (a) { Array.isArray(a) || (a = [a]); const t = []; for (let n = 0; n < a.length; n++)t[n] = e.deserialize(i, a[n], `${r}[${n}]`, s); return t; } return a; }(this, e, t, a, o)) : l.match(/^Dictionary$/i) !== null && (m = (function (e, t, a, r, s) { const i = t.type.value; if (!i || typeof i !== 'object') throw new Error(`"value" metadata for a Dictionary must be defined in the mapper and it must of type "object" in ${r}`); if (a) { const t = {}; for (const n of Object.keys(a))t[n] = e.deserialize(i, a[n], r, s); return t; } return a; }(this, e, t, a, o)));
            } return e.isConstant && (m = e.defaultValue), m;
          }
        } function ot(e) { const t = []; let a = ''; if (e) { const r = e.split('.'); for (const e of r)e.charAt(e.length - 1) === '\\' ? a += e.substr(0, e.length - 1) + '.' : (a += e, t.push(a), a = ''); } return t; } function mt(e, t, a) { const r = t.type.className; if (!r) throw new Error(`Class name for model "${a}" is not provided in the mapper "${JSON.stringify(t, void 0, 2)}".`); return e.modelMappers[r]; } function lt(e, t, a) { let r = t.type.modelProperties; if (!r) { const s = mt(e, t, a); if (!s) throw new Error(`mapper() cannot be null or undefined for model "${t.type.className}".`); if (r = s == null ? void 0 : s.type.modelProperties, !r) throw new Error(`modelProperties cannot be null or undefined in the mapper "${JSON.stringify(s)}" of type "${t.type.className}" for object "${a}".`); } return r; } function dt(e, t, a, r) { if (!a || !e.xmlNamespace) return t; const s = { [e.xmlNamespacePrefix ? `xmlns:${e.xmlNamespacePrefix}` : 'xmlns']: e.xmlNamespace }; if (['Composite'].includes(e.type.name)) { if (t[d]) return t; { const e = Object.assign({}, t); return e[d] = s, e; } } const i = {}; return i[r.xmlCharKey] = t, i[d] = s, i; } function ct(e, t) { return [d, t.xmlCharKey].includes(e); } function pt(e, t, a, r) {
          const s = ut(e, t); if (s) {
            const i = s[r]; if (i != null) {
              const r = a[i]; if (r != null) {
                const a = t.type.uberParent || t.type.className,
                  s = r === a ? r : a + '.' + r,
                  i = e.modelMappers.discriminators[s]; i && (t = i);
              }
            }
          } return t;
        } function ut(e, t) { return t.type.polymorphicDiscriminator || yt(e, t.type.uberParent) || yt(e, t.type.className); } function yt(e, t) { return t && e.modelMappers[t] && e.modelMappers[t].type.polymorphicDiscriminator; } const gt = (function (e) { const t = {}; for (const e of ['Base64Url', 'Boolean', 'ByteArray', 'Composite', 'Date', 'DateTime', 'DateTimeRfc1123', 'Dictionary', 'Enum', 'Number', 'Object', 'Sequence', 'String', 'Stream', 'TimeSpan', 'UnixTime'])t[e] = e; return t; }()),
          ht = {
            serializedName: 'BlobServiceProperties',
            xmlName: 'StorageServiceProperties',
            type: {
              name: 'Composite',
              className: 'BlobServiceProperties',
              modelProperties: {
                blobAnalyticsLogging: { serializedName: 'Logging', xmlName: 'Logging', type: { name: 'Composite', className: 'Logging' } },
                hourMetrics: { serializedName: 'HourMetrics', xmlName: 'HourMetrics', type: { name: 'Composite', className: 'Metrics' } },
                minuteMetrics: { serializedName: 'MinuteMetrics', xmlName: 'MinuteMetrics', type: { name: 'Composite', className: 'Metrics' } },
                cors: {
                  serializedName: 'Cors', xmlName: 'Cors', xmlIsWrapped: !0, xmlElementName: 'CorsRule', type: { name: 'Sequence', element: { type: { name: 'Composite', className: 'CorsRule' } } }
                },
                defaultServiceVersion: { serializedName: 'DefaultServiceVersion', xmlName: 'DefaultServiceVersion', type: { name: 'String' } },
                deleteRetentionPolicy: { serializedName: 'DeleteRetentionPolicy', xmlName: 'DeleteRetentionPolicy', type: { name: 'Composite', className: 'RetentionPolicy' } },
                staticWebsite: { serializedName: 'StaticWebsite', xmlName: 'StaticWebsite', type: { name: 'Composite', className: 'StaticWebsite' } }
              }
            }
          },
          xt = {
            serializedName: 'Logging',
            type: {
              name: 'Composite',
              className: 'Logging',
              modelProperties: {
                version: {
                  serializedName: 'Version', required: !0, xmlName: 'Version', type: { name: 'String' }
                },
                deleteProperty: {
                  serializedName: 'Delete', required: !0, xmlName: 'Delete', type: { name: 'Boolean' }
                },
                read: {
                  serializedName: 'Read', required: !0, xmlName: 'Read', type: { name: 'Boolean' }
                },
                write: {
                  serializedName: 'Write', required: !0, xmlName: 'Write', type: { name: 'Boolean' }
                },
                retentionPolicy: { serializedName: 'RetentionPolicy', xmlName: 'RetentionPolicy', type: { name: 'Composite', className: 'RetentionPolicy' } }
              }
            }
          },
          Nt = {
            serializedName: 'RetentionPolicy',
            type: {
              name: 'Composite',
              className: 'RetentionPolicy',
              modelProperties: {
                enabled: {
                  serializedName: 'Enabled', required: !0, xmlName: 'Enabled', type: { name: 'Boolean' }
                },
                days: {
                  constraints: { InclusiveMinimum: 1 }, serializedName: 'Days', xmlName: 'Days', type: { name: 'Number' }
                }
              }
            }
          },
          bt = {
            serializedName: 'Metrics',
            type: {
              name: 'Composite',
              className: 'Metrics',
              modelProperties: {
                version: { serializedName: 'Version', xmlName: 'Version', type: { name: 'String' } },
                enabled: {
                  serializedName: 'Enabled', required: !0, xmlName: 'Enabled', type: { name: 'Boolean' }
                },
                includeAPIs: { serializedName: 'IncludeAPIs', xmlName: 'IncludeAPIs', type: { name: 'Boolean' } },
                retentionPolicy: { serializedName: 'RetentionPolicy', xmlName: 'RetentionPolicy', type: { name: 'Composite', className: 'RetentionPolicy' } }
              }
            }
          },
          ft = {
            serializedName: 'CorsRule',
            type: {
              name: 'Composite',
              className: 'CorsRule',
              modelProperties: {
                allowedOrigins: {
                  serializedName: 'AllowedOrigins', required: !0, xmlName: 'AllowedOrigins', type: { name: 'String' }
                },
                allowedMethods: {
                  serializedName: 'AllowedMethods', required: !0, xmlName: 'AllowedMethods', type: { name: 'String' }
                },
                allowedHeaders: {
                  serializedName: 'AllowedHeaders', required: !0, xmlName: 'AllowedHeaders', type: { name: 'String' }
                },
                exposedHeaders: {
                  serializedName: 'ExposedHeaders', required: !0, xmlName: 'ExposedHeaders', type: { name: 'String' }
                },
                maxAgeInSeconds: {
                  constraints: { InclusiveMinimum: 0 }, serializedName: 'MaxAgeInSeconds', required: !0, xmlName: 'MaxAgeInSeconds', type: { name: 'Number' }
                }
              }
            }
          },
          St = {
            serializedName: 'StaticWebsite',
            type: {
              name: 'Composite',
              className: 'StaticWebsite',
              modelProperties: {
                enabled: {
                  serializedName: 'Enabled', required: !0, xmlName: 'Enabled', type: { name: 'Boolean' }
                },
                indexDocument: { serializedName: 'IndexDocument', xmlName: 'IndexDocument', type: { name: 'String' } },
                errorDocument404Path: { serializedName: 'ErrorDocument404Path', xmlName: 'ErrorDocument404Path', type: { name: 'String' } },
                defaultIndexDocumentPath: { serializedName: 'DefaultIndexDocumentPath', xmlName: 'DefaultIndexDocumentPath', type: { name: 'String' } }
              }
            }
          },
          Ct = { serializedName: 'StorageError', type: { name: 'Composite', className: 'StorageError', modelProperties: { message: { serializedName: 'Message', xmlName: 'Message', type: { name: 'String' } }, code: { serializedName: 'Code', xmlName: 'Code', type: { name: 'String' } } } } },
          vt = { serializedName: 'BlobServiceStatistics', xmlName: 'StorageServiceStats', type: { name: 'Composite', className: 'BlobServiceStatistics', modelProperties: { geoReplication: { serializedName: 'GeoReplication', xmlName: 'GeoReplication', type: { name: 'Composite', className: 'GeoReplication' } } } } },
          Pt = {
            serializedName: 'GeoReplication',
            type: {
              name: 'Composite',
              className: 'GeoReplication',
              modelProperties: {
                status: {
                  serializedName: 'Status', required: !0, xmlName: 'Status', type: { name: 'Enum', allowedValues: ['live', 'bootstrap', 'unavailable'] }
                },
                lastSyncOn: {
                  serializedName: 'LastSyncTime', required: !0, xmlName: 'LastSyncTime', type: { name: 'DateTimeRfc1123' }
                }
              }
            }
          },
          zt = {
            serializedName: 'ListContainersSegmentResponse',
            xmlName: 'EnumerationResults',
            type: {
              name: 'Composite',
              className: 'ListContainersSegmentResponse',
              modelProperties: {
                serviceEndpoint: {
                  serializedName: 'ServiceEndpoint', required: !0, xmlName: 'ServiceEndpoint', xmlIsAttribute: !0, type: { name: 'String' }
                },
                prefix: { serializedName: 'Prefix', xmlName: 'Prefix', type: { name: 'String' } },
                marker: { serializedName: 'Marker', xmlName: 'Marker', type: { name: 'String' } },
                maxPageSize: { serializedName: 'MaxResults', xmlName: 'MaxResults', type: { name: 'Number' } },
                containerItems: {
                  serializedName: 'ContainerItems', required: !0, xmlName: 'Containers', xmlIsWrapped: !0, xmlElementName: 'Container', type: { name: 'Sequence', element: { type: { name: 'Composite', className: 'ContainerItem' } } }
                },
                continuationToken: { serializedName: 'NextMarker', xmlName: 'NextMarker', type: { name: 'String' } }
              }
            }
          },
          Rt = {
            serializedName: 'ContainerItem',
            xmlName: 'Container',
            type: {
              name: 'Composite',
              className: 'ContainerItem',
              modelProperties: {
                name: {
                  serializedName: 'Name', required: !0, xmlName: 'Name', type: { name: 'String' }
                },
                deleted: { serializedName: 'Deleted', xmlName: 'Deleted', type: { name: 'Boolean' } },
                version: { serializedName: 'Version', xmlName: 'Version', type: { name: 'String' } },
                properties: { serializedName: 'Properties', xmlName: 'Properties', type: { name: 'Composite', className: 'ContainerProperties' } },
                metadata: { serializedName: 'Metadata', xmlName: 'Metadata', type: { name: 'Dictionary', value: { type: { name: 'String' } } } }
              }
            }
          },
          wt = {
            serializedName: 'ContainerProperties',
            type: {
              name: 'Composite',
              className: 'ContainerProperties',
              modelProperties: {
                lastModified: {
                  serializedName: 'Last-Modified', required: !0, xmlName: 'Last-Modified', type: { name: 'DateTimeRfc1123' }
                },
                etag: {
                  serializedName: 'Etag', required: !0, xmlName: 'Etag', type: { name: 'String' }
                },
                leaseStatus: { serializedName: 'LeaseStatus', xmlName: 'LeaseStatus', type: { name: 'Enum', allowedValues: ['locked', 'unlocked'] } },
                leaseState: { serializedName: 'LeaseState', xmlName: 'LeaseState', type: { name: 'Enum', allowedValues: ['available', 'leased', 'expired', 'breaking', 'broken'] } },
                leaseDuration: { serializedName: 'LeaseDuration', xmlName: 'LeaseDuration', type: { name: 'Enum', allowedValues: ['infinite', 'fixed'] } },
                publicAccess: { serializedName: 'PublicAccess', xmlName: 'PublicAccess', type: { name: 'Enum', allowedValues: ['container', 'blob'] } },
                hasImmutabilityPolicy: { serializedName: 'HasImmutabilityPolicy', xmlName: 'HasImmutabilityPolicy', type: { name: 'Boolean' } },
                hasLegalHold: { serializedName: 'HasLegalHold', xmlName: 'HasLegalHold', type: { name: 'Boolean' } },
                defaultEncryptionScope: { serializedName: 'DefaultEncryptionScope', xmlName: 'DefaultEncryptionScope', type: { name: 'String' } },
                preventEncryptionScopeOverride: { serializedName: 'DenyEncryptionScopeOverride', xmlName: 'DenyEncryptionScopeOverride', type: { name: 'Boolean' } },
                deletedOn: { serializedName: 'DeletedTime', xmlName: 'DeletedTime', type: { name: 'DateTimeRfc1123' } },
                remainingRetentionDays: { serializedName: 'RemainingRetentionDays', xmlName: 'RemainingRetentionDays', type: { name: 'Number' } },
                isImmutableStorageWithVersioningEnabled: { serializedName: 'ImmutableStorageWithVersioningEnabled', xmlName: 'ImmutableStorageWithVersioningEnabled', type: { name: 'Boolean' } }
              }
            }
          },
          Et = {
            serializedName: 'KeyInfo',
            type: {
              name: 'Composite',
              className: 'KeyInfo',
              modelProperties: {
                startsOn: {
                  serializedName: 'Start', required: !0, xmlName: 'Start', type: { name: 'String' }
                },
                expiresOn: {
                  serializedName: 'Expiry', required: !0, xmlName: 'Expiry', type: { name: 'String' }
                }
              }
            }
          },
          qt = {
            serializedName: 'UserDelegationKey',
            type: {
              name: 'Composite',
              className: 'UserDelegationKey',
              modelProperties: {
                signedObjectId: {
                  serializedName: 'SignedOid', required: !0, xmlName: 'SignedOid', type: { name: 'String' }
                },
                signedTenantId: {
                  serializedName: 'SignedTid', required: !0, xmlName: 'SignedTid', type: { name: 'String' }
                },
                signedStartsOn: {
                  serializedName: 'SignedStart', required: !0, xmlName: 'SignedStart', type: { name: 'String' }
                },
                signedExpiresOn: {
                  serializedName: 'SignedExpiry', required: !0, xmlName: 'SignedExpiry', type: { name: 'String' }
                },
                signedService: {
                  serializedName: 'SignedService', required: !0, xmlName: 'SignedService', type: { name: 'String' }
                },
                signedVersion: {
                  serializedName: 'SignedVersion', required: !0, xmlName: 'SignedVersion', type: { name: 'String' }
                },
                value: {
                  serializedName: 'Value', required: !0, xmlName: 'Value', type: { name: 'String' }
                }
              }
            }
          },
          Ot = {
            serializedName: 'FilterBlobSegment',
            xmlName: 'EnumerationResults',
            type: {
              name: 'Composite',
              className: 'FilterBlobSegment',
              modelProperties: {
                serviceEndpoint: {
                  serializedName: 'ServiceEndpoint', required: !0, xmlName: 'ServiceEndpoint', xmlIsAttribute: !0, type: { name: 'String' }
                },
                where: {
                  serializedName: 'Where', required: !0, xmlName: 'Where', type: { name: 'String' }
                },
                blobs: {
                  serializedName: 'Blobs', required: !0, xmlName: 'Blobs', xmlIsWrapped: !0, xmlElementName: 'Blob', type: { name: 'Sequence', element: { type: { name: 'Composite', className: 'FilterBlobItem' } } }
                },
                continuationToken: { serializedName: 'NextMarker', xmlName: 'NextMarker', type: { name: 'String' } }
              }
            }
          },
          Bt = {
            serializedName: 'FilterBlobItem',
            xmlName: 'Blob',
            type: {
              name: 'Composite',
              className: 'FilterBlobItem',
              modelProperties: {
                name: {
                  serializedName: 'Name', required: !0, xmlName: 'Name', type: { name: 'String' }
                },
                containerName: {
                  serializedName: 'ContainerName', required: !0, xmlName: 'ContainerName', type: { name: 'String' }
                },
                tags: { serializedName: 'Tags', xmlName: 'Tags', type: { name: 'Composite', className: 'BlobTags' } }
              }
            }
          },
          Mt = {
            serializedName: 'BlobTags',
            xmlName: 'Tags',
            type: {
              name: 'Composite',
              className: 'BlobTags',
              modelProperties: {
                blobTagSet: {
                  serializedName: 'BlobTagSet', required: !0, xmlName: 'TagSet', xmlIsWrapped: !0, xmlElementName: 'Tag', type: { name: 'Sequence', element: { type: { name: 'Composite', className: 'BlobTag' } } }
                }
              }
            }
          },
          Tt = {
            serializedName: 'BlobTag',
            xmlName: 'Tag',
            type: {
              name: 'Composite',
              className: 'BlobTag',
              modelProperties: {
                key: {
                  serializedName: 'Key', required: !0, xmlName: 'Key', type: { name: 'String' }
                },
                value: {
                  serializedName: 'Value', required: !0, xmlName: 'Value', type: { name: 'String' }
                }
              }
            }
          },
          It = {
            serializedName: 'SignedIdentifier',
            xmlName: 'SignedIdentifier',
            type: {
              name: 'Composite',
              className: 'SignedIdentifier',
              modelProperties: {
                id: {
                  serializedName: 'Id', required: !0, xmlName: 'Id', type: { name: 'String' }
                },
                accessPolicy: { serializedName: 'AccessPolicy', xmlName: 'AccessPolicy', type: { name: 'Composite', className: 'AccessPolicy' } }
              }
            }
          },
          Ht = { serializedName: 'AccessPolicy', type: { name: 'Composite', className: 'AccessPolicy', modelProperties: { startsOn: { serializedName: 'Start', xmlName: 'Start', type: { name: 'String' } }, expiresOn: { serializedName: 'Expiry', xmlName: 'Expiry', type: { name: 'String' } }, permissions: { serializedName: 'Permission', xmlName: 'Permission', type: { name: 'String' } } } } },
          At = {
            serializedName: 'ListBlobsFlatSegmentResponse',
            xmlName: 'EnumerationResults',
            type: {
              name: 'Composite',
              className: 'ListBlobsFlatSegmentResponse',
              modelProperties: {
                serviceEndpoint: {
                  serializedName: 'ServiceEndpoint', required: !0, xmlName: 'ServiceEndpoint', xmlIsAttribute: !0, type: { name: 'String' }
                },
                containerName: {
                  serializedName: 'ContainerName', required: !0, xmlName: 'ContainerName', xmlIsAttribute: !0, type: { name: 'String' }
                },
                prefix: { serializedName: 'Prefix', xmlName: 'Prefix', type: { name: 'String' } },
                marker: { serializedName: 'Marker', xmlName: 'Marker', type: { name: 'String' } },
                maxPageSize: { serializedName: 'MaxResults', xmlName: 'MaxResults', type: { name: 'Number' } },
                segment: { serializedName: 'Segment', xmlName: 'Blobs', type: { name: 'Composite', className: 'BlobFlatListSegment' } },
                continuationToken: { serializedName: 'NextMarker', xmlName: 'NextMarker', type: { name: 'String' } }
              }
            }
          },
          kt = {
            serializedName: 'BlobFlatListSegment',
            xmlName: 'Blobs',
            type: {
              name: 'Composite',
              className: 'BlobFlatListSegment',
              modelProperties: {
                blobItems: {
                  serializedName: 'BlobItems', required: !0, xmlName: 'BlobItems', xmlElementName: 'Blob', type: { name: 'Sequence', element: { type: { name: 'Composite', className: 'BlobItemInternal' } } }
                }
              }
            }
          },
          Lt = {
            serializedName: 'BlobItemInternal',
            xmlName: 'Blob',
            type: {
              name: 'Composite',
              className: 'BlobItemInternal',
              modelProperties: {
                name: {
                  serializedName: 'Name', required: !0, xmlName: 'Name', type: { name: 'String' }
                },
                deleted: {
                  serializedName: 'Deleted', required: !0, xmlName: 'Deleted', type: { name: 'Boolean' }
                },
                snapshot: {
                  serializedName: 'Snapshot', required: !0, xmlName: 'Snapshot', type: { name: 'String' }
                },
                versionId: { serializedName: 'VersionId', xmlName: 'VersionId', type: { name: 'String' } },
                isCurrentVersion: { serializedName: 'IsCurrentVersion', xmlName: 'IsCurrentVersion', type: { name: 'Boolean' } },
                properties: { serializedName: 'Properties', xmlName: 'Properties', type: { name: 'Composite', className: 'BlobPropertiesInternal' } },
                metadata: { serializedName: 'Metadata', xmlName: 'Metadata', type: { name: 'Dictionary', value: { type: { name: 'String' } } } },
                blobTags: { serializedName: 'BlobTags', xmlName: 'Tags', type: { name: 'Composite', className: 'BlobTags' } },
                objectReplicationMetadata: { serializedName: 'ObjectReplicationMetadata', xmlName: 'OrMetadata', type: { name: 'Dictionary', value: { type: { name: 'String' } } } },
                hasVersionsOnly: { serializedName: 'HasVersionsOnly', xmlName: 'HasVersionsOnly', type: { name: 'Boolean' } }
              }
            }
          },
          Dt = {
            serializedName: 'BlobPropertiesInternal',
            xmlName: 'Properties',
            type: {
              name: 'Composite',
              className: 'BlobPropertiesInternal',
              modelProperties: {
                createdOn: { serializedName: 'Creation-Time', xmlName: 'Creation-Time', type: { name: 'DateTimeRfc1123' } },
                lastModified: {
                  serializedName: 'Last-Modified', required: !0, xmlName: 'Last-Modified', type: { name: 'DateTimeRfc1123' }
                },
                etag: {
                  serializedName: 'Etag', required: !0, xmlName: 'Etag', type: { name: 'String' }
                },
                contentLength: { serializedName: 'Content-Length', xmlName: 'Content-Length', type: { name: 'Number' } },
                contentType: { serializedName: 'Content-Type', xmlName: 'Content-Type', type: { name: 'String' } },
                contentEncoding: { serializedName: 'Content-Encoding', xmlName: 'Content-Encoding', type: { name: 'String' } },
                contentLanguage: { serializedName: 'Content-Language', xmlName: 'Content-Language', type: { name: 'String' } },
                contentMD5: { serializedName: 'Content-MD5', xmlName: 'Content-MD5', type: { name: 'ByteArray' } },
                contentDisposition: { serializedName: 'Content-Disposition', xmlName: 'Content-Disposition', type: { name: 'String' } },
                cacheControl: { serializedName: 'Cache-Control', xmlName: 'Cache-Control', type: { name: 'String' } },
                blobSequenceNumber: { serializedName: 'x-ms-blob-sequence-number', xmlName: 'x-ms-blob-sequence-number', type: { name: 'Number' } },
                blobType: { serializedName: 'BlobType', xmlName: 'BlobType', type: { name: 'Enum', allowedValues: ['BlockBlob', 'PageBlob', 'AppendBlob'] } },
                leaseStatus: { serializedName: 'LeaseStatus', xmlName: 'LeaseStatus', type: { name: 'Enum', allowedValues: ['locked', 'unlocked'] } },
                leaseState: { serializedName: 'LeaseState', xmlName: 'LeaseState', type: { name: 'Enum', allowedValues: ['available', 'leased', 'expired', 'breaking', 'broken'] } },
                leaseDuration: { serializedName: 'LeaseDuration', xmlName: 'LeaseDuration', type: { name: 'Enum', allowedValues: ['infinite', 'fixed'] } },
                copyId: { serializedName: 'CopyId', xmlName: 'CopyId', type: { name: 'String' } },
                copyStatus: { serializedName: 'CopyStatus', xmlName: 'CopyStatus', type: { name: 'Enum', allowedValues: ['pending', 'success', 'aborted', 'failed'] } },
                copySource: { serializedName: 'CopySource', xmlName: 'CopySource', type: { name: 'String' } },
                copyProgress: { serializedName: 'CopyProgress', xmlName: 'CopyProgress', type: { name: 'String' } },
                copyCompletedOn: { serializedName: 'CopyCompletionTime', xmlName: 'CopyCompletionTime', type: { name: 'DateTimeRfc1123' } },
                copyStatusDescription: { serializedName: 'CopyStatusDescription', xmlName: 'CopyStatusDescription', type: { name: 'String' } },
                serverEncrypted: { serializedName: 'ServerEncrypted', xmlName: 'ServerEncrypted', type: { name: 'Boolean' } },
                incrementalCopy: { serializedName: 'IncrementalCopy', xmlName: 'IncrementalCopy', type: { name: 'Boolean' } },
                destinationSnapshot: { serializedName: 'DestinationSnapshot', xmlName: 'DestinationSnapshot', type: { name: 'String' } },
                deletedOn: { serializedName: 'DeletedTime', xmlName: 'DeletedTime', type: { name: 'DateTimeRfc1123' } },
                remainingRetentionDays: { serializedName: 'RemainingRetentionDays', xmlName: 'RemainingRetentionDays', type: { name: 'Number' } },
                accessTier: { serializedName: 'AccessTier', xmlName: 'AccessTier', type: { name: 'Enum', allowedValues: ['P4', 'P6', 'P10', 'P15', 'P20', 'P30', 'P40', 'P50', 'P60', 'P70', 'P80', 'Hot', 'Cool', 'Archive'] } },
                accessTierInferred: { serializedName: 'AccessTierInferred', xmlName: 'AccessTierInferred', type: { name: 'Boolean' } },
                archiveStatus: { serializedName: 'ArchiveStatus', xmlName: 'ArchiveStatus', type: { name: 'Enum', allowedValues: ['rehydrate-pending-to-hot', 'rehydrate-pending-to-cool'] } },
                customerProvidedKeySha256: { serializedName: 'CustomerProvidedKeySha256', xmlName: 'CustomerProvidedKeySha256', type: { name: 'String' } },
                encryptionScope: { serializedName: 'EncryptionScope', xmlName: 'EncryptionScope', type: { name: 'String' } },
                accessTierChangedOn: { serializedName: 'AccessTierChangeTime', xmlName: 'AccessTierChangeTime', type: { name: 'DateTimeRfc1123' } },
                tagCount: { serializedName: 'TagCount', xmlName: 'TagCount', type: { name: 'Number' } },
                expiresOn: { serializedName: 'Expiry-Time', xmlName: 'Expiry-Time', type: { name: 'DateTimeRfc1123' } },
                isSealed: { serializedName: 'Sealed', xmlName: 'Sealed', type: { name: 'Boolean' } },
                rehydratePriority: { serializedName: 'RehydratePriority', xmlName: 'RehydratePriority', type: { name: 'Enum', allowedValues: ['High', 'Standard'] } },
                lastAccessedOn: { serializedName: 'LastAccessTime', xmlName: 'LastAccessTime', type: { name: 'DateTimeRfc1123' } },
                immutabilityPolicyExpiresOn: { serializedName: 'ImmutabilityPolicyUntilDate', xmlName: 'ImmutabilityPolicyUntilDate', type: { name: 'DateTimeRfc1123' } },
                immutabilityPolicyMode: { serializedName: 'ImmutabilityPolicyMode', xmlName: 'ImmutabilityPolicyMode', type: { name: 'Enum', allowedValues: ['Mutable', 'Unlocked', 'Locked'] } },
                legalHold: { serializedName: 'LegalHold', xmlName: 'LegalHold', type: { name: 'Boolean' } }
              }
            }
          },
          _t = {
            serializedName: 'ListBlobsHierarchySegmentResponse',
            xmlName: 'EnumerationResults',
            type: {
              name: 'Composite',
              className: 'ListBlobsHierarchySegmentResponse',
              modelProperties: {
                serviceEndpoint: {
                  serializedName: 'ServiceEndpoint', required: !0, xmlName: 'ServiceEndpoint', xmlIsAttribute: !0, type: { name: 'String' }
                },
                containerName: {
                  serializedName: 'ContainerName', required: !0, xmlName: 'ContainerName', xmlIsAttribute: !0, type: { name: 'String' }
                },
                prefix: { serializedName: 'Prefix', xmlName: 'Prefix', type: { name: 'String' } },
                marker: { serializedName: 'Marker', xmlName: 'Marker', type: { name: 'String' } },
                maxPageSize: { serializedName: 'MaxResults', xmlName: 'MaxResults', type: { name: 'Number' } },
                delimiter: { serializedName: 'Delimiter', xmlName: 'Delimiter', type: { name: 'String' } },
                segment: { serializedName: 'Segment', xmlName: 'Blobs', type: { name: 'Composite', className: 'BlobHierarchyListSegment' } },
                continuationToken: { serializedName: 'NextMarker', xmlName: 'NextMarker', type: { name: 'String' } }
              }
            }
          },
          jt = {
            serializedName: 'BlobHierarchyListSegment',
            xmlName: 'Blobs',
            type: {
              name: 'Composite',
              className: 'BlobHierarchyListSegment',
              modelProperties: {
                blobPrefixes: {
                  serializedName: 'BlobPrefixes', xmlName: 'BlobPrefixes', xmlElementName: 'BlobPrefix', type: { name: 'Sequence', element: { type: { name: 'Composite', className: 'BlobPrefix' } } }
                },
                blobItems: {
                  serializedName: 'BlobItems', required: !0, xmlName: 'BlobItems', xmlElementName: 'Blob', type: { name: 'Sequence', element: { type: { name: 'Composite', className: 'BlobItemInternal' } } }
                }
              }
            }
          },
          Ut = {
            serializedName: 'BlobPrefix',
            type: {
              name: 'Composite',
              className: 'BlobPrefix',
              modelProperties: {
                name: {
                  serializedName: 'Name', required: !0, xmlName: 'Name', type: { name: 'String' }
                }
              }
            }
          },
          Vt = {
            serializedName: 'BlockLookupList',
            xmlName: 'BlockList',
            type: {
              name: 'Composite',
              className: 'BlockLookupList',
              modelProperties: {
                committed: {
                  serializedName: 'Committed', xmlName: 'Committed', xmlElementName: 'Committed', type: { name: 'Sequence', element: { type: { name: 'String' } } }
                },
                uncommitted: {
                  serializedName: 'Uncommitted', xmlName: 'Uncommitted', xmlElementName: 'Uncommitted', type: { name: 'Sequence', element: { type: { name: 'String' } } }
                },
                latest: {
                  serializedName: 'Latest', xmlName: 'Latest', xmlElementName: 'Latest', type: { name: 'Sequence', element: { type: { name: 'String' } } }
                }
              }
            }
          },
          Ft = {
            serializedName: 'BlockList',
            type: {
              name: 'Composite',
              className: 'BlockList',
              modelProperties: {
                committedBlocks: {
                  serializedName: 'CommittedBlocks', xmlName: 'CommittedBlocks', xmlIsWrapped: !0, xmlElementName: 'Block', type: { name: 'Sequence', element: { type: { name: 'Composite', className: 'Block' } } }
                },
                uncommittedBlocks: {
                  serializedName: 'UncommittedBlocks', xmlName: 'UncommittedBlocks', xmlIsWrapped: !0, xmlElementName: 'Block', type: { name: 'Sequence', element: { type: { name: 'Composite', className: 'Block' } } }
                }
              }
            }
          },
          $t = {
            serializedName: 'Block',
            type: {
              name: 'Composite',
              className: 'Block',
              modelProperties: {
                name: {
                  serializedName: 'Name', required: !0, xmlName: 'Name', type: { name: 'String' }
                },
                size: {
                  serializedName: 'Size', required: !0, xmlName: 'Size', type: { name: 'Number' }
                }
              }
            }
          },
          Kt = {
            serializedName: 'PageList',
            type: {
              name: 'Composite',
              className: 'PageList',
              modelProperties: {
                pageRange: {
                  serializedName: 'PageRange', xmlName: 'PageRange', xmlElementName: 'PageRange', type: { name: 'Sequence', element: { type: { name: 'Composite', className: 'PageRange' } } }
                },
                clearRange: {
                  serializedName: 'ClearRange', xmlName: 'ClearRange', xmlElementName: 'ClearRange', type: { name: 'Sequence', element: { type: { name: 'Composite', className: 'ClearRange' } } }
                }
              }
            }
          },
          Gt = {
            serializedName: 'PageRange',
            xmlName: 'PageRange',
            type: {
              name: 'Composite',
              className: 'PageRange',
              modelProperties: {
                start: {
                  serializedName: 'Start', required: !0, xmlName: 'Start', type: { name: 'Number' }
                },
                end: {
                  serializedName: 'End', required: !0, xmlName: 'End', type: { name: 'Number' }
                }
              }
            }
          },
          Qt = {
            serializedName: 'ClearRange',
            xmlName: 'ClearRange',
            type: {
              name: 'Composite',
              className: 'ClearRange',
              modelProperties: {
                start: {
                  serializedName: 'Start', required: !0, xmlName: 'Start', type: { name: 'Number' }
                },
                end: {
                  serializedName: 'End', required: !0, xmlName: 'End', type: { name: 'Number' }
                }
              }
            }
          },
          Xt = {
            serializedName: 'QueryRequest',
            xmlName: 'QueryRequest',
            type: {
              name: 'Composite',
              className: 'QueryRequest',
              modelProperties: {
                queryType: {
                  serializedName: 'QueryType', required: !0, xmlName: 'QueryType', type: { name: 'String' }
                },
                expression: {
                  serializedName: 'Expression', required: !0, xmlName: 'Expression', type: { name: 'String' }
                },
                inputSerialization: { serializedName: 'InputSerialization', xmlName: 'InputSerialization', type: { name: 'Composite', className: 'QuerySerialization' } },
                outputSerialization: { serializedName: 'OutputSerialization', xmlName: 'OutputSerialization', type: { name: 'Composite', className: 'QuerySerialization' } }
              }
            }
          },
          Wt = { serializedName: 'QuerySerialization', type: { name: 'Composite', className: 'QuerySerialization', modelProperties: { format: { serializedName: 'Format', xmlName: 'Format', type: { name: 'Composite', className: 'QueryFormat' } } } } },
          Jt = {
            serializedName: 'QueryFormat',
            type: {
              name: 'Composite',
              className: 'QueryFormat',
              modelProperties: {
                type: {
                  serializedName: 'Type', required: !0, xmlName: 'Type', type: { name: 'Enum', allowedValues: ['delimited', 'json', 'arrow', 'parquet'] }
                },
                delimitedTextConfiguration: { serializedName: 'DelimitedTextConfiguration', xmlName: 'DelimitedTextConfiguration', type: { name: 'Composite', className: 'DelimitedTextConfiguration' } },
                jsonTextConfiguration: { serializedName: 'JsonTextConfiguration', xmlName: 'JsonTextConfiguration', type: { name: 'Composite', className: 'JsonTextConfiguration' } },
                arrowConfiguration: { serializedName: 'ArrowConfiguration', xmlName: 'ArrowConfiguration', type: { name: 'Composite', className: 'ArrowConfiguration' } },
                parquetTextConfiguration: { serializedName: 'ParquetTextConfiguration', xmlName: 'ParquetTextConfiguration', type: { name: 'any' } }
              }
            }
          },
          Zt = {
            serializedName: 'DelimitedTextConfiguration',
            xmlName: 'DelimitedTextConfiguration',
            type: {
              name: 'Composite',
              className: 'DelimitedTextConfiguration',
              modelProperties: {
                columnSeparator: { serializedName: 'ColumnSeparator', xmlName: 'ColumnSeparator', type: { name: 'String' } }, fieldQuote: { serializedName: 'FieldQuote', xmlName: 'FieldQuote', type: { name: 'String' } }, recordSeparator: { serializedName: 'RecordSeparator', xmlName: 'RecordSeparator', type: { name: 'String' } }, escapeChar: { serializedName: 'EscapeChar', xmlName: 'EscapeChar', type: { name: 'String' } }, headersPresent: { serializedName: 'HeadersPresent', xmlName: 'HasHeaders', type: { name: 'Boolean' } }
              }
            }
          },
          Yt = { serializedName: 'JsonTextConfiguration', xmlName: 'JsonTextConfiguration', type: { name: 'Composite', className: 'JsonTextConfiguration', modelProperties: { recordSeparator: { serializedName: 'RecordSeparator', xmlName: 'RecordSeparator', type: { name: 'String' } } } } },
          ea = {
            serializedName: 'ArrowConfiguration',
            xmlName: 'ArrowConfiguration',
            type: {
              name: 'Composite',
              className: 'ArrowConfiguration',
              modelProperties: {
                schema: {
                  serializedName: 'Schema', required: !0, xmlName: 'Schema', xmlIsWrapped: !0, xmlElementName: 'Field', type: { name: 'Sequence', element: { type: { name: 'Composite', className: 'ArrowField' } } }
                }
              }
            }
          },
          ta = {
            serializedName: 'ArrowField',
            xmlName: 'Field',
            type: {
              name: 'Composite',
              className: 'ArrowField',
              modelProperties: {
                type: {
                  serializedName: 'Type', required: !0, xmlName: 'Type', type: { name: 'String' }
                },
                name: { serializedName: 'Name', xmlName: 'Name', type: { name: 'String' } },
                precision: { serializedName: 'Precision', xmlName: 'Precision', type: { name: 'Number' } },
                scale: { serializedName: 'Scale', xmlName: 'Scale', type: { name: 'Number' } }
              }
            }
          },
          aa = {
            serializedName: 'Service_setPropertiesHeaders',
            type: {
              name: 'Composite',
              className: 'ServiceSetPropertiesHeaders',
              modelProperties: {
                clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          ra = { serializedName: 'Service_setPropertiesExceptionHeaders', type: { name: 'Composite', className: 'ServiceSetPropertiesExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          sa = {
            serializedName: 'Service_getPropertiesHeaders',
            type: {
              name: 'Composite',
              className: 'ServiceGetPropertiesHeaders',
              modelProperties: {
                clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          ia = { serializedName: 'Service_getPropertiesExceptionHeaders', type: { name: 'Composite', className: 'ServiceGetPropertiesExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          na = {
            serializedName: 'Service_getStatisticsHeaders',
            type: {
              name: 'Composite',
              className: 'ServiceGetStatisticsHeaders',
              modelProperties: {
                clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          oa = { serializedName: 'Service_getStatisticsExceptionHeaders', type: { name: 'Composite', className: 'ServiceGetStatisticsExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          ma = {
            serializedName: 'Service_listContainersSegmentHeaders',
            type: {
              name: 'Composite',
              className: 'ServiceListContainersSegmentHeaders',
              modelProperties: {
                clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          la = { serializedName: 'Service_listContainersSegmentExceptionHeaders', type: { name: 'Composite', className: 'ServiceListContainersSegmentExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          da = {
            serializedName: 'Service_getUserDelegationKeyHeaders',
            type: {
              name: 'Composite',
              className: 'ServiceGetUserDelegationKeyHeaders',
              modelProperties: {
                clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          ca = { serializedName: 'Service_getUserDelegationKeyExceptionHeaders', type: { name: 'Composite', className: 'ServiceGetUserDelegationKeyExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          pa = {
            serializedName: 'Service_getAccountInfoHeaders',
            type: {
              name: 'Composite',
              className: 'ServiceGetAccountInfoHeaders',
              modelProperties: {
                clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, skuName: { serializedName: 'x-ms-sku-name', xmlName: 'x-ms-sku-name', type: { name: 'Enum', allowedValues: ['Standard_LRS', 'Standard_GRS', 'Standard_RAGRS', 'Standard_ZRS', 'Premium_LRS'] } }, accountKind: { serializedName: 'x-ms-account-kind', xmlName: 'x-ms-account-kind', type: { name: 'Enum', allowedValues: ['Storage', 'BlobStorage', 'StorageV2', 'FileStorage', 'BlockBlobStorage'] } }, isHierarchicalNamespaceEnabled: { serializedName: 'x-ms-is-hns-enabled', xmlName: 'x-ms-is-hns-enabled', type: { name: 'Boolean' } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          ua = { serializedName: 'Service_getAccountInfoExceptionHeaders', type: { name: 'Composite', className: 'ServiceGetAccountInfoExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          ya = {
            serializedName: 'Service_submitBatchHeaders',
            type: {
              name: 'Composite',
              className: 'ServiceSubmitBatchHeaders',
              modelProperties: {
                contentType: { serializedName: 'content-type', xmlName: 'content-type', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          ga = { serializedName: 'Service_submitBatchExceptionHeaders', type: { name: 'Composite', className: 'ServiceSubmitBatchExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          ha = {
            serializedName: 'Service_filterBlobsHeaders',
            type: {
              name: 'Composite',
              className: 'ServiceFilterBlobsHeaders',
              modelProperties: {
                clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          xa = { serializedName: 'Service_filterBlobsExceptionHeaders', type: { name: 'Composite', className: 'ServiceFilterBlobsExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          Na = {
            serializedName: 'Container_createHeaders',
            type: {
              name: 'Composite',
              className: 'ContainerCreateHeaders',
              modelProperties: {
                etag: { serializedName: 'etag', xmlName: 'etag', type: { name: 'String' } }, lastModified: { serializedName: 'last-modified', xmlName: 'last-modified', type: { name: 'DateTimeRfc1123' } }, clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          ba = { serializedName: 'Container_createExceptionHeaders', type: { name: 'Composite', className: 'ContainerCreateExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          fa = {
            serializedName: 'Container_getPropertiesHeaders',
            type: {
              name: 'Composite',
              className: 'ContainerGetPropertiesHeaders',
              modelProperties: {
                metadata: {
                  serializedName: 'x-ms-meta', xmlName: 'x-ms-meta', type: { name: 'Dictionary', value: { type: { name: 'String' } } }, headerCollectionPrefix: 'x-ms-meta-'
                },
                etag: { serializedName: 'etag', xmlName: 'etag', type: { name: 'String' } },
                lastModified: { serializedName: 'last-modified', xmlName: 'last-modified', type: { name: 'DateTimeRfc1123' } },
                leaseDuration: { serializedName: 'x-ms-lease-duration', xmlName: 'x-ms-lease-duration', type: { name: 'Enum', allowedValues: ['infinite', 'fixed'] } },
                leaseState: { serializedName: 'x-ms-lease-state', xmlName: 'x-ms-lease-state', type: { name: 'Enum', allowedValues: ['available', 'leased', 'expired', 'breaking', 'broken'] } },
                leaseStatus: { serializedName: 'x-ms-lease-status', xmlName: 'x-ms-lease-status', type: { name: 'Enum', allowedValues: ['locked', 'unlocked'] } },
                clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } },
                requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } },
                version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } },
                date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } },
                blobPublicAccess: { serializedName: 'x-ms-blob-public-access', xmlName: 'x-ms-blob-public-access', type: { name: 'Enum', allowedValues: ['container', 'blob'] } },
                hasImmutabilityPolicy: { serializedName: 'x-ms-has-immutability-policy', xmlName: 'x-ms-has-immutability-policy', type: { name: 'Boolean' } },
                hasLegalHold: { serializedName: 'x-ms-has-legal-hold', xmlName: 'x-ms-has-legal-hold', type: { name: 'Boolean' } },
                defaultEncryptionScope: { serializedName: 'x-ms-default-encryption-scope', xmlName: 'x-ms-default-encryption-scope', type: { name: 'String' } },
                denyEncryptionScopeOverride: { serializedName: 'x-ms-deny-encryption-scope-override', xmlName: 'x-ms-deny-encryption-scope-override', type: { name: 'Boolean' } },
                isImmutableStorageWithVersioningEnabled: { serializedName: 'x-ms-immutable-storage-with-versioning-enabled', xmlName: 'x-ms-immutable-storage-with-versioning-enabled', type: { name: 'Boolean' } },
                errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          Sa = { serializedName: 'Container_getPropertiesExceptionHeaders', type: { name: 'Composite', className: 'ContainerGetPropertiesExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          Ca = {
            serializedName: 'Container_deleteHeaders',
            type: {
              name: 'Composite',
              className: 'ContainerDeleteHeaders',
              modelProperties: {
                clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          va = { serializedName: 'Container_deleteExceptionHeaders', type: { name: 'Composite', className: 'ContainerDeleteExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          Pa = {
            serializedName: 'Container_setMetadataHeaders',
            type: {
              name: 'Composite',
              className: 'ContainerSetMetadataHeaders',
              modelProperties: {
                etag: { serializedName: 'etag', xmlName: 'etag', type: { name: 'String' } }, lastModified: { serializedName: 'last-modified', xmlName: 'last-modified', type: { name: 'DateTimeRfc1123' } }, clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          za = { serializedName: 'Container_setMetadataExceptionHeaders', type: { name: 'Composite', className: 'ContainerSetMetadataExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          Ra = {
            serializedName: 'Container_getAccessPolicyHeaders',
            type: {
              name: 'Composite',
              className: 'ContainerGetAccessPolicyHeaders',
              modelProperties: {
                blobPublicAccess: { serializedName: 'x-ms-blob-public-access', xmlName: 'x-ms-blob-public-access', type: { name: 'Enum', allowedValues: ['container', 'blob'] } }, etag: { serializedName: 'etag', xmlName: 'etag', type: { name: 'String' } }, lastModified: { serializedName: 'last-modified', xmlName: 'last-modified', type: { name: 'DateTimeRfc1123' } }, clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          wa = { serializedName: 'Container_getAccessPolicyExceptionHeaders', type: { name: 'Composite', className: 'ContainerGetAccessPolicyExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          Ea = {
            serializedName: 'Container_setAccessPolicyHeaders',
            type: {
              name: 'Composite',
              className: 'ContainerSetAccessPolicyHeaders',
              modelProperties: {
                etag: { serializedName: 'etag', xmlName: 'etag', type: { name: 'String' } }, lastModified: { serializedName: 'last-modified', xmlName: 'last-modified', type: { name: 'DateTimeRfc1123' } }, clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          qa = { serializedName: 'Container_setAccessPolicyExceptionHeaders', type: { name: 'Composite', className: 'ContainerSetAccessPolicyExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          Oa = {
            serializedName: 'Container_restoreHeaders',
            type: {
              name: 'Composite',
              className: 'ContainerRestoreHeaders',
              modelProperties: {
                clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          Ba = { serializedName: 'Container_restoreExceptionHeaders', type: { name: 'Composite', className: 'ContainerRestoreExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          Ma = {
            serializedName: 'Container_renameHeaders',
            type: {
              name: 'Composite',
              className: 'ContainerRenameHeaders',
              modelProperties: {
                clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          Ta = { serializedName: 'Container_renameExceptionHeaders', type: { name: 'Composite', className: 'ContainerRenameExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          Ia = { serializedName: 'Container_submitBatchHeaders', type: { name: 'Composite', className: 'ContainerSubmitBatchHeaders', modelProperties: { contentType: { serializedName: 'content-type', xmlName: 'content-type', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } } } } },
          Ha = { serializedName: 'Container_submitBatchExceptionHeaders', type: { name: 'Composite', className: 'ContainerSubmitBatchExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          Aa = {
            serializedName: 'Container_acquireLeaseHeaders',
            type: {
              name: 'Composite',
              className: 'ContainerAcquireLeaseHeaders',
              modelProperties: {
                etag: { serializedName: 'etag', xmlName: 'etag', type: { name: 'String' } }, lastModified: { serializedName: 'last-modified', xmlName: 'last-modified', type: { name: 'DateTimeRfc1123' } }, leaseId: { serializedName: 'x-ms-lease-id', xmlName: 'x-ms-lease-id', type: { name: 'String' } }, clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }
              }
            }
          },
          ka = { serializedName: 'Container_acquireLeaseExceptionHeaders', type: { name: 'Composite', className: 'ContainerAcquireLeaseExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          La = {
            serializedName: 'Container_releaseLeaseHeaders',
            type: {
              name: 'Composite',
              className: 'ContainerReleaseLeaseHeaders',
              modelProperties: {
                etag: { serializedName: 'etag', xmlName: 'etag', type: { name: 'String' } }, lastModified: { serializedName: 'last-modified', xmlName: 'last-modified', type: { name: 'DateTimeRfc1123' } }, clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }
              }
            }
          },
          Da = { serializedName: 'Container_releaseLeaseExceptionHeaders', type: { name: 'Composite', className: 'ContainerReleaseLeaseExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          _a = {
            serializedName: 'Container_renewLeaseHeaders',
            type: {
              name: 'Composite',
              className: 'ContainerRenewLeaseHeaders',
              modelProperties: {
                etag: { serializedName: 'etag', xmlName: 'etag', type: { name: 'String' } }, lastModified: { serializedName: 'last-modified', xmlName: 'last-modified', type: { name: 'DateTimeRfc1123' } }, leaseId: { serializedName: 'x-ms-lease-id', xmlName: 'x-ms-lease-id', type: { name: 'String' } }, clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }
              }
            }
          },
          ja = { serializedName: 'Container_renewLeaseExceptionHeaders', type: { name: 'Composite', className: 'ContainerRenewLeaseExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          Ua = {
            serializedName: 'Container_breakLeaseHeaders',
            type: {
              name: 'Composite',
              className: 'ContainerBreakLeaseHeaders',
              modelProperties: {
                etag: { serializedName: 'etag', xmlName: 'etag', type: { name: 'String' } }, lastModified: { serializedName: 'last-modified', xmlName: 'last-modified', type: { name: 'DateTimeRfc1123' } }, leaseTime: { serializedName: 'x-ms-lease-time', xmlName: 'x-ms-lease-time', type: { name: 'Number' } }, clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }
              }
            }
          },
          Va = { serializedName: 'Container_breakLeaseExceptionHeaders', type: { name: 'Composite', className: 'ContainerBreakLeaseExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          Fa = {
            serializedName: 'Container_changeLeaseHeaders',
            type: {
              name: 'Composite',
              className: 'ContainerChangeLeaseHeaders',
              modelProperties: {
                etag: { serializedName: 'etag', xmlName: 'etag', type: { name: 'String' } }, lastModified: { serializedName: 'last-modified', xmlName: 'last-modified', type: { name: 'DateTimeRfc1123' } }, leaseId: { serializedName: 'x-ms-lease-id', xmlName: 'x-ms-lease-id', type: { name: 'String' } }, clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }
              }
            }
          },
          $a = { serializedName: 'Container_changeLeaseExceptionHeaders', type: { name: 'Composite', className: 'ContainerChangeLeaseExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          Ka = {
            serializedName: 'Container_listBlobFlatSegmentHeaders',
            type: {
              name: 'Composite',
              className: 'ContainerListBlobFlatSegmentHeaders',
              modelProperties: {
                contentType: { serializedName: 'content-type', xmlName: 'content-type', type: { name: 'String' } }, clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          Ga = { serializedName: 'Container_listBlobFlatSegmentExceptionHeaders', type: { name: 'Composite', className: 'ContainerListBlobFlatSegmentExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          Qa = {
            serializedName: 'Container_listBlobHierarchySegmentHeaders',
            type: {
              name: 'Composite',
              className: 'ContainerListBlobHierarchySegmentHeaders',
              modelProperties: {
                contentType: { serializedName: 'content-type', xmlName: 'content-type', type: { name: 'String' } }, clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          Xa = { serializedName: 'Container_listBlobHierarchySegmentExceptionHeaders', type: { name: 'Composite', className: 'ContainerListBlobHierarchySegmentExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          Wa = {
            serializedName: 'Container_getAccountInfoHeaders',
            type: {
              name: 'Composite',
              className: 'ContainerGetAccountInfoHeaders',
              modelProperties: {
                clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, skuName: { serializedName: 'x-ms-sku-name', xmlName: 'x-ms-sku-name', type: { name: 'Enum', allowedValues: ['Standard_LRS', 'Standard_GRS', 'Standard_RAGRS', 'Standard_ZRS', 'Premium_LRS'] } }, accountKind: { serializedName: 'x-ms-account-kind', xmlName: 'x-ms-account-kind', type: { name: 'Enum', allowedValues: ['Storage', 'BlobStorage', 'StorageV2', 'FileStorage', 'BlockBlobStorage'] } }
              }
            }
          },
          Ja = { serializedName: 'Container_getAccountInfoExceptionHeaders', type: { name: 'Composite', className: 'ContainerGetAccountInfoExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          Za = {
            serializedName: 'Blob_downloadHeaders',
            type: {
              name: 'Composite',
              className: 'BlobDownloadHeaders',
              modelProperties: {
                lastModified: { serializedName: 'last-modified', xmlName: 'last-modified', type: { name: 'DateTimeRfc1123' } },
                metadata: {
                  serializedName: 'x-ms-meta', xmlName: 'x-ms-meta', type: { name: 'Dictionary', value: { type: { name: 'String' } } }, headerCollectionPrefix: 'x-ms-meta-'
                },
                objectReplicationPolicyId: { serializedName: 'x-ms-or-policy-id', xmlName: 'x-ms-or-policy-id', type: { name: 'String' } },
                objectReplicationRules: {
                  serializedName: 'x-ms-or', xmlName: 'x-ms-or', type: { name: 'Dictionary', value: { type: { name: 'String' } } }, headerCollectionPrefix: 'x-ms-or-'
                },
                contentLength: { serializedName: 'content-length', xmlName: 'content-length', type: { name: 'Number' } },
                contentType: { serializedName: 'content-type', xmlName: 'content-type', type: { name: 'String' } },
                contentRange: { serializedName: 'content-range', xmlName: 'content-range', type: { name: 'String' } },
                etag: { serializedName: 'etag', xmlName: 'etag', type: { name: 'String' } },
                contentMD5: { serializedName: 'content-md5', xmlName: 'content-md5', type: { name: 'ByteArray' } },
                contentEncoding: { serializedName: 'content-encoding', xmlName: 'content-encoding', type: { name: 'String' } },
                cacheControl: { serializedName: 'cache-control', xmlName: 'cache-control', type: { name: 'String' } },
                contentDisposition: { serializedName: 'content-disposition', xmlName: 'content-disposition', type: { name: 'String' } },
                contentLanguage: { serializedName: 'content-language', xmlName: 'content-language', type: { name: 'String' } },
                blobSequenceNumber: { serializedName: 'x-ms-blob-sequence-number', xmlName: 'x-ms-blob-sequence-number', type: { name: 'Number' } },
                blobType: { serializedName: 'x-ms-blob-type', xmlName: 'x-ms-blob-type', type: { name: 'Enum', allowedValues: ['BlockBlob', 'PageBlob', 'AppendBlob'] } },
                copyCompletedOn: { serializedName: 'x-ms-copy-completion-time', xmlName: 'x-ms-copy-completion-time', type: { name: 'DateTimeRfc1123' } },
                copyStatusDescription: { serializedName: 'x-ms-copy-status-description', xmlName: 'x-ms-copy-status-description', type: { name: 'String' } },
                copyId: { serializedName: 'x-ms-copy-id', xmlName: 'x-ms-copy-id', type: { name: 'String' } },
                copyProgress: { serializedName: 'x-ms-copy-progress', xmlName: 'x-ms-copy-progress', type: { name: 'String' } },
                copySource: { serializedName: 'x-ms-copy-source', xmlName: 'x-ms-copy-source', type: { name: 'String' } },
                copyStatus: { serializedName: 'x-ms-copy-status', xmlName: 'x-ms-copy-status', type: { name: 'Enum', allowedValues: ['pending', 'success', 'aborted', 'failed'] } },
                leaseDuration: { serializedName: 'x-ms-lease-duration', xmlName: 'x-ms-lease-duration', type: { name: 'Enum', allowedValues: ['infinite', 'fixed'] } },
                leaseState: { serializedName: 'x-ms-lease-state', xmlName: 'x-ms-lease-state', type: { name: 'Enum', allowedValues: ['available', 'leased', 'expired', 'breaking', 'broken'] } },
                leaseStatus: { serializedName: 'x-ms-lease-status', xmlName: 'x-ms-lease-status', type: { name: 'Enum', allowedValues: ['locked', 'unlocked'] } },
                clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } },
                requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } },
                version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } },
                versionId: { serializedName: 'x-ms-version-id', xmlName: 'x-ms-version-id', type: { name: 'String' } },
                isCurrentVersion: { serializedName: 'x-ms-is-current-version', xmlName: 'x-ms-is-current-version', type: { name: 'Boolean' } },
                acceptRanges: { serializedName: 'accept-ranges', xmlName: 'accept-ranges', type: { name: 'String' } },
                date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } },
                blobCommittedBlockCount: { serializedName: 'x-ms-blob-committed-block-count', xmlName: 'x-ms-blob-committed-block-count', type: { name: 'Number' } },
                isServerEncrypted: { serializedName: 'x-ms-server-encrypted', xmlName: 'x-ms-server-encrypted', type: { name: 'Boolean' } },
                encryptionKeySha256: { serializedName: 'x-ms-encryption-key-sha256', xmlName: 'x-ms-encryption-key-sha256', type: { name: 'String' } },
                encryptionScope: { serializedName: 'x-ms-encryption-scope', xmlName: 'x-ms-encryption-scope', type: { name: 'String' } },
                blobContentMD5: { serializedName: 'x-ms-blob-content-md5', xmlName: 'x-ms-blob-content-md5', type: { name: 'ByteArray' } },
                tagCount: { serializedName: 'x-ms-tag-count', xmlName: 'x-ms-tag-count', type: { name: 'Number' } },
                isSealed: { serializedName: 'x-ms-blob-sealed', xmlName: 'x-ms-blob-sealed', type: { name: 'Boolean' } },
                lastAccessed: { serializedName: 'x-ms-last-access-time', xmlName: 'x-ms-last-access-time', type: { name: 'DateTimeRfc1123' } },
                immutabilityPolicyExpiresOn: { serializedName: 'x-ms-immutability-policy-until-date', xmlName: 'x-ms-immutability-policy-until-date', type: { name: 'DateTimeRfc1123' } },
                immutabilityPolicyMode: { serializedName: 'x-ms-immutability-policy-mode', xmlName: 'x-ms-immutability-policy-mode', type: { name: 'Enum', allowedValues: ['Mutable', 'Unlocked', 'Locked'] } },
                legalHold: { serializedName: 'x-ms-legal-hold', xmlName: 'x-ms-legal-hold', type: { name: 'Boolean' } },
                errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } },
                contentCrc64: { serializedName: 'x-ms-content-crc64', xmlName: 'x-ms-content-crc64', type: { name: 'ByteArray' } }
              }
            }
          },
          Ya = { serializedName: 'Blob_downloadExceptionHeaders', type: { name: 'Composite', className: 'BlobDownloadExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          er = {
            serializedName: 'Blob_getPropertiesHeaders',
            type: {
              name: 'Composite',
              className: 'BlobGetPropertiesHeaders',
              modelProperties: {
                lastModified: { serializedName: 'last-modified', xmlName: 'last-modified', type: { name: 'DateTimeRfc1123' } },
                createdOn: { serializedName: 'x-ms-creation-time', xmlName: 'x-ms-creation-time', type: { name: 'DateTimeRfc1123' } },
                metadata: {
                  serializedName: 'x-ms-meta', xmlName: 'x-ms-meta', type: { name: 'Dictionary', value: { type: { name: 'String' } } }, headerCollectionPrefix: 'x-ms-meta-'
                },
                objectReplicationPolicyId: { serializedName: 'x-ms-or-policy-id', xmlName: 'x-ms-or-policy-id', type: { name: 'String' } },
                objectReplicationRules: {
                  serializedName: 'x-ms-or', xmlName: 'x-ms-or', type: { name: 'Dictionary', value: { type: { name: 'String' } } }, headerCollectionPrefix: 'x-ms-or-'
                },
                blobType: { serializedName: 'x-ms-blob-type', xmlName: 'x-ms-blob-type', type: { name: 'Enum', allowedValues: ['BlockBlob', 'PageBlob', 'AppendBlob'] } },
                copyCompletedOn: { serializedName: 'x-ms-copy-completion-time', xmlName: 'x-ms-copy-completion-time', type: { name: 'DateTimeRfc1123' } },
                copyStatusDescription: { serializedName: 'x-ms-copy-status-description', xmlName: 'x-ms-copy-status-description', type: { name: 'String' } },
                copyId: { serializedName: 'x-ms-copy-id', xmlName: 'x-ms-copy-id', type: { name: 'String' } },
                copyProgress: { serializedName: 'x-ms-copy-progress', xmlName: 'x-ms-copy-progress', type: { name: 'String' } },
                copySource: { serializedName: 'x-ms-copy-source', xmlName: 'x-ms-copy-source', type: { name: 'String' } },
                copyStatus: { serializedName: 'x-ms-copy-status', xmlName: 'x-ms-copy-status', type: { name: 'Enum', allowedValues: ['pending', 'success', 'aborted', 'failed'] } },
                isIncrementalCopy: { serializedName: 'x-ms-incremental-copy', xmlName: 'x-ms-incremental-copy', type: { name: 'Boolean' } },
                destinationSnapshot: { serializedName: 'x-ms-copy-destination-snapshot', xmlName: 'x-ms-copy-destination-snapshot', type: { name: 'String' } },
                leaseDuration: { serializedName: 'x-ms-lease-duration', xmlName: 'x-ms-lease-duration', type: { name: 'Enum', allowedValues: ['infinite', 'fixed'] } },
                leaseState: { serializedName: 'x-ms-lease-state', xmlName: 'x-ms-lease-state', type: { name: 'Enum', allowedValues: ['available', 'leased', 'expired', 'breaking', 'broken'] } },
                leaseStatus: { serializedName: 'x-ms-lease-status', xmlName: 'x-ms-lease-status', type: { name: 'Enum', allowedValues: ['locked', 'unlocked'] } },
                contentLength: { serializedName: 'content-length', xmlName: 'content-length', type: { name: 'Number' } },
                contentType: { serializedName: 'content-type', xmlName: 'content-type', type: { name: 'String' } },
                etag: { serializedName: 'etag', xmlName: 'etag', type: { name: 'String' } },
                contentMD5: { serializedName: 'content-md5', xmlName: 'content-md5', type: { name: 'ByteArray' } },
                contentEncoding: { serializedName: 'content-encoding', xmlName: 'content-encoding', type: { name: 'String' } },
                contentDisposition: { serializedName: 'content-disposition', xmlName: 'content-disposition', type: { name: 'String' } },
                contentLanguage: { serializedName: 'content-language', xmlName: 'content-language', type: { name: 'String' } },
                cacheControl: { serializedName: 'cache-control', xmlName: 'cache-control', type: { name: 'String' } },
                blobSequenceNumber: { serializedName: 'x-ms-blob-sequence-number', xmlName: 'x-ms-blob-sequence-number', type: { name: 'Number' } },
                clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } },
                requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } },
                version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } },
                date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } },
                acceptRanges: { serializedName: 'accept-ranges', xmlName: 'accept-ranges', type: { name: 'String' } },
                blobCommittedBlockCount: { serializedName: 'x-ms-blob-committed-block-count', xmlName: 'x-ms-blob-committed-block-count', type: { name: 'Number' } },
                isServerEncrypted: { serializedName: 'x-ms-server-encrypted', xmlName: 'x-ms-server-encrypted', type: { name: 'Boolean' } },
                encryptionKeySha256: { serializedName: 'x-ms-encryption-key-sha256', xmlName: 'x-ms-encryption-key-sha256', type: { name: 'String' } },
                encryptionScope: { serializedName: 'x-ms-encryption-scope', xmlName: 'x-ms-encryption-scope', type: { name: 'String' } },
                accessTier: { serializedName: 'x-ms-access-tier', xmlName: 'x-ms-access-tier', type: { name: 'String' } },
                accessTierInferred: { serializedName: 'x-ms-access-tier-inferred', xmlName: 'x-ms-access-tier-inferred', type: { name: 'Boolean' } },
                archiveStatus: { serializedName: 'x-ms-archive-status', xmlName: 'x-ms-archive-status', type: { name: 'String' } },
                accessTierChangedOn: { serializedName: 'x-ms-access-tier-change-time', xmlName: 'x-ms-access-tier-change-time', type: { name: 'DateTimeRfc1123' } },
                versionId: { serializedName: 'x-ms-version-id', xmlName: 'x-ms-version-id', type: { name: 'String' } },
                isCurrentVersion: { serializedName: 'x-ms-is-current-version', xmlName: 'x-ms-is-current-version', type: { name: 'Boolean' } },
                tagCount: { serializedName: 'x-ms-tag-count', xmlName: 'x-ms-tag-count', type: { name: 'Number' } },
                expiresOn: { serializedName: 'x-ms-expiry-time', xmlName: 'x-ms-expiry-time', type: { name: 'DateTimeRfc1123' } },
                isSealed: { serializedName: 'x-ms-blob-sealed', xmlName: 'x-ms-blob-sealed', type: { name: 'Boolean' } },
                rehydratePriority: { serializedName: 'x-ms-rehydrate-priority', xmlName: 'x-ms-rehydrate-priority', type: { name: 'Enum', allowedValues: ['High', 'Standard'] } },
                lastAccessed: { serializedName: 'x-ms-last-access-time', xmlName: 'x-ms-last-access-time', type: { name: 'DateTimeRfc1123' } },
                immutabilityPolicyExpiresOn: { serializedName: 'x-ms-immutability-policy-until-date', xmlName: 'x-ms-immutability-policy-until-date', type: { name: 'DateTimeRfc1123' } },
                immutabilityPolicyMode: { serializedName: 'x-ms-immutability-policy-mode', xmlName: 'x-ms-immutability-policy-mode', type: { name: 'Enum', allowedValues: ['Mutable', 'Unlocked', 'Locked'] } },
                legalHold: { serializedName: 'x-ms-legal-hold', xmlName: 'x-ms-legal-hold', type: { name: 'Boolean' } },
                errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          tr = { serializedName: 'Blob_getPropertiesExceptionHeaders', type: { name: 'Composite', className: 'BlobGetPropertiesExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          ar = {
            serializedName: 'Blob_deleteHeaders',
            type: {
              name: 'Composite',
              className: 'BlobDeleteHeaders',
              modelProperties: {
                clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          rr = { serializedName: 'Blob_deleteExceptionHeaders', type: { name: 'Composite', className: 'BlobDeleteExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          sr = {
            serializedName: 'Blob_undeleteHeaders',
            type: {
              name: 'Composite',
              className: 'BlobUndeleteHeaders',
              modelProperties: {
                clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          ir = { serializedName: 'Blob_undeleteExceptionHeaders', type: { name: 'Composite', className: 'BlobUndeleteExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          nr = {
            serializedName: 'Blob_setExpiryHeaders',
            type: {
              name: 'Composite',
              className: 'BlobSetExpiryHeaders',
              modelProperties: {
                etag: { serializedName: 'etag', xmlName: 'etag', type: { name: 'String' } }, lastModified: { serializedName: 'last-modified', xmlName: 'last-modified', type: { name: 'DateTimeRfc1123' } }, clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }
              }
            }
          },
          or = { serializedName: 'Blob_setExpiryExceptionHeaders', type: { name: 'Composite', className: 'BlobSetExpiryExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          mr = {
            serializedName: 'Blob_setHttpHeadersHeaders',
            type: {
              name: 'Composite',
              className: 'BlobSetHttpHeadersHeaders',
              modelProperties: {
                etag: { serializedName: 'etag', xmlName: 'etag', type: { name: 'String' } }, lastModified: { serializedName: 'last-modified', xmlName: 'last-modified', type: { name: 'DateTimeRfc1123' } }, blobSequenceNumber: { serializedName: 'x-ms-blob-sequence-number', xmlName: 'x-ms-blob-sequence-number', type: { name: 'Number' } }, clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          lr = { serializedName: 'Blob_setHttpHeadersExceptionHeaders', type: { name: 'Composite', className: 'BlobSetHttpHeadersExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          dr = {
            serializedName: 'Blob_setImmutabilityPolicyHeaders',
            type: {
              name: 'Composite',
              className: 'BlobSetImmutabilityPolicyHeaders',
              modelProperties: {
                clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, immutabilityPolicyExpiry: { serializedName: 'x-ms-immutability-policy-until-date', xmlName: 'x-ms-immutability-policy-until-date', type: { name: 'DateTimeRfc1123' } }, immutabilityPolicyMode: { serializedName: 'x-ms-immutability-policy-mode', xmlName: 'x-ms-immutability-policy-mode', type: { name: 'Enum', allowedValues: ['Mutable', 'Unlocked', 'Locked'] } }
              }
            }
          },
          cr = { serializedName: 'Blob_setImmutabilityPolicyExceptionHeaders', type: { name: 'Composite', className: 'BlobSetImmutabilityPolicyExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          pr = {
            serializedName: 'Blob_deleteImmutabilityPolicyHeaders',
            type: {
              name: 'Composite',
              className: 'BlobDeleteImmutabilityPolicyHeaders',
              modelProperties: {
                clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }
              }
            }
          },
          ur = { serializedName: 'Blob_deleteImmutabilityPolicyExceptionHeaders', type: { name: 'Composite', className: 'BlobDeleteImmutabilityPolicyExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          yr = {
            serializedName: 'Blob_setLegalHoldHeaders',
            type: {
              name: 'Composite',
              className: 'BlobSetLegalHoldHeaders',
              modelProperties: {
                clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, legalHold: { serializedName: 'x-ms-legal-hold', xmlName: 'x-ms-legal-hold', type: { name: 'Boolean' } }
              }
            }
          },
          gr = { serializedName: 'Blob_setLegalHoldExceptionHeaders', type: { name: 'Composite', className: 'BlobSetLegalHoldExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          hr = {
            serializedName: 'Blob_setMetadataHeaders',
            type: {
              name: 'Composite',
              className: 'BlobSetMetadataHeaders',
              modelProperties: {
                etag: { serializedName: 'etag', xmlName: 'etag', type: { name: 'String' } }, lastModified: { serializedName: 'last-modified', xmlName: 'last-modified', type: { name: 'DateTimeRfc1123' } }, clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, versionId: { serializedName: 'x-ms-version-id', xmlName: 'x-ms-version-id', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, isServerEncrypted: { serializedName: 'x-ms-request-server-encrypted', xmlName: 'x-ms-request-server-encrypted', type: { name: 'Boolean' } }, encryptionKeySha256: { serializedName: 'x-ms-encryption-key-sha256', xmlName: 'x-ms-encryption-key-sha256', type: { name: 'String' } }, encryptionScope: { serializedName: 'x-ms-encryption-scope', xmlName: 'x-ms-encryption-scope', type: { name: 'String' } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          xr = { serializedName: 'Blob_setMetadataExceptionHeaders', type: { name: 'Composite', className: 'BlobSetMetadataExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          Nr = {
            serializedName: 'Blob_acquireLeaseHeaders',
            type: {
              name: 'Composite',
              className: 'BlobAcquireLeaseHeaders',
              modelProperties: {
                etag: { serializedName: 'etag', xmlName: 'etag', type: { name: 'String' } }, lastModified: { serializedName: 'last-modified', xmlName: 'last-modified', type: { name: 'DateTimeRfc1123' } }, leaseId: { serializedName: 'x-ms-lease-id', xmlName: 'x-ms-lease-id', type: { name: 'String' } }, clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }
              }
            }
          },
          br = { serializedName: 'Blob_acquireLeaseExceptionHeaders', type: { name: 'Composite', className: 'BlobAcquireLeaseExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          fr = {
            serializedName: 'Blob_releaseLeaseHeaders',
            type: {
              name: 'Composite',
              className: 'BlobReleaseLeaseHeaders',
              modelProperties: {
                etag: { serializedName: 'etag', xmlName: 'etag', type: { name: 'String' } }, lastModified: { serializedName: 'last-modified', xmlName: 'last-modified', type: { name: 'DateTimeRfc1123' } }, clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }
              }
            }
          },
          Sr = { serializedName: 'Blob_releaseLeaseExceptionHeaders', type: { name: 'Composite', className: 'BlobReleaseLeaseExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          Cr = {
            serializedName: 'Blob_renewLeaseHeaders',
            type: {
              name: 'Composite',
              className: 'BlobRenewLeaseHeaders',
              modelProperties: {
                etag: { serializedName: 'etag', xmlName: 'etag', type: { name: 'String' } }, lastModified: { serializedName: 'last-modified', xmlName: 'last-modified', type: { name: 'DateTimeRfc1123' } }, leaseId: { serializedName: 'x-ms-lease-id', xmlName: 'x-ms-lease-id', type: { name: 'String' } }, clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }
              }
            }
          },
          vr = { serializedName: 'Blob_renewLeaseExceptionHeaders', type: { name: 'Composite', className: 'BlobRenewLeaseExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          Pr = {
            serializedName: 'Blob_changeLeaseHeaders',
            type: {
              name: 'Composite',
              className: 'BlobChangeLeaseHeaders',
              modelProperties: {
                etag: { serializedName: 'etag', xmlName: 'etag', type: { name: 'String' } }, lastModified: { serializedName: 'last-modified', xmlName: 'last-modified', type: { name: 'DateTimeRfc1123' } }, clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, leaseId: { serializedName: 'x-ms-lease-id', xmlName: 'x-ms-lease-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }
              }
            }
          },
          zr = { serializedName: 'Blob_changeLeaseExceptionHeaders', type: { name: 'Composite', className: 'BlobChangeLeaseExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          Rr = {
            serializedName: 'Blob_breakLeaseHeaders',
            type: {
              name: 'Composite',
              className: 'BlobBreakLeaseHeaders',
              modelProperties: {
                etag: { serializedName: 'etag', xmlName: 'etag', type: { name: 'String' } }, lastModified: { serializedName: 'last-modified', xmlName: 'last-modified', type: { name: 'DateTimeRfc1123' } }, leaseTime: { serializedName: 'x-ms-lease-time', xmlName: 'x-ms-lease-time', type: { name: 'Number' } }, clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }
              }
            }
          },
          wr = { serializedName: 'Blob_breakLeaseExceptionHeaders', type: { name: 'Composite', className: 'BlobBreakLeaseExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          Er = {
            serializedName: 'Blob_createSnapshotHeaders',
            type: {
              name: 'Composite',
              className: 'BlobCreateSnapshotHeaders',
              modelProperties: {
                snapshot: { serializedName: 'x-ms-snapshot', xmlName: 'x-ms-snapshot', type: { name: 'String' } }, etag: { serializedName: 'etag', xmlName: 'etag', type: { name: 'String' } }, lastModified: { serializedName: 'last-modified', xmlName: 'last-modified', type: { name: 'DateTimeRfc1123' } }, clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, versionId: { serializedName: 'x-ms-version-id', xmlName: 'x-ms-version-id', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, isServerEncrypted: { serializedName: 'x-ms-request-server-encrypted', xmlName: 'x-ms-request-server-encrypted', type: { name: 'Boolean' } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          qr = { serializedName: 'Blob_createSnapshotExceptionHeaders', type: { name: 'Composite', className: 'BlobCreateSnapshotExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          Or = {
            serializedName: 'Blob_startCopyFromURLHeaders',
            type: {
              name: 'Composite',
              className: 'BlobStartCopyFromURLHeaders',
              modelProperties: {
                etag: { serializedName: 'etag', xmlName: 'etag', type: { name: 'String' } }, lastModified: { serializedName: 'last-modified', xmlName: 'last-modified', type: { name: 'DateTimeRfc1123' } }, clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, versionId: { serializedName: 'x-ms-version-id', xmlName: 'x-ms-version-id', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, copyId: { serializedName: 'x-ms-copy-id', xmlName: 'x-ms-copy-id', type: { name: 'String' } }, copyStatus: { serializedName: 'x-ms-copy-status', xmlName: 'x-ms-copy-status', type: { name: 'Enum', allowedValues: ['pending', 'success', 'aborted', 'failed'] } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          Br = { serializedName: 'Blob_startCopyFromURLExceptionHeaders', type: { name: 'Composite', className: 'BlobStartCopyFromURLExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          Mr = {
            serializedName: 'Blob_copyFromURLHeaders',
            type: {
              name: 'Composite',
              className: 'BlobCopyFromURLHeaders',
              modelProperties: {
                etag: { serializedName: 'etag', xmlName: 'etag', type: { name: 'String' } },
                lastModified: { serializedName: 'last-modified', xmlName: 'last-modified', type: { name: 'DateTimeRfc1123' } },
                clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } },
                requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } },
                version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } },
                versionId: { serializedName: 'x-ms-version-id', xmlName: 'x-ms-version-id', type: { name: 'String' } },
                date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } },
                copyId: { serializedName: 'x-ms-copy-id', xmlName: 'x-ms-copy-id', type: { name: 'String' } },
                copyStatus: {
                  defaultValue: 'success', isConstant: !0, serializedName: 'x-ms-copy-status', type: { name: 'String' }
                },
                contentMD5: { serializedName: 'content-md5', xmlName: 'content-md5', type: { name: 'ByteArray' } },
                xMsContentCrc64: { serializedName: 'x-ms-content-crc64', xmlName: 'x-ms-content-crc64', type: { name: 'ByteArray' } },
                errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          Tr = { serializedName: 'Blob_copyFromURLExceptionHeaders', type: { name: 'Composite', className: 'BlobCopyFromURLExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          Ir = {
            serializedName: 'Blob_abortCopyFromURLHeaders',
            type: {
              name: 'Composite',
              className: 'BlobAbortCopyFromURLHeaders',
              modelProperties: {
                clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          Hr = { serializedName: 'Blob_abortCopyFromURLExceptionHeaders', type: { name: 'Composite', className: 'BlobAbortCopyFromURLExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          Ar = {
            serializedName: 'Blob_setTierHeaders',
            type: {
              name: 'Composite',
              className: 'BlobSetTierHeaders',
              modelProperties: {
                clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          kr = { serializedName: 'Blob_setTierExceptionHeaders', type: { name: 'Composite', className: 'BlobSetTierExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          Lr = {
            serializedName: 'Blob_getAccountInfoHeaders',
            type: {
              name: 'Composite',
              className: 'BlobGetAccountInfoHeaders',
              modelProperties: {
                clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, skuName: { serializedName: 'x-ms-sku-name', xmlName: 'x-ms-sku-name', type: { name: 'Enum', allowedValues: ['Standard_LRS', 'Standard_GRS', 'Standard_RAGRS', 'Standard_ZRS', 'Premium_LRS'] } }, accountKind: { serializedName: 'x-ms-account-kind', xmlName: 'x-ms-account-kind', type: { name: 'Enum', allowedValues: ['Storage', 'BlobStorage', 'StorageV2', 'FileStorage', 'BlockBlobStorage'] } }
              }
            }
          },
          Dr = { serializedName: 'Blob_getAccountInfoExceptionHeaders', type: { name: 'Composite', className: 'BlobGetAccountInfoExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          _r = {
            serializedName: 'Blob_queryHeaders',
            type: {
              name: 'Composite',
              className: 'BlobQueryHeaders',
              modelProperties: {
                lastModified: { serializedName: 'last-modified', xmlName: 'last-modified', type: { name: 'DateTimeRfc1123' } }, metadata: { serializedName: 'x-ms-meta', xmlName: 'x-ms-meta', type: { name: 'Dictionary', value: { type: { name: 'String' } } } }, contentLength: { serializedName: 'content-length', xmlName: 'content-length', type: { name: 'Number' } }, contentType: { serializedName: 'content-type', xmlName: 'content-type', type: { name: 'String' } }, contentRange: { serializedName: 'content-range', xmlName: 'content-range', type: { name: 'String' } }, etag: { serializedName: 'etag', xmlName: 'etag', type: { name: 'String' } }, contentMD5: { serializedName: 'content-md5', xmlName: 'content-md5', type: { name: 'ByteArray' } }, contentEncoding: { serializedName: 'content-encoding', xmlName: 'content-encoding', type: { name: 'String' } }, cacheControl: { serializedName: 'cache-control', xmlName: 'cache-control', type: { name: 'String' } }, contentDisposition: { serializedName: 'content-disposition', xmlName: 'content-disposition', type: { name: 'String' } }, contentLanguage: { serializedName: 'content-language', xmlName: 'content-language', type: { name: 'String' } }, blobSequenceNumber: { serializedName: 'x-ms-blob-sequence-number', xmlName: 'x-ms-blob-sequence-number', type: { name: 'Number' } }, blobType: { serializedName: 'x-ms-blob-type', xmlName: 'x-ms-blob-type', type: { name: 'Enum', allowedValues: ['BlockBlob', 'PageBlob', 'AppendBlob'] } }, copyCompletionTime: { serializedName: 'x-ms-copy-completion-time', xmlName: 'x-ms-copy-completion-time', type: { name: 'DateTimeRfc1123' } }, copyStatusDescription: { serializedName: 'x-ms-copy-status-description', xmlName: 'x-ms-copy-status-description', type: { name: 'String' } }, copyId: { serializedName: 'x-ms-copy-id', xmlName: 'x-ms-copy-id', type: { name: 'String' } }, copyProgress: { serializedName: 'x-ms-copy-progress', xmlName: 'x-ms-copy-progress', type: { name: 'String' } }, copySource: { serializedName: 'x-ms-copy-source', xmlName: 'x-ms-copy-source', type: { name: 'String' } }, copyStatus: { serializedName: 'x-ms-copy-status', xmlName: 'x-ms-copy-status', type: { name: 'Enum', allowedValues: ['pending', 'success', 'aborted', 'failed'] } }, leaseDuration: { serializedName: 'x-ms-lease-duration', xmlName: 'x-ms-lease-duration', type: { name: 'Enum', allowedValues: ['infinite', 'fixed'] } }, leaseState: { serializedName: 'x-ms-lease-state', xmlName: 'x-ms-lease-state', type: { name: 'Enum', allowedValues: ['available', 'leased', 'expired', 'breaking', 'broken'] } }, leaseStatus: { serializedName: 'x-ms-lease-status', xmlName: 'x-ms-lease-status', type: { name: 'Enum', allowedValues: ['locked', 'unlocked'] } }, clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, acceptRanges: { serializedName: 'accept-ranges', xmlName: 'accept-ranges', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, blobCommittedBlockCount: { serializedName: 'x-ms-blob-committed-block-count', xmlName: 'x-ms-blob-committed-block-count', type: { name: 'Number' } }, isServerEncrypted: { serializedName: 'x-ms-server-encrypted', xmlName: 'x-ms-server-encrypted', type: { name: 'Boolean' } }, encryptionKeySha256: { serializedName: 'x-ms-encryption-key-sha256', xmlName: 'x-ms-encryption-key-sha256', type: { name: 'String' } }, encryptionScope: { serializedName: 'x-ms-encryption-scope', xmlName: 'x-ms-encryption-scope', type: { name: 'String' } }, blobContentMD5: { serializedName: 'x-ms-blob-content-md5', xmlName: 'x-ms-blob-content-md5', type: { name: 'ByteArray' } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }, contentCrc64: { serializedName: 'x-ms-content-crc64', xmlName: 'x-ms-content-crc64', type: { name: 'ByteArray' } }
              }
            }
          },
          jr = { serializedName: 'Blob_queryExceptionHeaders', type: { name: 'Composite', className: 'BlobQueryExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          Ur = {
            serializedName: 'Blob_getTagsHeaders',
            type: {
              name: 'Composite',
              className: 'BlobGetTagsHeaders',
              modelProperties: {
                clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          Vr = { serializedName: 'Blob_getTagsExceptionHeaders', type: { name: 'Composite', className: 'BlobGetTagsExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          Fr = {
            serializedName: 'Blob_setTagsHeaders',
            type: {
              name: 'Composite',
              className: 'BlobSetTagsHeaders',
              modelProperties: {
                clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          $r = { serializedName: 'Blob_setTagsExceptionHeaders', type: { name: 'Composite', className: 'BlobSetTagsExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          Kr = {
            serializedName: 'PageBlob_createHeaders',
            type: {
              name: 'Composite',
              className: 'PageBlobCreateHeaders',
              modelProperties: {
                etag: { serializedName: 'etag', xmlName: 'etag', type: { name: 'String' } }, lastModified: { serializedName: 'last-modified', xmlName: 'last-modified', type: { name: 'DateTimeRfc1123' } }, contentMD5: { serializedName: 'content-md5', xmlName: 'content-md5', type: { name: 'ByteArray' } }, clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, versionId: { serializedName: 'x-ms-version-id', xmlName: 'x-ms-version-id', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, isServerEncrypted: { serializedName: 'x-ms-request-server-encrypted', xmlName: 'x-ms-request-server-encrypted', type: { name: 'Boolean' } }, encryptionKeySha256: { serializedName: 'x-ms-encryption-key-sha256', xmlName: 'x-ms-encryption-key-sha256', type: { name: 'String' } }, encryptionScope: { serializedName: 'x-ms-encryption-scope', xmlName: 'x-ms-encryption-scope', type: { name: 'String' } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          Gr = { serializedName: 'PageBlob_createExceptionHeaders', type: { name: 'Composite', className: 'PageBlobCreateExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          Qr = {
            serializedName: 'PageBlob_uploadPagesHeaders',
            type: {
              name: 'Composite',
              className: 'PageBlobUploadPagesHeaders',
              modelProperties: {
                etag: { serializedName: 'etag', xmlName: 'etag', type: { name: 'String' } }, lastModified: { serializedName: 'last-modified', xmlName: 'last-modified', type: { name: 'DateTimeRfc1123' } }, contentMD5: { serializedName: 'content-md5', xmlName: 'content-md5', type: { name: 'ByteArray' } }, xMsContentCrc64: { serializedName: 'x-ms-content-crc64', xmlName: 'x-ms-content-crc64', type: { name: 'ByteArray' } }, blobSequenceNumber: { serializedName: 'x-ms-blob-sequence-number', xmlName: 'x-ms-blob-sequence-number', type: { name: 'Number' } }, clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, isServerEncrypted: { serializedName: 'x-ms-request-server-encrypted', xmlName: 'x-ms-request-server-encrypted', type: { name: 'Boolean' } }, encryptionKeySha256: { serializedName: 'x-ms-encryption-key-sha256', xmlName: 'x-ms-encryption-key-sha256', type: { name: 'String' } }, encryptionScope: { serializedName: 'x-ms-encryption-scope', xmlName: 'x-ms-encryption-scope', type: { name: 'String' } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          Xr = { serializedName: 'PageBlob_uploadPagesExceptionHeaders', type: { name: 'Composite', className: 'PageBlobUploadPagesExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          Wr = {
            serializedName: 'PageBlob_clearPagesHeaders',
            type: {
              name: 'Composite',
              className: 'PageBlobClearPagesHeaders',
              modelProperties: {
                etag: { serializedName: 'etag', xmlName: 'etag', type: { name: 'String' } }, lastModified: { serializedName: 'last-modified', xmlName: 'last-modified', type: { name: 'DateTimeRfc1123' } }, contentMD5: { serializedName: 'content-md5', xmlName: 'content-md5', type: { name: 'ByteArray' } }, xMsContentCrc64: { serializedName: 'x-ms-content-crc64', xmlName: 'x-ms-content-crc64', type: { name: 'ByteArray' } }, blobSequenceNumber: { serializedName: 'x-ms-blob-sequence-number', xmlName: 'x-ms-blob-sequence-number', type: { name: 'Number' } }, clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          Jr = { serializedName: 'PageBlob_clearPagesExceptionHeaders', type: { name: 'Composite', className: 'PageBlobClearPagesExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          Zr = {
            serializedName: 'PageBlob_uploadPagesFromURLHeaders',
            type: {
              name: 'Composite',
              className: 'PageBlobUploadPagesFromURLHeaders',
              modelProperties: {
                etag: { serializedName: 'etag', xmlName: 'etag', type: { name: 'String' } }, lastModified: { serializedName: 'last-modified', xmlName: 'last-modified', type: { name: 'DateTimeRfc1123' } }, contentMD5: { serializedName: 'content-md5', xmlName: 'content-md5', type: { name: 'ByteArray' } }, xMsContentCrc64: { serializedName: 'x-ms-content-crc64', xmlName: 'x-ms-content-crc64', type: { name: 'ByteArray' } }, blobSequenceNumber: { serializedName: 'x-ms-blob-sequence-number', xmlName: 'x-ms-blob-sequence-number', type: { name: 'Number' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, isServerEncrypted: { serializedName: 'x-ms-request-server-encrypted', xmlName: 'x-ms-request-server-encrypted', type: { name: 'Boolean' } }, encryptionKeySha256: { serializedName: 'x-ms-encryption-key-sha256', xmlName: 'x-ms-encryption-key-sha256', type: { name: 'String' } }, encryptionScope: { serializedName: 'x-ms-encryption-scope', xmlName: 'x-ms-encryption-scope', type: { name: 'String' } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          Yr = { serializedName: 'PageBlob_uploadPagesFromURLExceptionHeaders', type: { name: 'Composite', className: 'PageBlobUploadPagesFromURLExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          es = {
            serializedName: 'PageBlob_getPageRangesHeaders',
            type: {
              name: 'Composite',
              className: 'PageBlobGetPageRangesHeaders',
              modelProperties: {
                lastModified: { serializedName: 'last-modified', xmlName: 'last-modified', type: { name: 'DateTimeRfc1123' } }, etag: { serializedName: 'etag', xmlName: 'etag', type: { name: 'String' } }, blobContentLength: { serializedName: 'x-ms-blob-content-length', xmlName: 'x-ms-blob-content-length', type: { name: 'Number' } }, clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          ts = { serializedName: 'PageBlob_getPageRangesExceptionHeaders', type: { name: 'Composite', className: 'PageBlobGetPageRangesExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          as = {
            serializedName: 'PageBlob_getPageRangesDiffHeaders',
            type: {
              name: 'Composite',
              className: 'PageBlobGetPageRangesDiffHeaders',
              modelProperties: {
                lastModified: { serializedName: 'last-modified', xmlName: 'last-modified', type: { name: 'DateTimeRfc1123' } }, etag: { serializedName: 'etag', xmlName: 'etag', type: { name: 'String' } }, blobContentLength: { serializedName: 'x-ms-blob-content-length', xmlName: 'x-ms-blob-content-length', type: { name: 'Number' } }, clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          rs = { serializedName: 'PageBlob_getPageRangesDiffExceptionHeaders', type: { name: 'Composite', className: 'PageBlobGetPageRangesDiffExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          ss = {
            serializedName: 'PageBlob_resizeHeaders',
            type: {
              name: 'Composite',
              className: 'PageBlobResizeHeaders',
              modelProperties: {
                etag: { serializedName: 'etag', xmlName: 'etag', type: { name: 'String' } }, lastModified: { serializedName: 'last-modified', xmlName: 'last-modified', type: { name: 'DateTimeRfc1123' } }, blobSequenceNumber: { serializedName: 'x-ms-blob-sequence-number', xmlName: 'x-ms-blob-sequence-number', type: { name: 'Number' } }, clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          is = { serializedName: 'PageBlob_resizeExceptionHeaders', type: { name: 'Composite', className: 'PageBlobResizeExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          ns = {
            serializedName: 'PageBlob_updateSequenceNumberHeaders',
            type: {
              name: 'Composite',
              className: 'PageBlobUpdateSequenceNumberHeaders',
              modelProperties: {
                etag: { serializedName: 'etag', xmlName: 'etag', type: { name: 'String' } }, lastModified: { serializedName: 'last-modified', xmlName: 'last-modified', type: { name: 'DateTimeRfc1123' } }, blobSequenceNumber: { serializedName: 'x-ms-blob-sequence-number', xmlName: 'x-ms-blob-sequence-number', type: { name: 'Number' } }, clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          os = { serializedName: 'PageBlob_updateSequenceNumberExceptionHeaders', type: { name: 'Composite', className: 'PageBlobUpdateSequenceNumberExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          ms = {
            serializedName: 'PageBlob_copyIncrementalHeaders',
            type: {
              name: 'Composite',
              className: 'PageBlobCopyIncrementalHeaders',
              modelProperties: {
                etag: { serializedName: 'etag', xmlName: 'etag', type: { name: 'String' } }, lastModified: { serializedName: 'last-modified', xmlName: 'last-modified', type: { name: 'DateTimeRfc1123' } }, clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, copyId: { serializedName: 'x-ms-copy-id', xmlName: 'x-ms-copy-id', type: { name: 'String' } }, copyStatus: { serializedName: 'x-ms-copy-status', xmlName: 'x-ms-copy-status', type: { name: 'Enum', allowedValues: ['pending', 'success', 'aborted', 'failed'] } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          ls = { serializedName: 'PageBlob_copyIncrementalExceptionHeaders', type: { name: 'Composite', className: 'PageBlobCopyIncrementalExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          ds = {
            serializedName: 'AppendBlob_createHeaders',
            type: {
              name: 'Composite',
              className: 'AppendBlobCreateHeaders',
              modelProperties: {
                etag: { serializedName: 'etag', xmlName: 'etag', type: { name: 'String' } }, lastModified: { serializedName: 'last-modified', xmlName: 'last-modified', type: { name: 'DateTimeRfc1123' } }, contentMD5: { serializedName: 'content-md5', xmlName: 'content-md5', type: { name: 'ByteArray' } }, clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, versionId: { serializedName: 'x-ms-version-id', xmlName: 'x-ms-version-id', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, isServerEncrypted: { serializedName: 'x-ms-request-server-encrypted', xmlName: 'x-ms-request-server-encrypted', type: { name: 'Boolean' } }, encryptionKeySha256: { serializedName: 'x-ms-encryption-key-sha256', xmlName: 'x-ms-encryption-key-sha256', type: { name: 'String' } }, encryptionScope: { serializedName: 'x-ms-encryption-scope', xmlName: 'x-ms-encryption-scope', type: { name: 'String' } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          cs = { serializedName: 'AppendBlob_createExceptionHeaders', type: { name: 'Composite', className: 'AppendBlobCreateExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          ps = {
            serializedName: 'AppendBlob_appendBlockHeaders',
            type: {
              name: 'Composite',
              className: 'AppendBlobAppendBlockHeaders',
              modelProperties: {
                etag: { serializedName: 'etag', xmlName: 'etag', type: { name: 'String' } }, lastModified: { serializedName: 'last-modified', xmlName: 'last-modified', type: { name: 'DateTimeRfc1123' } }, contentMD5: { serializedName: 'content-md5', xmlName: 'content-md5', type: { name: 'ByteArray' } }, xMsContentCrc64: { serializedName: 'x-ms-content-crc64', xmlName: 'x-ms-content-crc64', type: { name: 'ByteArray' } }, clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, blobAppendOffset: { serializedName: 'x-ms-blob-append-offset', xmlName: 'x-ms-blob-append-offset', type: { name: 'String' } }, blobCommittedBlockCount: { serializedName: 'x-ms-blob-committed-block-count', xmlName: 'x-ms-blob-committed-block-count', type: { name: 'Number' } }, isServerEncrypted: { serializedName: 'x-ms-request-server-encrypted', xmlName: 'x-ms-request-server-encrypted', type: { name: 'Boolean' } }, encryptionKeySha256: { serializedName: 'x-ms-encryption-key-sha256', xmlName: 'x-ms-encryption-key-sha256', type: { name: 'String' } }, encryptionScope: { serializedName: 'x-ms-encryption-scope', xmlName: 'x-ms-encryption-scope', type: { name: 'String' } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          us = { serializedName: 'AppendBlob_appendBlockExceptionHeaders', type: { name: 'Composite', className: 'AppendBlobAppendBlockExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          ys = {
            serializedName: 'AppendBlob_appendBlockFromUrlHeaders',
            type: {
              name: 'Composite',
              className: 'AppendBlobAppendBlockFromUrlHeaders',
              modelProperties: {
                etag: { serializedName: 'etag', xmlName: 'etag', type: { name: 'String' } }, lastModified: { serializedName: 'last-modified', xmlName: 'last-modified', type: { name: 'DateTimeRfc1123' } }, contentMD5: { serializedName: 'content-md5', xmlName: 'content-md5', type: { name: 'ByteArray' } }, xMsContentCrc64: { serializedName: 'x-ms-content-crc64', xmlName: 'x-ms-content-crc64', type: { name: 'ByteArray' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, blobAppendOffset: { serializedName: 'x-ms-blob-append-offset', xmlName: 'x-ms-blob-append-offset', type: { name: 'String' } }, blobCommittedBlockCount: { serializedName: 'x-ms-blob-committed-block-count', xmlName: 'x-ms-blob-committed-block-count', type: { name: 'Number' } }, encryptionKeySha256: { serializedName: 'x-ms-encryption-key-sha256', xmlName: 'x-ms-encryption-key-sha256', type: { name: 'String' } }, encryptionScope: { serializedName: 'x-ms-encryption-scope', xmlName: 'x-ms-encryption-scope', type: { name: 'String' } }, isServerEncrypted: { serializedName: 'x-ms-request-server-encrypted', xmlName: 'x-ms-request-server-encrypted', type: { name: 'Boolean' } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          gs = { serializedName: 'AppendBlob_appendBlockFromUrlExceptionHeaders', type: { name: 'Composite', className: 'AppendBlobAppendBlockFromUrlExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          hs = {
            serializedName: 'AppendBlob_sealHeaders',
            type: {
              name: 'Composite',
              className: 'AppendBlobSealHeaders',
              modelProperties: {
                etag: { serializedName: 'etag', xmlName: 'etag', type: { name: 'String' } }, lastModified: { serializedName: 'last-modified', xmlName: 'last-modified', type: { name: 'DateTimeRfc1123' } }, clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, isSealed: { serializedName: 'x-ms-blob-sealed', xmlName: 'x-ms-blob-sealed', type: { name: 'Boolean' } }
              }
            }
          },
          xs = { serializedName: 'AppendBlob_sealExceptionHeaders', type: { name: 'Composite', className: 'AppendBlobSealExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          Ns = {
            serializedName: 'BlockBlob_uploadHeaders',
            type: {
              name: 'Composite',
              className: 'BlockBlobUploadHeaders',
              modelProperties: {
                etag: { serializedName: 'etag', xmlName: 'etag', type: { name: 'String' } }, lastModified: { serializedName: 'last-modified', xmlName: 'last-modified', type: { name: 'DateTimeRfc1123' } }, contentMD5: { serializedName: 'content-md5', xmlName: 'content-md5', type: { name: 'ByteArray' } }, clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, versionId: { serializedName: 'x-ms-version-id', xmlName: 'x-ms-version-id', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, isServerEncrypted: { serializedName: 'x-ms-request-server-encrypted', xmlName: 'x-ms-request-server-encrypted', type: { name: 'Boolean' } }, encryptionKeySha256: { serializedName: 'x-ms-encryption-key-sha256', xmlName: 'x-ms-encryption-key-sha256', type: { name: 'String' } }, encryptionScope: { serializedName: 'x-ms-encryption-scope', xmlName: 'x-ms-encryption-scope', type: { name: 'String' } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          bs = { serializedName: 'BlockBlob_uploadExceptionHeaders', type: { name: 'Composite', className: 'BlockBlobUploadExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          fs = {
            serializedName: 'BlockBlob_putBlobFromUrlHeaders',
            type: {
              name: 'Composite',
              className: 'BlockBlobPutBlobFromUrlHeaders',
              modelProperties: {
                etag: { serializedName: 'etag', xmlName: 'etag', type: { name: 'String' } }, lastModified: { serializedName: 'last-modified', xmlName: 'last-modified', type: { name: 'DateTimeRfc1123' } }, contentMD5: { serializedName: 'content-md5', xmlName: 'content-md5', type: { name: 'ByteArray' } }, clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, versionId: { serializedName: 'x-ms-version-id', xmlName: 'x-ms-version-id', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, isServerEncrypted: { serializedName: 'x-ms-request-server-encrypted', xmlName: 'x-ms-request-server-encrypted', type: { name: 'Boolean' } }, encryptionKeySha256: { serializedName: 'x-ms-encryption-key-sha256', xmlName: 'x-ms-encryption-key-sha256', type: { name: 'String' } }, encryptionScope: { serializedName: 'x-ms-encryption-scope', xmlName: 'x-ms-encryption-scope', type: { name: 'String' } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          Ss = { serializedName: 'BlockBlob_putBlobFromUrlExceptionHeaders', type: { name: 'Composite', className: 'BlockBlobPutBlobFromUrlExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          Cs = {
            serializedName: 'BlockBlob_stageBlockHeaders',
            type: {
              name: 'Composite',
              className: 'BlockBlobStageBlockHeaders',
              modelProperties: {
                contentMD5: { serializedName: 'content-md5', xmlName: 'content-md5', type: { name: 'ByteArray' } }, clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, xMsContentCrc64: { serializedName: 'x-ms-content-crc64', xmlName: 'x-ms-content-crc64', type: { name: 'ByteArray' } }, isServerEncrypted: { serializedName: 'x-ms-request-server-encrypted', xmlName: 'x-ms-request-server-encrypted', type: { name: 'Boolean' } }, encryptionKeySha256: { serializedName: 'x-ms-encryption-key-sha256', xmlName: 'x-ms-encryption-key-sha256', type: { name: 'String' } }, encryptionScope: { serializedName: 'x-ms-encryption-scope', xmlName: 'x-ms-encryption-scope', type: { name: 'String' } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          vs = { serializedName: 'BlockBlob_stageBlockExceptionHeaders', type: { name: 'Composite', className: 'BlockBlobStageBlockExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          Ps = {
            serializedName: 'BlockBlob_stageBlockFromURLHeaders',
            type: {
              name: 'Composite',
              className: 'BlockBlobStageBlockFromURLHeaders',
              modelProperties: {
                contentMD5: { serializedName: 'content-md5', xmlName: 'content-md5', type: { name: 'ByteArray' } }, xMsContentCrc64: { serializedName: 'x-ms-content-crc64', xmlName: 'x-ms-content-crc64', type: { name: 'ByteArray' } }, clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, isServerEncrypted: { serializedName: 'x-ms-request-server-encrypted', xmlName: 'x-ms-request-server-encrypted', type: { name: 'Boolean' } }, encryptionKeySha256: { serializedName: 'x-ms-encryption-key-sha256', xmlName: 'x-ms-encryption-key-sha256', type: { name: 'String' } }, encryptionScope: { serializedName: 'x-ms-encryption-scope', xmlName: 'x-ms-encryption-scope', type: { name: 'String' } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          zs = { serializedName: 'BlockBlob_stageBlockFromURLExceptionHeaders', type: { name: 'Composite', className: 'BlockBlobStageBlockFromURLExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          Rs = {
            serializedName: 'BlockBlob_commitBlockListHeaders',
            type: {
              name: 'Composite',
              className: 'BlockBlobCommitBlockListHeaders',
              modelProperties: {
                etag: { serializedName: 'etag', xmlName: 'etag', type: { name: 'String' } }, lastModified: { serializedName: 'last-modified', xmlName: 'last-modified', type: { name: 'DateTimeRfc1123' } }, contentMD5: { serializedName: 'content-md5', xmlName: 'content-md5', type: { name: 'ByteArray' } }, xMsContentCrc64: { serializedName: 'x-ms-content-crc64', xmlName: 'x-ms-content-crc64', type: { name: 'ByteArray' } }, clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, versionId: { serializedName: 'x-ms-version-id', xmlName: 'x-ms-version-id', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, isServerEncrypted: { serializedName: 'x-ms-request-server-encrypted', xmlName: 'x-ms-request-server-encrypted', type: { name: 'Boolean' } }, encryptionKeySha256: { serializedName: 'x-ms-encryption-key-sha256', xmlName: 'x-ms-encryption-key-sha256', type: { name: 'String' } }, encryptionScope: { serializedName: 'x-ms-encryption-scope', xmlName: 'x-ms-encryption-scope', type: { name: 'String' } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          ws = { serializedName: 'BlockBlob_commitBlockListExceptionHeaders', type: { name: 'Composite', className: 'BlockBlobCommitBlockListExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } },
          Es = {
            serializedName: 'BlockBlob_getBlockListHeaders',
            type: {
              name: 'Composite',
              className: 'BlockBlobGetBlockListHeaders',
              modelProperties: {
                lastModified: { serializedName: 'last-modified', xmlName: 'last-modified', type: { name: 'DateTimeRfc1123' } }, etag: { serializedName: 'etag', xmlName: 'etag', type: { name: 'String' } }, contentType: { serializedName: 'content-type', xmlName: 'content-type', type: { name: 'String' } }, blobContentLength: { serializedName: 'x-ms-blob-content-length', xmlName: 'x-ms-blob-content-length', type: { name: 'Number' } }, clientRequestId: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } }, requestId: { serializedName: 'x-ms-request-id', xmlName: 'x-ms-request-id', type: { name: 'String' } }, version: { serializedName: 'x-ms-version', xmlName: 'x-ms-version', type: { name: 'String' } }, date: { serializedName: 'date', xmlName: 'date', type: { name: 'DateTimeRfc1123' } }, errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } }
              }
            }
          },
          qs = { serializedName: 'BlockBlob_getBlockListExceptionHeaders', type: { name: 'Composite', className: 'BlockBlobGetBlockListExceptionHeaders', modelProperties: { errorCode: { serializedName: 'x-ms-error-code', xmlName: 'x-ms-error-code', type: { name: 'String' } } } } }; var Os; !(function (e) { e.Csv = ',', e.Ssv = ' ', e.Tsv = '\t', e.Pipes = '|', e.Multi = 'Multi'; }(Os || (Os = {}))); const Bs = {
            parameterPath: ['options', 'contentType'],
            mapper: {
              defaultValue: 'application/xml', isConstant: !0, serializedName: 'Content-Type', type: { name: 'String' }
            }
          },
          Ms = { parameterPath: 'blobServiceProperties', mapper: ht },
          Ts = {
            parameterPath: 'accept',
            mapper: {
              defaultValue: 'application/xml', isConstant: !0, serializedName: 'Accept', type: { name: 'String' }
            }
          },
          Is = {
            parameterPath: 'url',
            mapper: {
              serializedName: 'url', required: !0, xmlName: 'url', type: { name: 'String' }
            },
            skipEncoding: !0
          },
          Hs = {
            parameterPath: 'restype',
            mapper: {
              defaultValue: 'service', isConstant: !0, serializedName: 'restype', type: { name: 'String' }
            }
          },
          As = {
            parameterPath: 'comp',
            mapper: {
              defaultValue: 'properties', isConstant: !0, serializedName: 'comp', type: { name: 'String' }
            }
          },
          ks = {
            parameterPath: ['options', 'timeoutInSeconds'],
            mapper: {
              constraints: { InclusiveMinimum: 0 }, serializedName: 'timeout', xmlName: 'timeout', type: { name: 'Number' }
            }
          },
          Ls = {
            parameterPath: 'version',
            mapper: {
              defaultValue: '2020-10-02', isConstant: !0, serializedName: 'x-ms-version', type: { name: 'String' }
            }
          },
          Ds = { parameterPath: ['options', 'requestId'], mapper: { serializedName: 'x-ms-client-request-id', xmlName: 'x-ms-client-request-id', type: { name: 'String' } } },
          _s = {
            parameterPath: 'accept',
            mapper: {
              defaultValue: 'application/xml', isConstant: !0, serializedName: 'Accept', type: { name: 'String' }
            }
          },
          js = {
            parameterPath: 'comp',
            mapper: {
              defaultValue: 'list', isConstant: !0, serializedName: 'comp', type: { name: 'String' }
            }
          },
          Us = { parameterPath: ['options', 'prefix'], mapper: { serializedName: 'prefix', xmlName: 'prefix', type: { name: 'String' } } },
          Vs = { parameterPath: ['options', 'marker'], mapper: { serializedName: 'marker', xmlName: 'marker', type: { name: 'String' } } },
          Fs = {
            parameterPath: ['options', 'maxPageSize'],
            mapper: {
              constraints: { InclusiveMinimum: 1 }, serializedName: 'maxresults', xmlName: 'maxresults', type: { name: 'Number' }
            }
          },
          $s = {
            parameterPath: ['options', 'include'],
            mapper: {
              serializedName: 'include', xmlName: 'include', xmlElementName: 'ListContainersIncludeType', type: { name: 'Sequence', element: { type: { name: 'Enum', allowedValues: ['metadata', 'deleted'] } } }
            },
            collectionFormat: Os.Csv
          },
          Ks = { parameterPath: 'keyInfo', mapper: Et },
          Gs = {
            parameterPath: 'restype',
            mapper: {
              defaultValue: 'account', isConstant: !0, serializedName: 'restype', type: { name: 'String' }
            }
          },
          Qs = {
            parameterPath: 'body',
            mapper: {
              serializedName: 'body', required: !0, xmlName: 'body', type: { name: 'Stream' }
            }
          },
          Xs = {
            parameterPath: 'comp',
            mapper: {
              defaultValue: 'batch', isConstant: !0, serializedName: 'comp', type: { name: 'String' }
            }
          },
          Ws = {
            parameterPath: 'contentLength',
            mapper: {
              serializedName: 'Content-Length', required: !0, xmlName: 'Content-Length', type: { name: 'Number' }
            }
          },
          Js = {
            parameterPath: 'multipartContentType',
            mapper: {
              serializedName: 'Content-Type', required: !0, xmlName: 'Content-Type', type: { name: 'String' }
            }
          },
          Zs = {
            parameterPath: 'restype',
            mapper: {
              defaultValue: 'container', isConstant: !0, serializedName: 'restype', type: { name: 'String' }
            }
          },
          Ys = {
            parameterPath: ['options', 'metadata'],
            mapper: {
              serializedName: 'x-ms-meta', xmlName: 'x-ms-meta', type: { name: 'Dictionary', value: { type: { name: 'String' } } }, headerCollectionPrefix: 'x-ms-meta-'
            }
          },
          ei = { parameterPath: ['options', 'access'], mapper: { serializedName: 'x-ms-blob-public-access', xmlName: 'x-ms-blob-public-access', type: { name: 'Enum', allowedValues: ['container', 'blob'] } } },
          ti = { parameterPath: ['options', 'leaseAccessConditions', 'leaseId'], mapper: { serializedName: 'x-ms-lease-id', xmlName: 'x-ms-lease-id', type: { name: 'String' } } },
          ai = { parameterPath: ['options', 'modifiedAccessConditions', 'ifModifiedSince'], mapper: { serializedName: 'If-Modified-Since', xmlName: 'If-Modified-Since', type: { name: 'DateTimeRfc1123' } } },
          ri = { parameterPath: ['options', 'modifiedAccessConditions', 'ifUnmodifiedSince'], mapper: { serializedName: 'If-Unmodified-Since', xmlName: 'If-Unmodified-Since', type: { name: 'DateTimeRfc1123' } } },
          si = {
            parameterPath: 'comp',
            mapper: {
              defaultValue: 'metadata', isConstant: !0, serializedName: 'comp', type: { name: 'String' }
            }
          },
          ii = {
            parameterPath: 'comp',
            mapper: {
              defaultValue: 'acl', isConstant: !0, serializedName: 'comp', type: { name: 'String' }
            }
          },
          ni = {
            parameterPath: 'comp',
            mapper: {
              defaultValue: 'undelete', isConstant: !0, serializedName: 'comp', type: { name: 'String' }
            }
          },
          oi = {
            parameterPath: 'comp',
            mapper: {
              defaultValue: 'lease', isConstant: !0, serializedName: 'comp', type: { name: 'String' }
            }
          },
          mi = {
            parameterPath: 'action',
            mapper: {
              defaultValue: 'acquire', isConstant: !0, serializedName: 'x-ms-lease-action', type: { name: 'String' }
            }
          },
          li = { parameterPath: ['options', 'duration'], mapper: { serializedName: 'x-ms-lease-duration', xmlName: 'x-ms-lease-duration', type: { name: 'Number' } } },
          di = { parameterPath: ['options', 'proposedLeaseId'], mapper: { serializedName: 'x-ms-proposed-lease-id', xmlName: 'x-ms-proposed-lease-id', type: { name: 'String' } } },
          ci = {
            parameterPath: 'action',
            mapper: {
              defaultValue: 'release', isConstant: !0, serializedName: 'x-ms-lease-action', type: { name: 'String' }
            }
          },
          pi = {
            parameterPath: 'leaseId',
            mapper: {
              serializedName: 'x-ms-lease-id', required: !0, xmlName: 'x-ms-lease-id', type: { name: 'String' }
            }
          },
          ui = {
            parameterPath: 'action',
            mapper: {
              defaultValue: 'renew', isConstant: !0, serializedName: 'x-ms-lease-action', type: { name: 'String' }
            }
          },
          yi = {
            parameterPath: 'action',
            mapper: {
              defaultValue: 'break', isConstant: !0, serializedName: 'x-ms-lease-action', type: { name: 'String' }
            }
          },
          gi = { parameterPath: ['options', 'breakPeriod'], mapper: { serializedName: 'x-ms-lease-break-period', xmlName: 'x-ms-lease-break-period', type: { name: 'Number' } } },
          hi = {
            parameterPath: 'action',
            mapper: {
              defaultValue: 'change', isConstant: !0, serializedName: 'x-ms-lease-action', type: { name: 'String' }
            }
          },
          xi = {
            parameterPath: 'proposedLeaseId',
            mapper: {
              serializedName: 'x-ms-proposed-lease-id', required: !0, xmlName: 'x-ms-proposed-lease-id', type: { name: 'String' }
            }
          },
          Ni = {
            parameterPath: ['options', 'include'],
            mapper: {
              serializedName: 'include', xmlName: 'include', xmlElementName: 'ListBlobsIncludeItem', type: { name: 'Sequence', element: { type: { name: 'Enum', allowedValues: ['copy', 'deleted', 'metadata', 'snapshots', 'uncommittedblobs', 'versions', 'tags', 'immutabilitypolicy', 'legalhold', 'deletedwithversions'] } } }
            },
            collectionFormat: Os.Csv
          },
          bi = { parameterPath: ['options', 'snapshot'], mapper: { serializedName: 'snapshot', xmlName: 'snapshot', type: { name: 'String' } } },
          fi = { parameterPath: ['options', 'versionId'], mapper: { serializedName: 'versionid', xmlName: 'versionid', type: { name: 'String' } } },
          Si = { parameterPath: ['options', 'range'], mapper: { serializedName: 'x-ms-range', xmlName: 'x-ms-range', type: { name: 'String' } } },
          Ci = { parameterPath: ['options', 'cpkInfo', 'encryptionKey'], mapper: { serializedName: 'x-ms-encryption-key', xmlName: 'x-ms-encryption-key', type: { name: 'String' } } },
          vi = { parameterPath: ['options', 'cpkInfo', 'encryptionKeySha256'], mapper: { serializedName: 'x-ms-encryption-key-sha256', xmlName: 'x-ms-encryption-key-sha256', type: { name: 'String' } } },
          Pi = {
            parameterPath: ['options', 'encryptionAlgorithm'],
            mapper: {
              defaultValue: 'AES256', isConstant: !0, serializedName: 'x-ms-encryption-algorithm', type: { name: 'String' }
            }
          },
          zi = { parameterPath: ['options', 'modifiedAccessConditions', 'ifMatch'], mapper: { serializedName: 'If-Match', xmlName: 'If-Match', type: { name: 'String' } } },
          Ri = { parameterPath: ['options', 'modifiedAccessConditions', 'ifNoneMatch'], mapper: { serializedName: 'If-None-Match', xmlName: 'If-None-Match', type: { name: 'String' } } },
          wi = { parameterPath: ['options', 'modifiedAccessConditions', 'ifTags'], mapper: { serializedName: 'x-ms-if-tags', xmlName: 'x-ms-if-tags', type: { name: 'String' } } },
          Ei = { parameterPath: ['options', 'blobHttpHeaders', 'blobCacheControl'], mapper: { serializedName: 'x-ms-blob-cache-control', xmlName: 'x-ms-blob-cache-control', type: { name: 'String' } } },
          qi = { parameterPath: ['options', 'blobHttpHeaders', 'blobContentType'], mapper: { serializedName: 'x-ms-blob-content-type', xmlName: 'x-ms-blob-content-type', type: { name: 'String' } } },
          Oi = { parameterPath: ['options', 'blobHttpHeaders', 'blobContentMD5'], mapper: { serializedName: 'x-ms-blob-content-md5', xmlName: 'x-ms-blob-content-md5', type: { name: 'ByteArray' } } },
          Bi = { parameterPath: ['options', 'blobHttpHeaders', 'blobContentEncoding'], mapper: { serializedName: 'x-ms-blob-content-encoding', xmlName: 'x-ms-blob-content-encoding', type: { name: 'String' } } },
          Mi = { parameterPath: ['options', 'blobHttpHeaders', 'blobContentLanguage'], mapper: { serializedName: 'x-ms-blob-content-language', xmlName: 'x-ms-blob-content-language', type: { name: 'String' } } },
          Ti = { parameterPath: ['options', 'blobHttpHeaders', 'blobContentDisposition'], mapper: { serializedName: 'x-ms-blob-content-disposition', xmlName: 'x-ms-blob-content-disposition', type: { name: 'String' } } },
          Ii = {
            parameterPath: 'comp',
            mapper: {
              defaultValue: 'immutabilityPolicies', isConstant: !0, serializedName: 'comp', type: { name: 'String' }
            }
          },
          Hi = { parameterPath: ['options', 'immutabilityPolicyExpiry'], mapper: { serializedName: 'x-ms-immutability-policy-until-date', xmlName: 'x-ms-immutability-policy-until-date', type: { name: 'DateTimeRfc1123' } } },
          Ai = { parameterPath: ['options', 'immutabilityPolicyMode'], mapper: { serializedName: 'x-ms-immutability-policy-mode', xmlName: 'x-ms-immutability-policy-mode', type: { name: 'Enum', allowedValues: ['Mutable', 'Unlocked', 'Locked'] } } },
          ki = { parameterPath: ['options', 'encryptionScope'], mapper: { serializedName: 'x-ms-encryption-scope', xmlName: 'x-ms-encryption-scope', type: { name: 'String' } } },
          Li = { parameterPath: ['options', 'tier'], mapper: { serializedName: 'x-ms-access-tier', xmlName: 'x-ms-access-tier', type: { name: 'Enum', allowedValues: ['P4', 'P6', 'P10', 'P15', 'P20', 'P30', 'P40', 'P50', 'P60', 'P70', 'P80', 'Hot', 'Cool', 'Archive'] } } },
          Di = { parameterPath: ['options', 'rehydratePriority'], mapper: { serializedName: 'x-ms-rehydrate-priority', xmlName: 'x-ms-rehydrate-priority', type: { name: 'Enum', allowedValues: ['High', 'Standard'] } } },
          _i = { parameterPath: ['options', 'sourceModifiedAccessConditions', 'sourceIfModifiedSince'], mapper: { serializedName: 'x-ms-source-if-modified-since', xmlName: 'x-ms-source-if-modified-since', type: { name: 'DateTimeRfc1123' } } },
          ji = { parameterPath: ['options', 'sourceModifiedAccessConditions', 'sourceIfUnmodifiedSince'], mapper: { serializedName: 'x-ms-source-if-unmodified-since', xmlName: 'x-ms-source-if-unmodified-since', type: { name: 'DateTimeRfc1123' } } },
          Ui = { parameterPath: ['options', 'sourceModifiedAccessConditions', 'sourceIfMatch'], mapper: { serializedName: 'x-ms-source-if-match', xmlName: 'x-ms-source-if-match', type: { name: 'String' } } },
          Vi = { parameterPath: ['options', 'sourceModifiedAccessConditions', 'sourceIfNoneMatch'], mapper: { serializedName: 'x-ms-source-if-none-match', xmlName: 'x-ms-source-if-none-match', type: { name: 'String' } } },
          Fi = { parameterPath: ['options', 'sourceModifiedAccessConditions', 'sourceIfTags'], mapper: { serializedName: 'x-ms-source-if-tags', xmlName: 'x-ms-source-if-tags', type: { name: 'String' } } },
          $i = {
            parameterPath: 'copySource',
            mapper: {
              serializedName: 'x-ms-copy-source', required: !0, xmlName: 'x-ms-copy-source', type: { name: 'String' }
            }
          },
          Ki = { parameterPath: ['options', 'blobTagsString'], mapper: { serializedName: 'x-ms-tags', xmlName: 'x-ms-tags', type: { name: 'String' } } },
          Gi = { parameterPath: ['options', 'legalHold'], mapper: { serializedName: 'x-ms-legal-hold', xmlName: 'x-ms-legal-hold', type: { name: 'Boolean' } } },
          Qi = { parameterPath: ['options', 'sourceContentMD5'], mapper: { serializedName: 'x-ms-source-content-md5', xmlName: 'x-ms-source-content-md5', type: { name: 'ByteArray' } } },
          Xi = { parameterPath: ['options', 'copySourceAuthorization'], mapper: { serializedName: 'x-ms-copy-source-authorization', xmlName: 'x-ms-copy-source-authorization', type: { name: 'String' } } },
          Wi = { parameterPath: ['options', 'queryRequest'], mapper: Xt },
          Ji = {
            parameterPath: 'comp',
            mapper: {
              defaultValue: 'tags', isConstant: !0, serializedName: 'comp', type: { name: 'String' }
            }
          },
          Zi = { parameterPath: ['options', 'tags'], mapper: Mt },
          Yi = { parameterPath: ['options', 'transactionalContentMD5'], mapper: { serializedName: 'Content-MD5', xmlName: 'Content-MD5', type: { name: 'ByteArray' } } },
          en = { parameterPath: ['options', 'transactionalContentCrc64'], mapper: { serializedName: 'x-ms-content-crc64', xmlName: 'x-ms-content-crc64', type: { name: 'ByteArray' } } },
          tn = {
            parameterPath: 'blobContentLength',
            mapper: {
              serializedName: 'x-ms-blob-content-length', required: !0, xmlName: 'x-ms-blob-content-length', type: { name: 'Number' }
            }
          },
          an = { parameterPath: ['options', 'blobSequenceNumber'], mapper: { serializedName: 'x-ms-blob-sequence-number', xmlName: 'x-ms-blob-sequence-number', type: { name: 'Number' } } },
          rn = {
            parameterPath: ['options', 'contentType'],
            mapper: {
              defaultValue: 'application/octet-stream', isConstant: !0, serializedName: 'Content-Type', type: { name: 'String' }
            }
          },
          sn = {
            parameterPath: 'body',
            mapper: {
              serializedName: 'body', required: !0, xmlName: 'body', type: { name: 'Stream' }
            }
          },
          nn = {
            parameterPath: 'accept',
            mapper: {
              defaultValue: 'application/xml', isConstant: !0, serializedName: 'Accept', type: { name: 'String' }
            }
          },
          on = {
            parameterPath: 'comp',
            mapper: {
              defaultValue: 'page', isConstant: !0, serializedName: 'comp', type: { name: 'String' }
            }
          },
          mn = {
            parameterPath: 'pageWrite',
            mapper: {
              defaultValue: 'update', isConstant: !0, serializedName: 'x-ms-page-write', type: { name: 'String' }
            }
          },
          ln = { parameterPath: ['options', 'sequenceNumberAccessConditions', 'ifSequenceNumberLessThanOrEqualTo'], mapper: { serializedName: 'x-ms-if-sequence-number-le', xmlName: 'x-ms-if-sequence-number-le', type: { name: 'Number' } } },
          dn = { parameterPath: ['options', 'sequenceNumberAccessConditions', 'ifSequenceNumberLessThan'], mapper: { serializedName: 'x-ms-if-sequence-number-lt', xmlName: 'x-ms-if-sequence-number-lt', type: { name: 'Number' } } },
          cn = { parameterPath: ['options', 'sequenceNumberAccessConditions', 'ifSequenceNumberEqualTo'], mapper: { serializedName: 'x-ms-if-sequence-number-eq', xmlName: 'x-ms-if-sequence-number-eq', type: { name: 'Number' } } },
          pn = {
            parameterPath: 'sourceUrl',
            mapper: {
              serializedName: 'x-ms-copy-source', required: !0, xmlName: 'x-ms-copy-source', type: { name: 'String' }
            }
          },
          un = { parameterPath: ['options', 'sourceContentCrc64'], mapper: { serializedName: 'x-ms-source-content-crc64', xmlName: 'x-ms-source-content-crc64', type: { name: 'ByteArray' } } },
          yn = {
            parameterPath: 'comp',
            mapper: {
              defaultValue: 'pagelist', isConstant: !0, serializedName: 'comp', type: { name: 'String' }
            }
          },
          gn = {
            parameterPath: 'comp',
            mapper: {
              defaultValue: 'appendblock', isConstant: !0, serializedName: 'comp', type: { name: 'String' }
            }
          },
          hn = { parameterPath: ['options', 'appendPositionAccessConditions', 'maxSize'], mapper: { serializedName: 'x-ms-blob-condition-maxsize', xmlName: 'x-ms-blob-condition-maxsize', type: { name: 'Number' } } },
          xn = { parameterPath: ['options', 'appendPositionAccessConditions', 'appendPosition'], mapper: { serializedName: 'x-ms-blob-condition-appendpos', xmlName: 'x-ms-blob-condition-appendpos', type: { name: 'Number' } } },
          Nn = { parameterPath: ['options', 'sourceRange'], mapper: { serializedName: 'x-ms-source-range', xmlName: 'x-ms-source-range', type: { name: 'String' } } },
          bn = {
            parameterPath: 'blobType',
            mapper: {
              defaultValue: 'BlockBlob', isConstant: !0, serializedName: 'x-ms-blob-type', type: { name: 'String' }
            }
          },
          fn = {
            parameterPath: 'comp',
            mapper: {
              defaultValue: 'block', isConstant: !0, serializedName: 'comp', type: { name: 'String' }
            }
          },
          Sn = {
            parameterPath: 'blockId',
            mapper: {
              serializedName: 'blockid', required: !0, xmlName: 'blockid', type: { name: 'String' }
            }
          },
          Cn = { parameterPath: 'blocks', mapper: Vt },
          vn = {
            parameterPath: 'comp',
            mapper: {
              defaultValue: 'blocklist', isConstant: !0, serializedName: 'comp', type: { name: 'String' }
            }
          }; class Pn {
          constructor(e) { this.client = e; }
  
          download(e) { const t = { options: rt(e || {}) }; return this.client.sendOperationRequest(t, Rn); }
  
          getProperties(e) { const t = { options: rt(e || {}) }; return this.client.sendOperationRequest(t, wn); }
  
          delete(e) { const t = { options: rt(e || {}) }; return this.client.sendOperationRequest(t, En); }
  
          undelete(e) { const t = { options: rt(e || {}) }; return this.client.sendOperationRequest(t, qn); }
  
          setExpiry(e, t) { const a = { expiryOptions: e, options: rt(t || {}) }; return this.client.sendOperationRequest(a, On); }
  
          setHttpHeaders(e) { const t = { options: rt(e || {}) }; return this.client.sendOperationRequest(t, Bn); }
  
          setImmutabilityPolicy(e) { const t = { options: rt(e || {}) }; return this.client.sendOperationRequest(t, Mn); }
  
          deleteImmutabilityPolicy(e) { const t = { options: rt(e || {}) }; return this.client.sendOperationRequest(t, Tn); }
  
          setLegalHold(e, t) { const a = { legalHold: e, options: rt(t || {}) }; return this.client.sendOperationRequest(a, In); }
  
          setMetadata(e) { const t = { options: rt(e || {}) }; return this.client.sendOperationRequest(t, Hn); }
  
          acquireLease(e) { const t = { options: rt(e || {}) }; return this.client.sendOperationRequest(t, An); }
  
          releaseLease(e, t) { const a = { leaseId: e, options: rt(t || {}) }; return this.client.sendOperationRequest(a, kn); }
  
          renewLease(e, t) { const a = { leaseId: e, options: rt(t || {}) }; return this.client.sendOperationRequest(a, Ln); }
  
          changeLease(e, t, a) { const r = { leaseId: e, proposedLeaseId: t, options: rt(a || {}) }; return this.client.sendOperationRequest(r, Dn); }
  
          breakLease(e) { const t = { options: rt(e || {}) }; return this.client.sendOperationRequest(t, _n); }
  
          createSnapshot(e) { const t = { options: rt(e || {}) }; return this.client.sendOperationRequest(t, jn); }
  
          startCopyFromURL(e, t) { const a = { copySource: e, options: rt(t || {}) }; return this.client.sendOperationRequest(a, Un); }
  
          copyFromURL(e, t) { const a = { copySource: e, options: rt(t || {}) }; return this.client.sendOperationRequest(a, Vn); }
  
          abortCopyFromURL(e, t) { const a = { copyId: e, options: rt(t || {}) }; return this.client.sendOperationRequest(a, Fn); }
  
          setTier(e, t) { const a = { tier: e, options: rt(t || {}) }; return this.client.sendOperationRequest(a, $n); }
  
          getAccountInfo(e) { const t = { options: rt(e || {}) }; return this.client.sendOperationRequest(t, Kn); }
  
          query(e) { const t = { options: rt(e || {}) }; return this.client.sendOperationRequest(t, Gn); }
  
          getTags(e) { const t = { options: rt(e || {}) }; return this.client.sendOperationRequest(t, Qn); }
  
          setTags(e) { const t = { options: rt(e || {}) }; return this.client.sendOperationRequest(t, Xn); }
        } const zn = new nt(t, !0),
          Rn = {
            path: '/{containerName}/{blob}', httpMethod: 'GET', responses: { 200: { bodyMapper: { type: { name: 'Stream' }, serializedName: 'parsedResponse' }, headersMapper: Za }, 206: { bodyMapper: { type: { name: 'Stream' }, serializedName: 'parsedResponse' }, headersMapper: Za }, default: { bodyMapper: Ct, headersMapper: Ya } }, queryParameters: [ks, bi, fi], urlParameters: [Is], headerParameters: [Ls, Ds, _s, ti, ai, ri, Si, { parameterPath: ['options', 'rangeGetContentMD5'], mapper: { serializedName: 'x-ms-range-get-content-md5', xmlName: 'x-ms-range-get-content-md5', type: { name: 'Boolean' } } }, { parameterPath: ['options', 'rangeGetContentCRC64'], mapper: { serializedName: 'x-ms-range-get-content-crc64', xmlName: 'x-ms-range-get-content-crc64', type: { name: 'Boolean' } } }, Ci, vi, Pi, zi, Ri, wi], isXML: !0, serializer: zn
          },
          wn = {
            path: '/{containerName}/{blob}', httpMethod: 'HEAD', responses: { 200: { headersMapper: er }, default: { bodyMapper: Ct, headersMapper: tr } }, queryParameters: [ks, bi, fi], urlParameters: [Is], headerParameters: [Ls, Ds, _s, ti, ai, ri, Ci, vi, Pi, zi, Ri, wi], isXML: !0, serializer: zn
          },
          En = {
            path: '/{containerName}/{blob}', httpMethod: 'DELETE', responses: { 202: { headersMapper: ar }, default: { bodyMapper: Ct, headersMapper: rr } }, queryParameters: [ks, bi, fi, { parameterPath: ['options', 'blobDeleteType'], mapper: { serializedName: 'deletetype', xmlName: 'deletetype', type: { name: 'String' } } }], urlParameters: [Is], headerParameters: [Ls, Ds, _s, ti, ai, ri, zi, Ri, wi, { parameterPath: ['options', 'deleteSnapshots'], mapper: { serializedName: 'x-ms-delete-snapshots', xmlName: 'x-ms-delete-snapshots', type: { name: 'Enum', allowedValues: ['include', 'only'] } } }], isXML: !0, serializer: zn
          },
          qn = {
            path: '/{containerName}/{blob}', httpMethod: 'PUT', responses: { 200: { headersMapper: sr }, default: { bodyMapper: Ct, headersMapper: ir } }, queryParameters: [ks, ni], urlParameters: [Is], headerParameters: [Ls, Ds, _s], isXML: !0, serializer: zn
          },
          On = {
            path: '/{containerName}/{blob}',
            httpMethod: 'PUT',
            responses: { 200: { headersMapper: nr }, default: { bodyMapper: Ct, headersMapper: or } },
            queryParameters: [ks, {
              parameterPath: 'comp',
              mapper: {
                defaultValue: 'expiry', isConstant: !0, serializedName: 'comp', type: { name: 'String' }
              }
            }],
            urlParameters: [Is],
            headerParameters: [Ls, Ds, _s, {
              parameterPath: 'expiryOptions',
              mapper: {
                serializedName: 'x-ms-expiry-option', required: !0, xmlName: 'x-ms-expiry-option', type: { name: 'String' }
              }
            }, { parameterPath: ['options', 'expiresOn'], mapper: { serializedName: 'x-ms-expiry-time', xmlName: 'x-ms-expiry-time', type: { name: 'String' } } }],
            isXML: !0,
            serializer: zn
          },
          Bn = {
            path: '/{containerName}/{blob}', httpMethod: 'PUT', responses: { 200: { headersMapper: mr }, default: { bodyMapper: Ct, headersMapper: lr } }, queryParameters: [As, ks], urlParameters: [Is], headerParameters: [Ls, Ds, _s, ti, ai, ri, zi, Ri, wi, Ei, qi, Oi, Bi, Mi, Ti], isXML: !0, serializer: zn
          },
          Mn = {
            path: '/{containerName}/{blob}', httpMethod: 'PUT', responses: { 200: { headersMapper: dr }, default: { bodyMapper: Ct, headersMapper: cr } }, queryParameters: [ks, Ii], urlParameters: [Is], headerParameters: [Ls, Ds, _s, ri, Hi, Ai], isXML: !0, serializer: zn
          },
          Tn = {
            path: '/{containerName}/{blob}', httpMethod: 'DELETE', responses: { 200: { headersMapper: pr }, default: { bodyMapper: Ct, headersMapper: ur } }, queryParameters: [ks, Ii], urlParameters: [Is], headerParameters: [Ls, Ds, _s], isXML: !0, serializer: zn
          },
          In = {
            path: '/{containerName}/{blob}',
            httpMethod: 'PUT',
            responses: { 200: { headersMapper: yr }, default: { bodyMapper: Ct, headersMapper: gr } },
            queryParameters: [ks, {
              parameterPath: 'comp',
              mapper: {
                defaultValue: 'legalhold', isConstant: !0, serializedName: 'comp', type: { name: 'String' }
              }
            }],
            urlParameters: [Is],
            headerParameters: [Ls, Ds, _s, {
              parameterPath: 'legalHold',
              mapper: {
                serializedName: 'x-ms-legal-hold', required: !0, xmlName: 'x-ms-legal-hold', type: { name: 'Boolean' }
              }
            }],
            isXML: !0,
            serializer: zn
          },
          Hn = {
            path: '/{containerName}/{blob}', httpMethod: 'PUT', responses: { 200: { headersMapper: hr }, default: { bodyMapper: Ct, headersMapper: xr } }, queryParameters: [ks, si], urlParameters: [Is], headerParameters: [Ls, Ds, _s, Ys, ti, ai, ri, Ci, vi, Pi, zi, Ri, wi, ki], isXML: !0, serializer: zn
          },
          An = {
            path: '/{containerName}/{blob}', httpMethod: 'PUT', responses: { 201: { headersMapper: Nr }, default: { bodyMapper: Ct, headersMapper: br } }, queryParameters: [ks, oi], urlParameters: [Is], headerParameters: [Ls, Ds, _s, ai, ri, mi, li, di, zi, Ri, wi], isXML: !0, serializer: zn
          },
          kn = {
            path: '/{containerName}/{blob}', httpMethod: 'PUT', responses: { 200: { headersMapper: fr }, default: { bodyMapper: Ct, headersMapper: Sr } }, queryParameters: [ks, oi], urlParameters: [Is], headerParameters: [Ls, Ds, _s, ai, ri, ci, pi, zi, Ri, wi], isXML: !0, serializer: zn
          },
          Ln = {
            path: '/{containerName}/{blob}', httpMethod: 'PUT', responses: { 200: { headersMapper: Cr }, default: { bodyMapper: Ct, headersMapper: vr } }, queryParameters: [ks, oi], urlParameters: [Is], headerParameters: [Ls, Ds, _s, ai, ri, pi, ui, zi, Ri, wi], isXML: !0, serializer: zn
          },
          Dn = {
            path: '/{containerName}/{blob}', httpMethod: 'PUT', responses: { 200: { headersMapper: Pr }, default: { bodyMapper: Ct, headersMapper: zr } }, queryParameters: [ks, oi], urlParameters: [Is], headerParameters: [Ls, Ds, _s, ai, ri, pi, hi, xi, zi, Ri, wi], isXML: !0, serializer: zn
          },
          _n = {
            path: '/{containerName}/{blob}', httpMethod: 'PUT', responses: { 202: { headersMapper: Rr }, default: { bodyMapper: Ct, headersMapper: wr } }, queryParameters: [ks, oi], urlParameters: [Is], headerParameters: [Ls, Ds, _s, ai, ri, yi, gi, zi, Ri, wi], isXML: !0, serializer: zn
          },
          jn = {
            path: '/{containerName}/{blob}',
            httpMethod: 'PUT',
            responses: { 201: { headersMapper: Er }, default: { bodyMapper: Ct, headersMapper: qr } },
            queryParameters: [ks, {
              parameterPath: 'comp',
              mapper: {
                defaultValue: 'snapshot', isConstant: !0, serializedName: 'comp', type: { name: 'String' }
              }
            }],
            urlParameters: [Is],
            headerParameters: [Ls, Ds, _s, Ys, ti, ai, ri, Ci, vi, Pi, zi, Ri, wi, ki],
            isXML: !0,
            serializer: zn
          },
          Un = {
            path: '/{containerName}/{blob}', httpMethod: 'PUT', responses: { 202: { headersMapper: Or }, default: { bodyMapper: Ct, headersMapper: Br } }, queryParameters: [ks], urlParameters: [Is], headerParameters: [Ls, Ds, _s, Ys, ti, ai, ri, zi, Ri, wi, Hi, Ai, Li, Di, _i, ji, Ui, Vi, Fi, $i, Ki, { parameterPath: ['options', 'sealBlob'], mapper: { serializedName: 'x-ms-seal-blob', xmlName: 'x-ms-seal-blob', type: { name: 'Boolean' } } }, Gi], isXML: !0, serializer: zn
          },
          Vn = {
            path: '/{containerName}/{blob}',
            httpMethod: 'PUT',
            responses: { 202: { headersMapper: Mr }, default: { bodyMapper: Ct, headersMapper: Tr } },
            queryParameters: [ks],
            urlParameters: [Is],
            headerParameters: [Ls, Ds, _s, Ys, ti, ai, ri, zi, Ri, wi, Hi, Ai, Li, _i, ji, Ui, Vi, $i, Ki, Gi, {
              parameterPath: 'xMsRequiresSync',
              mapper: {
                defaultValue: 'true', isConstant: !0, serializedName: 'x-ms-requires-sync', type: { name: 'String' }
              }
            }, Qi, Xi],
            isXML: !0,
            serializer: zn
          },
          Fn = {
            path: '/{containerName}/{blob}',
            httpMethod: 'PUT',
            responses: { 204: { headersMapper: Ir }, default: { bodyMapper: Ct, headersMapper: Hr } },
            queryParameters: [ks, {
              parameterPath: 'comp',
              mapper: {
                defaultValue: 'copy', isConstant: !0, serializedName: 'comp', type: { name: 'String' }
              }
            }, {
              parameterPath: 'copyId',
              mapper: {
                serializedName: 'copyid', required: !0, xmlName: 'copyid', type: { name: 'String' }
              }
            }],
            urlParameters: [Is],
            headerParameters: [Ls, Ds, _s, ti, {
              parameterPath: 'copyActionAbortConstant',
              mapper: {
                defaultValue: 'abort', isConstant: !0, serializedName: 'x-ms-copy-action', type: { name: 'String' }
              }
            }],
            isXML: !0,
            serializer: zn
          },
          $n = {
            path: '/{containerName}/{blob}',
            httpMethod: 'PUT',
            responses: { 200: { headersMapper: Ar }, 202: { headersMapper: Ar }, default: { bodyMapper: Ct, headersMapper: kr } },
            queryParameters: [ks, bi, fi, {
              parameterPath: 'comp',
              mapper: {
                defaultValue: 'tier', isConstant: !0, serializedName: 'comp', type: { name: 'String' }
              }
            }],
            urlParameters: [Is],
            headerParameters: [Ls, Ds, _s, ti, wi, Di, {
              parameterPath: 'tier',
              mapper: {
                serializedName: 'x-ms-access-tier', required: !0, xmlName: 'x-ms-access-tier', type: { name: 'Enum', allowedValues: ['P4', 'P6', 'P10', 'P15', 'P20', 'P30', 'P40', 'P50', 'P60', 'P70', 'P80', 'Hot', 'Cool', 'Archive'] }
              }
            }],
            isXML: !0,
            serializer: zn
          },
          Kn = {
            path: '/{containerName}/{blob}', httpMethod: 'GET', responses: { 200: { headersMapper: Lr }, default: { bodyMapper: Ct, headersMapper: Dr } }, queryParameters: [As, Gs], urlParameters: [Is], headerParameters: [Ls, _s], isXML: !0, serializer: zn
          },
          Gn = {
            path: '/{containerName}/{blob}',
            httpMethod: 'POST',
            responses: { 200: { bodyMapper: { type: { name: 'Stream' }, serializedName: 'parsedResponse' }, headersMapper: _r }, 206: { bodyMapper: { type: { name: 'Stream' }, serializedName: 'parsedResponse' }, headersMapper: _r }, default: { bodyMapper: Ct, headersMapper: jr } },
            requestBody: Wi,
            queryParameters: [ks, bi, {
              parameterPath: 'comp',
              mapper: {
                defaultValue: 'query', isConstant: !0, serializedName: 'comp', type: { name: 'String' }
              }
            }],
            urlParameters: [Is],
            headerParameters: [Bs, Ts, Ls, Ds, ti, ai, ri, Ci, vi, Pi, zi, Ri, wi],
            isXML: !0,
            contentType: 'application/xml; charset=utf-8',
            mediaType: 'xml',
            serializer: zn
          },
          Qn = {
            path: '/{containerName}/{blob}', httpMethod: 'GET', responses: { 200: { bodyMapper: Mt, headersMapper: Ur }, default: { bodyMapper: Ct, headersMapper: Vr } }, queryParameters: [ks, bi, fi, Ji], urlParameters: [Is], headerParameters: [Ls, Ds, _s, ti, wi], isXML: !0, serializer: zn
          },
          Xn = {
            path: '/{containerName}/{blob}', httpMethod: 'PUT', responses: { 204: { headersMapper: Fr }, default: { bodyMapper: Ct, headersMapper: $r } }, requestBody: Zi, queryParameters: [ks, fi, Ji], urlParameters: [Is], headerParameters: [Bs, Ts, Ls, Ds, ti, wi, Yi, en], isXML: !0, contentType: 'application/xml; charset=utf-8', mediaType: 'xml', serializer: zn
          }; class Wn {
          constructor(e) { this.client = e; }
  
          create(e, t) { const a = { contentLength: e, options: rt(t || {}) }; return this.client.sendOperationRequest(a, Yn); }
  
          appendBlock(e, t, a) { const r = { contentLength: e, body: t, options: rt(a || {}) }; return this.client.sendOperationRequest(r, eo); }
  
          appendBlockFromUrl(e, t, a) { const r = { sourceUrl: e, contentLength: t, options: rt(a || {}) }; return this.client.sendOperationRequest(r, to); }
  
          seal(e) { const t = { options: rt(e || {}) }; return this.client.sendOperationRequest(t, ao); }
        } const Jn = new nt(t, !0),
          Zn = new nt(t, !1),
          Yn = {
            path: '/{containerName}/{blob}',
            httpMethod: 'PUT',
            responses: { 201: { headersMapper: ds }, default: { bodyMapper: Ct, headersMapper: cs } },
            queryParameters: [ks],
            urlParameters: [Is],
            headerParameters: [Ls, Ds, _s, Ws, Ys, ti, ai, ri, Ci, vi, Pi, zi, Ri, wi, Ei, qi, Oi, Bi, Mi, Ti, Hi, Ai, ki, Ki, Gi, {
              parameterPath: 'blobType',
              mapper: {
                defaultValue: 'AppendBlob', isConstant: !0, serializedName: 'x-ms-blob-type', type: { name: 'String' }
              }
            }],
            isXML: !0,
            serializer: Jn
          },
          eo = {
            path: '/{containerName}/{blob}', httpMethod: 'PUT', responses: { 201: { headersMapper: ps }, default: { bodyMapper: Ct, headersMapper: us } }, requestBody: sn, queryParameters: [ks, gn], urlParameters: [Is], headerParameters: [Ls, Ds, Ws, ti, ai, ri, Ci, vi, Pi, zi, Ri, wi, ki, Yi, en, rn, nn, hn, xn], mediaType: 'binary', serializer: Zn
          },
          to = {
            path: '/{containerName}/{blob}', httpMethod: 'PUT', responses: { 201: { headersMapper: ys }, default: { bodyMapper: Ct, headersMapper: gs } }, queryParameters: [ks, gn], urlParameters: [Is], headerParameters: [Ls, Ds, _s, Ws, ti, ai, ri, Ci, vi, Pi, zi, Ri, wi, ki, _i, ji, Ui, Vi, Qi, Xi, Yi, pn, un, hn, xn, Nn], isXML: !0, serializer: Jn
          },
          ao = {
            path: '/{containerName}/{blob}',
            httpMethod: 'PUT',
            responses: { 200: { headersMapper: hs }, default: { bodyMapper: Ct, headersMapper: xs } },
            queryParameters: [ks, {
              parameterPath: 'comp',
              mapper: {
                defaultValue: 'seal', isConstant: !0, serializedName: 'comp', type: { name: 'String' }
              }
            }],
            urlParameters: [Is],
            headerParameters: [Ls, Ds, _s, ti, ai, ri, zi, Ri, xn],
            isXML: !0,
            serializer: Jn
          }; class ro {
          constructor(e) { this.client = e; }
  
          upload(e, t, a) { const r = { contentLength: e, body: t, options: rt(a || {}) }; return this.client.sendOperationRequest(r, no); }
  
          putBlobFromUrl(e, t, a) { const r = { contentLength: e, copySource: t, options: rt(a || {}) }; return this.client.sendOperationRequest(r, oo); }
  
          stageBlock(e, t, a, r) {
            const s = {
              blockId: e, contentLength: t, body: a, options: rt(r || {})
            }; return this.client.sendOperationRequest(s, mo);
          }
  
          stageBlockFromURL(e, t, a, r) {
            const s = {
              blockId: e, contentLength: t, sourceUrl: a, options: rt(r || {})
            }; return this.client.sendOperationRequest(s, lo);
          }
  
          commitBlockList(e, t) { const a = { blocks: e, options: rt(t || {}) }; return this.client.sendOperationRequest(a, co); }
  
          getBlockList(e, t) { const a = { listType: e, options: rt(t || {}) }; return this.client.sendOperationRequest(a, po); }
        } const so = new nt(t, !0),
          io = new nt(t, !1),
          no = {
            path: '/{containerName}/{blob}', httpMethod: 'PUT', responses: { 201: { headersMapper: Ns }, default: { bodyMapper: Ct, headersMapper: bs } }, requestBody: sn, queryParameters: [ks], urlParameters: [Is], headerParameters: [Ls, Ds, Ws, Ys, ti, ai, ri, Ci, vi, Pi, zi, Ri, wi, Ei, qi, Oi, Bi, Mi, Ti, Hi, Ai, ki, Li, Ki, Gi, Yi, rn, nn, bn], mediaType: 'binary', serializer: io
          },
          oo = {
            path: '/{containerName}/{blob}', httpMethod: 'PUT', responses: { 201: { headersMapper: fs }, default: { bodyMapper: Ct, headersMapper: Ss } }, queryParameters: [ks], urlParameters: [Is], headerParameters: [Ls, Ds, _s, Ws, Ys, ti, ai, ri, Ci, vi, Pi, zi, Ri, wi, Ei, qi, Oi, Bi, Mi, Ti, ki, Li, _i, ji, Ui, Vi, Fi, $i, Ki, Qi, Xi, Yi, bn, { parameterPath: ['options', 'copySourceBlobProperties'], mapper: { serializedName: 'x-ms-copy-source-blob-properties', xmlName: 'x-ms-copy-source-blob-properties', type: { name: 'Boolean' } } }], isXML: !0, serializer: so
          },
          mo = {
            path: '/{containerName}/{blob}', httpMethod: 'PUT', responses: { 201: { headersMapper: Cs }, default: { bodyMapper: Ct, headersMapper: vs } }, requestBody: sn, queryParameters: [ks, fn, Sn], urlParameters: [Is], headerParameters: [Ls, Ds, Ws, ti, Ci, vi, Pi, ki, Yi, en, rn, nn], mediaType: 'binary', serializer: io
          },
          lo = {
            path: '/{containerName}/{blob}', httpMethod: 'PUT', responses: { 201: { headersMapper: Ps }, default: { bodyMapper: Ct, headersMapper: zs } }, queryParameters: [ks, fn, Sn], urlParameters: [Is], headerParameters: [Ls, Ds, _s, Ws, ti, Ci, vi, Pi, ki, _i, ji, Ui, Vi, Qi, Xi, pn, un, Nn], isXML: !0, serializer: so
          },
          co = {
            path: '/{containerName}/{blob}', httpMethod: 'PUT', responses: { 201: { headersMapper: Rs }, default: { bodyMapper: Ct, headersMapper: ws } }, requestBody: Cn, queryParameters: [ks, vn], urlParameters: [Is], headerParameters: [Bs, Ts, Ls, Ds, Ys, ti, ai, ri, Ci, vi, Pi, zi, Ri, wi, Ei, qi, Oi, Bi, Mi, Ti, Hi, Ai, ki, Li, Ki, Gi, Yi, en], isXML: !0, contentType: 'application/xml; charset=utf-8', mediaType: 'xml', serializer: so
          },
          po = {
            path: '/{containerName}/{blob}',
            httpMethod: 'GET',
            responses: { 200: { bodyMapper: Ft, headersMapper: Es }, default: { bodyMapper: Ct, headersMapper: qs } },
            queryParameters: [ks, bi, vn, {
              parameterPath: 'listType',
              mapper: {
                defaultValue: 'committed', serializedName: 'blocklisttype', required: !0, xmlName: 'blocklisttype', type: { name: 'Enum', allowedValues: ['committed', 'uncommitted', 'all'] }
              }
            }],
            urlParameters: [Is],
            headerParameters: [Ls, Ds, _s, ti, wi],
            isXML: !0,
            serializer: so
          }; class uo {
          constructor(e) { this.client = e; }
  
          create(e, t, a) { const r = { contentLength: e, blobContentLength: t, options: rt(a || {}) }; return this.client.sendOperationRequest(r, ho); }
  
          uploadPages(e, t, a) { const r = { contentLength: e, body: t, options: rt(a || {}) }; return this.client.sendOperationRequest(r, xo); }
  
          clearPages(e, t) { const a = { contentLength: e, options: rt(t || {}) }; return this.client.sendOperationRequest(a, No); }
  
          uploadPagesFromURL(e, t, a, r, s) {
            const i = {
              sourceUrl: e, sourceRange: t, contentLength: a, range: r, options: rt(s || {})
            }; return this.client.sendOperationRequest(i, bo);
          }
  
          getPageRanges(e) { const t = { options: rt(e || {}) }; return this.client.sendOperationRequest(t, fo); }
  
          getPageRangesDiff(e) { const t = { options: rt(e || {}) }; return this.client.sendOperationRequest(t, So); }
  
          resize(e, t) { const a = { blobContentLength: e, options: rt(t || {}) }; return this.client.sendOperationRequest(a, Co); }
  
          updateSequenceNumber(e, t) { const a = { sequenceNumberAction: e, options: rt(t || {}) }; return this.client.sendOperationRequest(a, vo); }
  
          copyIncremental(e, t) { const a = { copySource: e, options: rt(t || {}) }; return this.client.sendOperationRequest(a, Po); }
        } const yo = new nt(t, !0),
          go = new nt(t, !1),
          ho = {
            path: '/{containerName}/{blob}',
            httpMethod: 'PUT',
            responses: { 201: { headersMapper: Kr }, default: { bodyMapper: Ct, headersMapper: Gr } },
            queryParameters: [ks],
            urlParameters: [Is],
            headerParameters: [Ls, Ds, _s, Ws, Ys, ti, ai, ri, Ci, vi, Pi, zi, Ri, wi, Ei, qi, Oi, Bi, Mi, Ti, Hi, Ai, ki, Li, Ki, Gi, {
              parameterPath: 'blobType',
              mapper: {
                defaultValue: 'PageBlob', isConstant: !0, serializedName: 'x-ms-blob-type', type: { name: 'String' }
              }
            }, tn, an],
            isXML: !0,
            serializer: yo
          },
          xo = {
            path: '/{containerName}/{blob}', httpMethod: 'PUT', responses: { 201: { headersMapper: Qr }, default: { bodyMapper: Ct, headersMapper: Xr } }, requestBody: sn, queryParameters: [ks, on], urlParameters: [Is], headerParameters: [Ls, Ds, Ws, ti, ai, ri, Si, Ci, vi, Pi, zi, Ri, wi, ki, Yi, en, rn, nn, mn, ln, dn, cn], mediaType: 'binary', serializer: go
          },
          No = {
            path: '/{containerName}/{blob}',
            httpMethod: 'PUT',
            responses: { 201: { headersMapper: Wr }, default: { bodyMapper: Ct, headersMapper: Jr } },
            queryParameters: [ks, on],
            urlParameters: [Is],
            headerParameters: [Ls, Ds, _s, Ws, ti, ai, ri, Si, Ci, vi, Pi, zi, Ri, wi, ki, ln, dn, cn, {
              parameterPath: 'pageWrite',
              mapper: {
                defaultValue: 'clear', isConstant: !0, serializedName: 'x-ms-page-write', type: { name: 'String' }
              }
            }],
            isXML: !0,
            serializer: yo
          },
          bo = {
            path: '/{containerName}/{blob}',
            httpMethod: 'PUT',
            responses: { 201: { headersMapper: Zr }, default: { bodyMapper: Ct, headersMapper: Yr } },
            queryParameters: [ks, on],
            urlParameters: [Is],
            headerParameters: [Ls, Ds, _s, Ws, ti, ai, ri, Ci, vi, Pi, zi, Ri, wi, ki, _i, ji, Ui, Vi, Qi, Xi, mn, ln, dn, cn, pn, {
              parameterPath: 'sourceRange',
              mapper: {
                serializedName: 'x-ms-source-range', required: !0, xmlName: 'x-ms-source-range', type: { name: 'String' }
              }
            }, un, {
              parameterPath: 'range',
              mapper: {
                serializedName: 'x-ms-range', required: !0, xmlName: 'x-ms-range', type: { name: 'String' }
              }
            }],
            isXML: !0,
            serializer: yo
          },
          fo = {
            path: '/{containerName}/{blob}', httpMethod: 'GET', responses: { 200: { bodyMapper: Kt, headersMapper: es }, default: { bodyMapper: Ct, headersMapper: ts } }, queryParameters: [ks, bi, yn], urlParameters: [Is], headerParameters: [Ls, Ds, _s, ti, ai, ri, Si, zi, Ri, wi], isXML: !0, serializer: yo
          },
          So = {
            path: '/{containerName}/{blob}', httpMethod: 'GET', responses: { 200: { bodyMapper: Kt, headersMapper: as }, default: { bodyMapper: Ct, headersMapper: rs } }, queryParameters: [ks, bi, yn, { parameterPath: ['options', 'prevsnapshot'], mapper: { serializedName: 'prevsnapshot', xmlName: 'prevsnapshot', type: { name: 'String' } } }], urlParameters: [Is], headerParameters: [Ls, Ds, _s, ti, ai, ri, Si, zi, Ri, wi, { parameterPath: ['options', 'prevSnapshotUrl'], mapper: { serializedName: 'x-ms-previous-snapshot-url', xmlName: 'x-ms-previous-snapshot-url', type: { name: 'String' } } }], isXML: !0, serializer: yo
          },
          Co = {
            path: '/{containerName}/{blob}', httpMethod: 'PUT', responses: { 200: { headersMapper: ss }, default: { bodyMapper: Ct, headersMapper: is } }, queryParameters: [As, ks], urlParameters: [Is], headerParameters: [Ls, Ds, _s, ti, ai, ri, Ci, vi, Pi, zi, Ri, wi, ki, tn], isXML: !0, serializer: yo
          },
          vo = {
            path: '/{containerName}/{blob}',
            httpMethod: 'PUT',
            responses: { 200: { headersMapper: ns }, default: { bodyMapper: Ct, headersMapper: os } },
            queryParameters: [As, ks],
            urlParameters: [Is],
            headerParameters: [Ls, Ds, _s, ti, ai, ri, zi, Ri, wi, an, {
              parameterPath: 'sequenceNumberAction',
              mapper: {
                serializedName: 'x-ms-sequence-number-action', required: !0, xmlName: 'x-ms-sequence-number-action', type: { name: 'Enum', allowedValues: ['max', 'update', 'increment'] }
              }
            }],
            isXML: !0,
            serializer: yo
          },
          Po = {
            path: '/{containerName}/{blob}',
            httpMethod: 'PUT',
            responses: { 202: { headersMapper: ms }, default: { bodyMapper: Ct, headersMapper: ls } },
            queryParameters: [ks, {
              parameterPath: 'comp',
              mapper: {
                defaultValue: 'incrementalcopy', isConstant: !0, serializedName: 'comp', type: { name: 'String' }
              }
            }],
            urlParameters: [Is],
            headerParameters: [Ls, Ds, _s, ai, ri, zi, Ri, wi, $i],
            isXML: !0,
            serializer: yo
          },
          zo = '2020-10-02',
          Ro = 268435456,
          wo = 4194304,
          Eo = 'https://storage.azure.com/.default',
          qo = '_',
          Oo = 'snapshot',
          Bo = 'versionid',
          Mo = 'timeout',
          To = 'Content-ID',
          Io = 'User-Agent',
          Ho = '',
          Ao = ['Access-Control-Allow-Origin', 'Cache-Control', 'Content-Length', 'Content-Type', 'Date', 'Request-Id', 'traceparent', 'Transfer-Encoding', 'User-Agent', 'x-ms-client-request-id', 'x-ms-date', 'x-ms-error-code', 'x-ms-request-id', 'x-ms-return-client-request-id', 'x-ms-version', 'Accept-Ranges', 'Content-Disposition', 'Content-Encoding', 'Content-Language', 'Content-MD5', 'Content-Range', 'ETag', 'Last-Modified', 'Server', 'Vary', 'x-ms-content-crc64', 'x-ms-copy-action', 'x-ms-copy-completion-time', 'x-ms-copy-id', 'x-ms-copy-progress', 'x-ms-copy-status', 'x-ms-has-immutability-policy', 'x-ms-has-legal-hold', 'x-ms-lease-state', 'x-ms-lease-status', 'x-ms-range', 'x-ms-request-server-encrypted', 'x-ms-server-encrypted', 'x-ms-snapshot', 'x-ms-source-range', 'If-Match', 'If-Modified-Since', 'If-None-Match', 'If-Unmodified-Since', 'x-ms-access-tier', 'x-ms-access-tier-change-time', 'x-ms-access-tier-inferred', 'x-ms-account-kind', 'x-ms-archive-status', 'x-ms-blob-append-offset', 'x-ms-blob-cache-control', 'x-ms-blob-committed-block-count', 'x-ms-blob-condition-appendpos', 'x-ms-blob-condition-maxsize', 'x-ms-blob-content-disposition', 'x-ms-blob-content-encoding', 'x-ms-blob-content-language', 'x-ms-blob-content-length', 'x-ms-blob-content-md5', 'x-ms-blob-content-type', 'x-ms-blob-public-access', 'x-ms-blob-sequence-number', 'x-ms-blob-type', 'x-ms-copy-destination-snapshot', 'x-ms-creation-time', 'x-ms-default-encryption-scope', 'x-ms-delete-snapshots', 'x-ms-delete-type-permanent', 'x-ms-deny-encryption-scope-override', 'x-ms-encryption-algorithm', 'x-ms-if-sequence-number-eq', 'x-ms-if-sequence-number-le', 'x-ms-if-sequence-number-lt', 'x-ms-incremental-copy', 'x-ms-lease-action', 'x-ms-lease-break-period', 'x-ms-lease-duration', 'x-ms-lease-id', 'x-ms-lease-time', 'x-ms-page-write', 'x-ms-proposed-lease-id', 'x-ms-range-get-content-md5', 'x-ms-rehydrate-priority', 'x-ms-sequence-number-action', 'x-ms-sku-name', 'x-ms-source-content-md5', 'x-ms-source-if-match', 'x-ms-source-if-modified-since', 'x-ms-source-if-none-match', 'x-ms-source-if-unmodified-since', 'x-ms-tag-count', 'x-ms-encryption-key-sha256', 'x-ms-if-tags', 'x-ms-source-if-tags'],
          ko = ['comp', 'maxresults', 'rscc', 'rscd', 'rsce', 'rscl', 'rsct', 'se', 'si', 'sip', 'sp', 'spr', 'sr', 'srt', 'ss', 'st', 'sv', 'include', 'marker', 'prefix', 'copyid', 'restype', 'blockid', 'blocklisttype', 'delimiter', 'prevsnapshot', 'ske', 'skoid', 'sks', 'skt', 'sktid', 'skv', 'snapshot']; var Lo,
          Do; function _o(e) { if (void 0 !== e) return e; } function jo(e, t) { if (e && !t) throw new RangeError('Customer-provided encryption key must be used over HTTPS.'); e && !e.encryptionAlgorithm && (e.encryptionAlgorithm = 'AES256'); } function Uo(e) {
          const t = (e._response.parsedBody.pageRange || []).map((e=>({ offset: e.start, count: e.end - e.start }))),
            a = (e._response.parsedBody.clearRange || []).map((e=>({ offset: e.start, count: e.end - e.start }))); return Object.assign(Object.assign({}, e), { pageRange: t, clearRange: a, _response: Object.assign(Object.assign({}, e._response), { parsedBody: { pageRange: t, clearRange: a } }) });
        } function Vo(e) {
          return function (t, a) {
            const r = Ke.getTracer('azure/core-tracing', void 0),
              s = (a == null ? void 0 : a.tracingOptions) || {},
              i = Object.assign({ kind: je.INTERNAL }, s.spanOptions),
              n = e.packagePrefix ? `${e.packagePrefix}.${t}` : t; let o; o = (function () { var e; if (typeof process === 'undefined') return !1; const t = (e = process.env.AZURE_TRACING_DISABLED) === null || void 0 === e ? void 0 : e.toLowerCase(); return t !== 'false' && t !== '0' && Boolean(t); }()) ? Ke.wrapSpanContext(ue) : r.startSpan(n, i, s.tracingContext), e.namespace && o.setAttribute('az.namespace', e.namespace); let m = s.spanOptions || {}; o.isRecording() && e.namespace && (m = Object.assign(Object.assign({}, s.spanOptions), { attributes: Object.assign(Object.assign({}, i.attributes), { 'az.namespace': e.namespace }) })); const l = Object.assign(Object.assign({}, s), { spanOptions: m, tracingContext: Ge(s.tracingContext || Qe.active(), o) }); return { span: o, updatedOptions: Object.assign(Object.assign({}, a), { tracingOptions: l }) };
          };
        }!(function (e) { e.Hot = 'Hot', e.Cool = 'Cool', e.Archive = 'Archive'; }(Lo || (Lo = {}))), (function (e) { e.P4 = 'P4', e.P6 = 'P6', e.P10 = 'P10', e.P15 = 'P15', e.P20 = 'P20', e.P30 = 'P30', e.P40 = 'P40', e.P50 = 'P50', e.P60 = 'P60', e.P70 = 'P70', e.P80 = 'P80'; }(Do || (Do = {}))); const Fo = typeof process !== 'undefined' && process.env && process.env.DEBUG || void 0; let $o,
          Ko = [],
          Go = []; const Qo = []; Fo && Wo(Fo); const Xo = Object.assign((e=>Zo(e)), {
          enable: Wo, enabled: Jo, disable: function () { const e = $o || ''; return Wo(''), e; }, log: function (...e) { if (e.length > 0) { const t = String(e[0]); t.includes(':error') ? console.error(...e) : t.includes(':warning') ? console.warn(...e) : t.includes(':info') ? console.info(...e) : (t.includes(':verbose'), console.debug(...e)); } }
        }); function Wo(e) {
          $o = e, Ko = [], Go = []; const t = /\*/g,
            a = e.split(',').map((e=>e.trim().replace(t, '.*?'))); for (const e of a)e.startsWith('-') ? Go.push(new RegExp(`^${e.substr(1)}$`)) : Ko.push(new RegExp(`^${e}$`)); for (const e of Qo)e.enabled = Jo(e.namespace);
        } function Jo(e) { if (e.endsWith('*')) return !0; for (const t of Go) if (t.test(e)) return !1; for (const t of Ko) if (t.test(e)) return !0; return !1; } function Zo(e) {
          const t = Object.assign((function (...a) { t.enabled && (a.length > 0 && (a[0] = `${e} ${a[0]}`), t.log(...a)); }), {
            enabled: Jo(e), destroy: Yo, log: Xo.log, namespace: e, extend: em
          }); return Qo.push(t), t;
        } function Yo() { const e = Qo.indexOf(this); return e >= 0 && (Qo.splice(e, 1), !0); } function em(e) { const t = Zo(`${this.namespace}:${e}`); return t.log = this.log, t; } const tm = Xo,
          am = new Set(),
          rm = typeof process !== 'undefined' && process.env && process.env.AZURE_LOG_LEVEL || void 0; let sm; const im = tm('azure'); im.log = (...e)=>{ tm.log(...e); }; const nm = ['verbose', 'info', 'warning', 'error']; rm && (pm(rm) ? (function (e) { if (e && !pm(e)) throw new Error(`Unknown log level '${e}'. Acceptable values: ${nm.join(',')}`); sm = e; const t = []; for (const e of am)cm(e) && t.push(e.namespace); tm.enable(t.join(',')); }(rm)) : console.error(`AZURE_LOG_LEVEL set to unknown log level '${rm}'; logging is not enabled. Acceptable values: ${nm.join(', ')}.`)); const om = {
          verbose: 400, info: 300, warning: 200, error: 100
        }; function mm(e) {
          const t = im.extend(e); return lm(im, t), {
            error: dm(t, 'error'), warning: dm(t, 'warning'), info: dm(t, 'info'), verbose: dm(t, 'verbose')
          };
        } function lm(e, t) { t.log = (...t)=>{ e.log(...t); }; } function dm(e, t) { const a = Object.assign(e.extend(t), { level: t }); if (lm(e, a), cm(a)) { const e = tm.disable(); tm.enable(e + ',' + a.namespace); } return am.add(a), a; } function cm(e) { return !!(sm && om[e.level] <= om[sm]); } function pm(e) { return nm.includes(e); } const um = mm('core-http'),
          ym = Vo({ packagePrefix: '', namespace: '' }); function gm(e = {}) { return { create: (t, a)=>new hm(t, a, e) }; } class hm extends s {
          constructor(e, t, a) { super(e, t), this.userAgent = a.userAgent; }
  
          async sendRequest(e) { if (!e.tracingContext) return this._nextPolicy.sendRequest(e); const t = this.tryCreateSpan(e); if (!t) return this._nextPolicy.sendRequest(e); try { const a = await this._nextPolicy.sendRequest(e); return this.tryProcessResponse(t, a), a; } catch (e) { throw this.tryProcessError(t, e), e; } }
  
          tryCreateSpan(e) {
            var t; try {
              const a = q.parse(e.url).getPath() || '/',
                { span: r } = ym(a, { tracingOptions: { spanOptions: Object.assign(Object.assign({}, e.spanOptions), { kind: je.CLIENT }), tracingContext: e.tracingContext } }); if (!r.isRecording()) return void r.end(); const s = (t = e.tracingContext) === null || void 0 === t ? void 0 : t.getValue(Symbol.for('az.namespace')); typeof s === 'string' && r.setAttribute('az.namespace', s), r.setAttributes({ 'http.method': e.method, 'http.url': e.url, requestId: e.requestId }), this.userAgent && r.setAttribute('http.user_agent', this.userAgent); const i = r.spanContext(),
                n = (function (e) {
                  const t = []; if (e.traceId || t.push('traceId'), e.spanId || t.push('spanId'), t.length) return; const a = (e.traceFlags || 0).toString(16),
                    r = a.length === 1 ? `0${a}` : a; return `00-${e.traceId}-${e.spanId}-${r}`;
                }(i)); if (n && (function (e) { return Ke.isSpanContextValid(e); }(i))) { e.headers.set('traceparent', n); const t = i.traceState && i.traceState.serialize(); t && e.headers.set('tracestate', t); } return r;
            } catch (e) { return void um.warning(`Skipping creating a tracing span due to an error: ${e.message}`); }
          }
  
          tryProcessError(e, t) { try { e.setStatus({ code: Xe.ERROR, message: t.message }), t.statusCode && e.setAttribute('http.status_code', t.statusCode), e.end(); } catch (e) { um.warning(`Skipping tracing span processing due to an error: ${e.message}`); } }
  
          tryProcessResponse(e, t) { try { e.setAttribute('http.status_code', t.status); const a = t.headers.get('x-ms-request-id'); a && e.setAttribute('serviceRequestId', a), e.setStatus({ code: Xe.OK }), e.end(); } catch (e) { um.warning(`Skipping tracing span processing due to an error: ${e.message}`); } }
        } const xm = { enable: !0 }; class Nm extends s {
          constructor(e, t, a) { super(e, t), this.keepAliveOptions = a; }
  
          async sendRequest(e) { return e.keepAlive = this.keepAliveOptions.enable, this._nextPolicy.sendRequest(e); }
        } function bm(e = 'x-ms-client-request-id') { return { create: (t, a)=>new fm(t, a, e) }; } class fm extends s {
          constructor(e, t, a) { super(e, t), this._requestIdHeaderName = a; }
  
          sendRequest(e) { return e.headers.contains(this._requestIdHeaderName) || e.headers.set(this._requestIdHeaderName, e.requestId), this._nextPolicy.sendRequest(e); }
        } const Sm = 'REDACTED',
          Cm = ['x-ms-client-request-id', 'x-ms-return-client-request-id', 'x-ms-useragent', 'x-ms-correlation-request-id', 'x-ms-request-id', 'client-request-id', 'ms-cv', 'return-client-request-id', 'traceparent', 'Access-Control-Allow-Credentials', 'Access-Control-Allow-Headers', 'Access-Control-Allow-Methods', 'Access-Control-Allow-Origin', 'Access-Control-Expose-Headers', 'Access-Control-Max-Age', 'Access-Control-Request-Headers', 'Access-Control-Request-Method', 'Origin', 'Accept', 'Accept-Encoding', 'Cache-Control', 'Connection', 'Content-Length', 'Content-Type', 'Date', 'ETag', 'Expires', 'If-Match', 'If-Modified-Since', 'If-None-Match', 'If-Unmodified-Since', 'Last-Modified', 'Pragma', 'Request-Id', 'Retry-After', 'Server', 'Transfer-Encoding', 'User-Agent'],
          vm = ['api-version']; class Pm {
          constructor({ allowedHeaderNames: e = [], allowedQueryParameters: t = [] } = {}) { e = Array.isArray(e) ? Cm.concat(e) : Cm, t = Array.isArray(t) ? vm.concat(t) : vm, this.allowedHeaderNames = new Set(e.map((e=>e.toLowerCase()))), this.allowedQueryParameters = new Set(t.map((e=>e.toLowerCase()))); }
  
          sanitize(e) { const t = new Set(); return JSON.stringify(e, ((e, a)=>{ if (a instanceof Error) return Object.assign(Object.assign({}, a), { name: a.name, message: a.message }); if (e === '_headersMap') return this.sanitizeHeaders(a); if (e === 'url') return this.sanitizeUrl(a); if (e === 'query') return this.sanitizeQuery(a); if (e !== 'body' && e !== 'response' && e !== 'operationSpec') { if (Array.isArray(a) || !(typeof (r = a) !== 'object' || r === null || Array.isArray(r) || r instanceof RegExp || r instanceof Date)) { if (t.has(a)) return '[Circular]'; t.add(a); } var r; return a; } }), 2); }
  
          sanitizeHeaders(e) { return this.sanitizeObject(e, this.allowedHeaderNames, ((e, t)=>e[t].value)); }
  
          sanitizeQuery(e) { return this.sanitizeObject(e, this.allowedQueryParameters, ((e, t)=>e[t])); }
  
          sanitizeObject(e, t, a) { if (typeof e !== 'object' || e === null) return e; const r = {}; for (const s of Object.keys(e))t.has(s.toLowerCase()) ? r[s] = a(e, s) : r[s] = Sm; return r; }
  
          sanitizeUrl(e) {
            if (typeof e !== 'string' || e === null) return e; const t = q.parse(e),
              a = t.getQuery(); if (!a) return e; const r = E.parse(a); for (const e of r.keys()) this.allowedQueryParameters.has(e.toLowerCase()) || r.set(e, Sm); return t.setQuery(r.toString()), t.toString();
          }
        } const zm = {},
          Rm = new Pm(); class wm extends Error {
          constructor(e, t, a, r, s) { super(e), this.name = 'RestError', this.code = t, this.statusCode = a, this.request = r, this.response = s, Object.setPrototypeOf(this, wm.prototype); }
  
          [zm]() { return `RestError: ${this.message} \n ${Rm.sanitize(this)}`; }
        } if (wm.REQUEST_SEND_ERROR = 'REQUEST_SEND_ERROR', wm.PARSE_ERROR = 'PARSE_ERROR', !(self.document && self.DOMParser && self.Node && self.XMLSerializer)) throw new Error('This library depends on the following DOM objects: ["document", "DOMParser", "Node", "XMLSerializer"] to parse XML, but some of these are undefined. You may provide a polyfill to make these globally available in order to support your environment. For more information, please refer to https://aka.ms/azsdk/js/web-workers. '); const Em = document.implementation.createDocument(null, null, null),
          qm = new DOMParser(); let Om; function Bm(e, t) {
          let a = {}; const r = e.childNodes.length,
            s = e.childNodes[0],
            i = s && r === 1 && s.nodeType === Node.TEXT_NODE && s.nodeValue || void 0,
            n = (function (e) { return (function (e) { return !!e.attributes; }(e)) && e.hasAttributes() ? e : void 0; }(e)); if (n) { a[d] = {}; for (let e = 0; e < n.attributes.length; e++) { const t = n.attributes[e]; a[d][t.nodeName] = t.nodeValue; }i && (a[t.xmlCharKey] = i); } else r === 0 ? a = '' : i && (a = i); if (!i) for (let s = 0; s < r; s++) { const r = e.childNodes[s]; if (r.nodeType !== Node.TEXT_NODE) { const e = Bm(r, t); a[r.nodeName] ? Array.isArray(a[r.nodeName]) ? a[r.nodeName].push(e) : a[r.nodeName] = [a[r.nodeName], e] : a[r.nodeName] = e; } } return a;
        } const Mm = new XMLSerializer(); function Tm(e, t = {}) {
          var a,
            r,
            s; const i = { rootName: (a = t.rootName) !== null && void 0 !== a ? a : 'root', includeRoot: (r = t.includeRoot) !== null && void 0 !== r && r, xmlCharKey: (s = t.xmlCharKey) !== null && void 0 !== s ? s : c },
            n = Hm(e, i.rootName, i)[0]; return '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' + Mm.serializeToString(n);
        } function Im(e) { const t = []; for (const a of Object.keys(e)) { const r = Em.createAttribute(a); r.value = e[a].toString(), t.push(r); } return t; } function Hm(e, t, a) { if (e == null || typeof e === 'string' || typeof e === 'number' || typeof e === 'boolean') { const a = Em.createElement(t); return a.textContent = e == null ? '' : e.toString(), [a]; } if (Array.isArray(e)) { const r = []; for (const s of e) for (const e of Hm(s, t, a))r.push(e); return r; } if (typeof e === 'object') { const r = Em.createElement(t); for (const t of Object.keys(e)) if (t === d) for (const a of Im(e[t]))r.attributes.setNamedItem(a); else if (t === a.xmlCharKey)r.textContent = e[t].toString(); else for (const s of Hm(e[t], t, a))r.appendChild(s); return [r]; } throw new Error(`Illegal value passed to buildObject: ${e}`); } function Am(e, t) { return { create: (a, r)=>new Dm(a, r, e, t) }; } const km = ['application/json', 'text/json'],
          Lm = ['application/xml', 'application/atom+xml']; class Dm extends s {
          constructor(e, t, a, r = {}) { var s; super(e, t), this.jsonContentTypes = a && a.json || km, this.xmlContentTypes = a && a.xml || Lm, this.xmlCharKey = (s = r.xmlCharKey) !== null && void 0 !== s ? s : c; }
  
          async sendRequest(e) {
            return this._nextPolicy.sendRequest(e).then((e=>(function (e, t, a, r = {}) {
              var s,
                i,
                n; const o = { rootName: (s = r.rootName) !== null && void 0 !== s ? s : '', includeRoot: (i = r.includeRoot) !== null && void 0 !== i && i, xmlCharKey: (n = r.xmlCharKey) !== null && void 0 !== n ? n : c }; return (function (e, t, a, r) {
                var s; const i = e=>{
                  const t = `Error "${e}" occurred while parsing the response body - ${a.bodyAsText}.`,
                    r = e.code || wm.PARSE_ERROR,
                    s = new wm(t, r, a.status, a.request, a); return Promise.reject(s);
                }; if (!((s = a.request.streamResponseStatusCodes) === null || void 0 === s ? void 0 : s.has(a.status)) && !a.request.streamResponseBody && a.bodyAsText) {
                  const s = a.bodyAsText,
                    n = a.headers.get('Content-Type') || '',
                    o = n ? n.split(';').map((e=>e.toLowerCase())) : []; if (o.length === 0 || o.some((t=>e.indexOf(t) !== -1))) return new Promise((e=>{ a.parsedBody = JSON.parse(s), e(a); })).catch(i); if (o.some((e=>t.indexOf(e) !== -1))) {
                    return (function (e, t = {}) {
                      var a,
                        r,
                        s; try {
                        const i = { rootName: (a = t.rootName) !== null && void 0 !== a ? a : '', includeRoot: (r = t.includeRoot) !== null && void 0 !== r && r, xmlCharKey: (s = t.xmlCharKey) !== null && void 0 !== s ? s : c },
                          n = qm.parseFromString(e, 'application/xml'); let o; return (function (e) { const t = e.getElementsByTagName('parsererror'); if (t.length > 0 && (function () { var e; if (void 0 === Om) try { Om = (e = qm.parseFromString('INVALID', 'text/xml').getElementsByTagName('parsererror')[0].namespaceURI) !== null && void 0 !== e ? e : ''; } catch (e) { Om = ''; } return Om; }())) for (let e = 0; e < t.length; e++) if (t[e].namespaceURI === Om) throw new Error(t[e].innerHTML); }(n)), o = i.includeRoot ? Bm(n, i) : Bm(n.childNodes[0], i), Promise.resolve(o);
                      } catch (e) { return Promise.reject(e); }
                    }(s, r)).then((e=>(a.parsedBody = e, a))).catch(i);
                  }
                } return Promise.resolve(a);
              }(e, t, a, o)).then((e=>{
                if (!(function (e) { const t = e.request.shouldDeserialize; let a; return a = void 0 === t || (typeof t === 'boolean' ? t : t(e)), a; }(e))) return e; const t = e.request.operationSpec; if (!t || !t.responses) return e; const s = (function (e) {
                    let t; const a = e.request,
                      r = a.operationSpec; if (r) { const s = a.operationResponseGetter; t = s ? s(r, e) : r.responses[e.status]; } return t;
                  }(e)),
                  { error: i, shouldReturnResponse: n } = (function (e, t, a) {
                    var r; const s = e.status >= 200 && e.status < 300; if ((function (e) { const t = Object.keys(e.responses); return t.length === 0 || t.length === 1 && t[0] === 'default'; }(t)) ? s : a) { if (!a) return { error: null, shouldReturnResponse: !1 }; if (!a.isError) return { error: null, shouldReturnResponse: !1 }; } const i = a != null ? a : t.responses.default,
                      n = ((r = e.request.streamResponseStatusCodes) === null || void 0 === r ? void 0 : r.has(e.status)) || e.request.streamResponseBody ? `Unexpected status code: ${e.status}` : e.bodyAsText,
                      o = new wm(n, void 0, e.status, e.request, e); if (!i) throw o; const m = i.bodyMapper,
                      l = i.headersMapper; try { if (e.parsedBody) { const a = e.parsedBody; let r; if (m) { let e = a; t.isXML && m.type.name === gt.Sequence && (e = typeof a === 'object' ? a[m.xmlElementName] : []), r = t.serializer.deserialize(m, e, 'error.response.parsedBody'); } const s = a.error || r || a; o.code = s.code, s.message && (o.message = s.message), m && (o.response.parsedBody = r); }e.headers && l && (o.response.parsedHeaders = t.serializer.deserialize(l, e.headers.rawHeaders(), 'operationRes.parsedHeaders')); } catch (t) { o.message = `Error "${t.message}" occurred in deserializing the responseBody - "${e.bodyAsText}" for the default response.`; } return { error: o, shouldReturnResponse: !1 };
                  }(e, t, s)); if (i) throw i; if (n) return e; if (s) { if (s.bodyMapper) { let a = e.parsedBody; t.isXML && s.bodyMapper.type.name === gt.Sequence && (a = typeof a === 'object' ? a[s.bodyMapper.xmlElementName] : []); try { e.parsedBody = t.serializer.deserialize(s.bodyMapper, a, 'operationRes.parsedBody', r); } catch (t) { throw new wm(`Error ${t} occurred in deserializing the responseBody - ${e.bodyAsText}`, void 0, e.status, e.request, e); } } else t.httpMethod === 'HEAD' && (e.parsedBody = a.status >= 200 && a.status < 300); s.headersMapper && (e.parsedHeaders = t.serializer.deserialize(s.headersMapper, e.headers.rawHeaders(), 'operationRes.parsedHeaders', r)); } return e;
              }));
            }(this.jsonContentTypes, this.xmlContentTypes, e, { xmlCharKey: this.xmlCharKey }))));
          }
        } function _m(e = {}) { return { create: (t, a)=>new jm(t, a, e) }; } class jm extends s {
          constructor(e, t, { logger: a = um.info, allowedHeaderNames: r = [], allowedQueryParameters: s = [] } = {}) { super(e, t), this.logger = a, this.sanitizer = new Pm({ allowedHeaderNames: r, allowedQueryParameters: s }); }
  
          get allowedHeaderNames() { return this.sanitizer.allowedHeaderNames; }
  
          set allowedHeaderNames(e) { this.sanitizer.allowedHeaderNames = e; }
  
          get allowedQueryParameters() { return this.sanitizer.allowedQueryParameters; }
  
          set allowedQueryParameters(e) { this.sanitizer.allowedQueryParameters = e; }
  
          sendRequest(e) { return this.logger.enabled ? (this.logRequest(e), this._nextPolicy.sendRequest(e).then((e=>this.logResponse(e)))) : this._nextPolicy.sendRequest(e); }
  
          logRequest(e) { this.logger(`Request: ${this.sanitizer.sanitize(e)}`); }
  
          logResponse(e) { return this.logger(`Response status code: ${e.status}`), this.logger(`Headers: ${this.sanitizer.sanitize(e.headers)}`), e; }
        } const Um = new Error('DisableResponseDecompressionPolicy is not supported in browser environment'),
          Vm = 'authorization',
          Fm = 'Retry-After'; var $m = new WeakMap(),
          Km = new WeakMap(),
          Gm = (function () {
            function e() { this.onabort = null, $m.set(this, []), Km.set(this, !1); } return Object.defineProperty(e.prototype, 'aborted', { get: function () { if (!Km.has(this)) throw new TypeError('Expected `this` to be an instance of AbortSignal.'); return Km.get(this); }, enumerable: !1, configurable: !0 }), Object.defineProperty(e, 'none', { get: function () { return new e(); }, enumerable: !1, configurable: !0 }), e.prototype.addEventListener = function (e, t) { if (!$m.has(this)) throw new TypeError('Expected `this` to be an instance of AbortSignal.'); $m.get(this).push(t); }, e.prototype.removeEventListener = function (e, t) {
              if (!$m.has(this)) throw new TypeError('Expected `this` to be an instance of AbortSignal.'); var a = $m.get(this),
                r = a.indexOf(t); r > -1 && a.splice(r, 1);
            }, e.prototype.dispatchEvent = function (e) { throw new Error('This is a stub dispatchEvent implementation that should not be used.  It only exists for type-checking purposes.'); }, e;
          }()); function Qm(e) { if (!e.aborted) { e.onabort && e.onabort.call(e); var t = $m.get(e); t && t.slice().forEach((function (t) { t.call(e, { type: 'abort' }); })), Km.set(e, !0); } } var Xm = (function (e) { function t(t) { var a = e.call(this, t) || this; return a.name = 'AbortError', a; } return (function (e, t) { if (typeof t !== 'function' && t !== null) throw new TypeError('Class extends value ' + String(t) + ' is not a constructor or null'); function a() { this.constructor = e; }Ze(e, t), e.prototype = t === null ? Object.create(t) : (a.prototype = t.prototype, new a()); }(t, e)), t; }(Error)); function Wm(e, t, a) {
          return new Promise(((r, s)=>{
            let i,
              n; const o = ()=>s(new Xm((a == null ? void 0 : a.abortErrorMsg) ? a == null ? void 0 : a.abortErrorMsg : 'The operation was aborted.')),
              m = ()=>{ (a == null ? void 0 : a.abortSignal) && n && a.abortSignal.removeEventListener('abort', n); }; if (n = ()=>(i != null && clearTimeout(i), m(), o()), (a == null ? void 0 : a.abortSignal) && a.abortSignal.aborted) return o(); i = setTimeout((()=>{ m(), r(t); }), e), (a == null ? void 0 : a.abortSignal) && a.abortSignal.addEventListener('abort', n);
          }));
        }!(function () {
          function e(e) { var t = this; if (this._signal = new Gm(), e) { Array.isArray(e) || (e = arguments); for (var a = 0, r = e; a < r.length; a++) { var s = r[a]; s.aborted ? this.abort() : s.addEventListener('abort', (function () { t.abort(); })); } } }Object.defineProperty(e.prototype, 'signal', { get: function () { return this._signal; }, enumerable: !1, configurable: !0 }), e.prototype.abort = function () { Qm(this._signal); }, e.timeout = function (e) {
            var t = new Gm(),
              a = setTimeout(Qm, e, t); return typeof a.unref === 'function' && a.unref(), t;
          };
        }()); const Jm = { forcedRefreshWindowInMs: 1e3, retryIntervalInMs: 3e3, refreshWindowInMs: 12e4 }; function Zm(e, t) {
          const a = (function (e, t, a) {
            let r = null,
              s = null; const i = Object.assign(Object.assign({}, Jm), a),
              n = { get isRefreshing() { return r !== null; }, get shouldRefresh() { var e; return !n.isRefreshing && ((e = s == null ? void 0 : s.expiresOnTimestamp) !== null && void 0 !== e ? e : 0) - i.refreshWindowInMs < Date.now(); }, get mustRefresh() { return s === null || s.expiresOnTimestamp - i.forcedRefreshWindowInMs < Date.now(); } }; function o(a) { var o; return n.isRefreshing || (r = (async function (e, t, a) { async function r() { if (!(Date.now() < a)) { const t = await e(); if (t === null) throw new Error('Failed to refresh access token.'); return t; } try { return await e(); } catch (e) { return null; } }let s = await r(); for (;s === null;) await Wm(t), s = await r(); return s; }((()=>e.getToken(t, a)), i.retryIntervalInMs, (o = s == null ? void 0 : s.expiresOnTimestamp) !== null && void 0 !== o ? o : Date.now())).then((e=>(r = null, s = e, s))).catch((e=>{ throw r = null, s = null, e; }))), r; } return async e=>n.mustRefresh ? o(e) : (n.shouldRefresh && o(e), s);
          }(e, t)); class r extends s {
            constructor(e, t) { super(e, t); }
  
            async sendRequest(e) { if (!e.url.toLowerCase().startsWith('https://')) throw new Error('Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.'); const { token: t } = await a({ abortSignal: e.abortSignal, tracingOptions: { tracingContext: e.tracingContext } }); return e.headers.set(Vm, `Bearer ${t}`), this._nextPolicy.sendRequest(e); }
          } return { create: (e, t)=>new r(e, t) };
        } const Ym = mm('storage-blob'); function el(e, t) { const a = e.split(';'); for (const e of a) if (e.trim().startsWith(t)) return e.trim().match(t + '=(.*)')[1]; return ''; } function tl(e) {
          let t = ''; e.startsWith('UseDevelopmentStorage=true') && (t = (function (e) { let t = ''; if (e.search('DevelopmentStorageProxyUri=') !== -1) { const a = e.split(';'); for (const e of a)e.trim().startsWith('DevelopmentStorageProxyUri=') && (t = e.trim().match('DevelopmentStorageProxyUri=(.*)')[1]); } return t; }(e)), e = 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://127.0.0.1:10000/devstoreaccount1;'); let a = el(e, 'BlobEndpoint'); if (a = a.endsWith('/') ? a.slice(0, -1) : a, e.search('DefaultEndpointsProtocol=') !== -1 && e.search('AccountKey=') !== -1) {
            let r = '',
              s = '',
              i = Buffer.from('accountKey', 'base64'),
              n = ''; if (s = el(e, 'AccountName'), i = Buffer.from(el(e, 'AccountKey'), 'base64'), !a) { r = el(e, 'DefaultEndpointsProtocol'); const t = r.toLowerCase(); if (t !== 'https' && t !== 'http') throw new Error("Invalid DefaultEndpointsProtocol in the provided Connection String. Expecting 'https' or 'http'"); if (n = el(e, 'EndpointSuffix'), !n) throw new Error('Invalid EndpointSuffix in the provided Connection String'); a = `${r}://${s}.blob.${n}`; } if (!s) throw new Error('Invalid AccountName in the provided Connection String'); if (i.length === 0) throw new Error('Invalid AccountKey in the provided Connection String'); return {
              kind: 'AccountConnString', url: a, accountName: s, accountKey: i, proxyUri: t
            };
          } { const t = el(e, 'SharedAccessSignature'),
            r = cl(a); if (!a) throw new Error('Invalid BlobEndpoint in the provided SAS Connection String'); if (!t) throw new Error('Invalid SharedAccessSignature in the provided SAS Connection String'); return {
            kind: 'SASConnString', url: a, accountName: r, accountSas: t
          }; }
        } function al(e, t) { const a = q.parse(e); let r = a.getPath(); return r = r ? r.endsWith('/') ? `${r}${t}` : `${r}/${t}` : t, a.setPath(r), a.toString(); } function rl(e, t, a) { const r = q.parse(e); return r.setQueryParameter(t, a), r.toString(); } function sl(e, t) { return q.parse(e).getQueryParameterValue(t); } function il(e) { return q.parse(e).getPath(); } function nl(e) {
          const t = q.parse(e),
            a = t.getPath(); if (!a) throw new RangeError('Invalid url without valid path.'); let r = t.getQuery() || ''; return r = r.trim(), r !== '' && (r = r.startsWith('?') ? r : `?${r}`), `${a}${r}`;
        } function ol(e, t) { const a = q.parse(e); let r = a.getQuery(); return r ? r += '&' + t : r = t, a.setQuery(r), a.toString(); } function ml(e, t = !0) { const a = e.toISOString(); return t ? a.substring(0, a.length - 1) + '0000Z' : a.substring(0, a.length - 5) + 'Z'; } function ll(e, t) { e.length > 42 && (e = e.slice(0, 42)); return a = e + (function (e, t, a = ' ') { return String.prototype.padStart ? e.padStart(t, a) : (a = a || ' ', e.length > t ? e : ((t -= e.length) > a.length && (a += a.repeat(t / a.length)), a.slice(0, t) + e)); }(t.toString(), 48 - e.length, '0')), S ? Buffer.from(a).toString('base64') : btoa(a); var a; } function dl(e, t) { return e.toLocaleLowerCase() === t.toLocaleLowerCase(); } function cl(e) { const t = q.parse(e); let a; try { return a = t.getHost().split('.')[1] === 'blob' ? t.getHost().split('.')[0] : pl(t) ? t.getPath().split('/')[1] : '', a; } catch (e) { throw new Error('Unable to extract accountName with provided information.'); } } function pl(e) { if (void 0 === e.getHost()) return !1; const t = e.getHost() + (void 0 === e.getPort() ? '' : ':' + e.getPort()); return /^.*:.*:.*$|^localhost(:[0-9]+)?$|^(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])(\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])){3}(:[0-9]+)?$/.test(t); } function ul(e) { if (void 0 === e) return; const t = []; for (const a in e) if (Object.prototype.hasOwnProperty.call(e, a)) { const r = e[a]; t.push(`${encodeURIComponent(a)}=${encodeURIComponent(r)}`); } return t.join('&'); } function yl(e) { if (void 0 === e) return; const t = { blobTagSet: [] }; for (const a in e) if (Object.prototype.hasOwnProperty.call(e, a)) { const r = e[a]; t.blobTagSet.push({ key: a, value: r }); } return t; } function gl(e) { if (void 0 === e) return; const t = {}; for (const a of e.blobTagSet)t[a.key] = a.value; return t; } function hl(e) {
          if (void 0 !== e) {
            switch (e.kind) {
              case 'csv': return {
                format: {
                  type: 'delimited',
                  delimitedTextConfiguration: {
                    columnSeparator: e.columnSeparator || ',', fieldQuote: e.fieldQuote || '', recordSeparator: e.recordSeparator, escapeChar: e.escapeCharacter || '', headersPresent: e.hasHeaders || !1
                  }
                }
              }; case 'json': return { format: { type: 'json', jsonTextConfiguration: { recordSeparator: e.recordSeparator } } }; case 'arrow': return { format: { type: 'arrow', arrowConfiguration: { schema: e.schema } } }; case 'parquet': return { format: { type: 'parquet' } }; default: throw Error('Invalid BlobQueryTextConfiguration.');
            }
          }
        } function xl(e) {
          if (!e) return; if ('policy-id' in e) return; const t = []; for (const a in e) {
            const r = a.split('_'),
              s = 'or-'; r[0].startsWith(s) && (r[0] = r[0].substring(s.length)); const i = { ruleId: r[1], replicationStatus: e[a] },
              n = t.findIndex((e=>e.policyId === r[0])); n > -1 ? t[n].rules.push(i) : t.push({ policyId: r[0], rules: [i] });
          } return t;
        } function Nl(e, t) { return e.credential = t, e; } function bl(e) { return e ? e.scheme + ' ' + e.value : void 0; } class fl extends s {
          constructor(e, t) { super(e, t); }
  
          async sendRequest(e) { return S || (e.method.toUpperCase() !== 'GET' && e.method.toUpperCase() !== 'HEAD' || (e.url = rl(e.url, qo, (new Date()).getTime().toString())), e.headers.remove('Cookie'), e.headers.remove('Content-Length')), this._nextPolicy.sendRequest(e); }
        } class Sl {create(e, t) { return new fl(e, t); }} var Cl; !(function (e) { e[e.EXPONENTIAL = 0] = 'EXPONENTIAL', e[e.FIXED = 1] = 'FIXED'; }(Cl || (Cl = {}))); const vl = {
            maxRetryDelayInMs: 12e4, maxTries: 4, retryDelayInMs: 4e3, retryPolicyType: Cl.EXPONENTIAL, secondaryHost: '', tryTimeoutInMs: void 0
          },
          Pl = new Xm('The operation was aborted.'); class zl extends s {
          constructor(e, t, a = vl) {
            super(e, t), this.retryOptions = {
              retryPolicyType: a.retryPolicyType ? a.retryPolicyType : vl.retryPolicyType, maxTries: a.maxTries && a.maxTries >= 1 ? Math.floor(a.maxTries) : vl.maxTries, tryTimeoutInMs: a.tryTimeoutInMs && a.tryTimeoutInMs >= 0 ? a.tryTimeoutInMs : vl.tryTimeoutInMs, retryDelayInMs: a.retryDelayInMs && a.retryDelayInMs >= 0 ? Math.min(a.retryDelayInMs, a.maxRetryDelayInMs ? a.maxRetryDelayInMs : vl.maxRetryDelayInMs) : vl.retryDelayInMs, maxRetryDelayInMs: a.maxRetryDelayInMs && a.maxRetryDelayInMs >= 0 ? a.maxRetryDelayInMs : vl.maxRetryDelayInMs, secondaryHost: a.secondaryHost ? a.secondaryHost : vl.secondaryHost
            };
          }
  
          async sendRequest(e) { return this.attemptSendRequest(e, !1, 1); }
  
          async attemptSendRequest(e, t, a) {
            const r = e.clone(),
              s = t || !this.retryOptions.secondaryHost || !(e.method === 'GET' || e.method === 'HEAD' || e.method === 'OPTIONS') || a % 2 == 1; let i; s || (r.url = (function (e, t) { const a = q.parse(e); return a.setHost(t), a.toString(); }(r.url, this.retryOptions.secondaryHost))), this.retryOptions.tryTimeoutInMs && (r.url = rl(r.url, Mo, Math.floor(this.retryOptions.tryTimeoutInMs / 1e3).toString())); try { if (Ym.info(`RetryPolicy: =====> Try=${a} ${s ? 'Primary' : 'Secondary'}`), i = await this._nextPolicy.sendRequest(r), !this.shouldRetry(s, a, i)) return i; t = t || !s && i.status === 404; } catch (e) { if (Ym.error(`RetryPolicy: Caught error, message: ${e.message}, code: ${e.code}`), !this.shouldRetry(s, a, i, e)) throw e; } return await this.delay(s, a, e.abortSignal), this.attemptSendRequest(e, t, ++a);
          }
  
          shouldRetry(e, t, a, r) { if (t >= this.retryOptions.maxTries) return Ym.info(`RetryPolicy: Attempt(s) ${t} >= maxTries ${this.retryOptions.maxTries}, no further try.`), !1; const s = ['ETIMEDOUT', 'ESOCKETTIMEDOUT', 'ECONNREFUSED', 'ECONNRESET', 'ENOENT', 'ENOTFOUND', 'TIMEOUT', 'EPIPE', 'REQUEST_SEND_ERROR']; if (r) for (const e of s) if (r.name.toUpperCase().includes(e) || r.message.toUpperCase().includes(e) || r.code && r.code.toString().toUpperCase() === e) return Ym.info(`RetryPolicy: Network error ${e} found, will retry.`), !0; if (a || r) { const t = a ? a.status : r ? r.statusCode : 0; if (!e && t === 404) return Ym.info('RetryPolicy: Secondary access with 404, will retry.'), !0; if (t === 503 || t === 500) return Ym.info(`RetryPolicy: Will retry for status code ${t}.`), !0; } return !((r == null ? void 0 : r.code) !== 'PARSE_ERROR' || !(r == null ? void 0 : r.message.startsWith('Error "Error: Unclosed root tag')) || (Ym.info('RetryPolicy: Incomplete XML response likely due to service timeout, will retry.'), 0)); }
  
          async delay(e, t, a) { let r = 0; if (e) switch (this.retryOptions.retryPolicyType) { case Cl.EXPONENTIAL: r = Math.min((Math.pow(2, t - 1) - 1) * this.retryOptions.retryDelayInMs, this.retryOptions.maxRetryDelayInMs); break; case Cl.FIXED: r = this.retryOptions.retryDelayInMs; } else r = 1e3 * Math.random(); return Ym.info(`RetryPolicy: Delay for ${r}ms`), (async function (e, t, a) { return new Promise(((r, s)=>{ let i; const n = ()=>{ void 0 !== i && clearTimeout(i), s(a); }; i = setTimeout((()=>{ void 0 !== t && t.removeEventListener('abort', n), r(); }), e), void 0 !== t && t.addEventListener('abort', n); })); }(r, a, Pl)); }
        } class Rl {
          constructor(e) { this.retryOptions = e; }
  
          create(e, t) { return new zl(e, t, this.retryOptions); }
        } var wl = a(598); function El(e) { return e.toLowerCase(); } function ql(e) { if (e && typeof e === 'object') { const t = e; if (typeof t.rawHeaders === 'function' && typeof t.clone === 'function' && typeof t.get === 'function' && typeof t.set === 'function' && typeof t.contains === 'function' && typeof t.remove === 'function' && typeof t.headersArray === 'function' && typeof t.headerValues === 'function' && typeof t.headerNames === 'function' && typeof t.toJson === 'function') return !0; } return !1; } class Ol {
          constructor(e) { if (this._headersMap = {}, e) for (const t in e) this.set(t, e[t]); }
  
          set(e, t) { this._headersMap[El(e)] = { name: e, value: t.toString() }; }
  
          get(e) { const t = this._headersMap[El(e)]; return t ? t.value : void 0; }
  
          contains(e) { return !!this._headersMap[El(e)]; }
  
          remove(e) { const t = this.contains(e); return delete this._headersMap[El(e)], t; }
  
          rawHeaders() { return this.toJson({ preserveCase: !0 }); }
  
          headersArray() { const e = []; for (const t in this._headersMap)e.push(this._headersMap[t]); return e; }
  
          headerNames() {
            const e = [],
              t = this.headersArray(); for (let a = 0; a < t.length; ++a)e.push(t[a].name); return e;
          }
  
          headerValues() {
            const e = [],
              t = this.headersArray(); for (let a = 0; a < t.length; ++a)e.push(t[a].value); return e;
          }
  
          toJson(e = {}) { const t = {}; if (e.preserveCase) for (const e in this._headersMap) { const a = this._headersMap[e]; t[a.name] = a.value; } else for (const e in this._headersMap) { const a = this._headersMap[e]; t[El(a.name)] = a.value; } return t; }
  
          toString() { return JSON.stringify(this.toJson({ preserveCase: !0 })); }
  
          clone() { const e = {}; for (const t in this._headersMap) { const a = this._headersMap[t]; e[a.name] = a.value; } return new Ol(e); }
        } class Bl extends s {
          constructor(e, t, a) { super(e, t), this.telemetry = a; }
  
          async sendRequest(e) { return S && (e.headers || (e.headers = new Ol()), e.headers.get(Io) || e.headers.set(Io, this.telemetry)), this._nextPolicy.sendRequest(e); }
        } class Ml {
          constructor(e) { const t = []; if (S) { if (e) { const a = e.userAgentPrefix || ''; a.length > 0 && t.indexOf(a) === -1 && t.push(a); } const a = 'azsdk-js-storageblob/12.8.0'; t.indexOf(a) === -1 && t.push(a); const r = `(NODE-VERSION ${process.version}; ${wl.type()} ${wl.release()})`; t.indexOf(r) === -1 && t.push(r); } this.telemetryString = t.join(' '); }
  
          create(e, t) { return new Bl(e, t, this.telemetryString); }
        } class Tl {
          sendRequest(e) {
            var t; const a = new XMLHttpRequest(); if (e.proxySettings) throw new Error('HTTP proxy is not supported in browser environment'); const r = e.abortSignal; if (r) { if (r.aborted) return Promise.reject(new Xm('The operation was aborted.')); const e = ()=>{ a.abort(); }; r.addEventListener('abort', e), a.addEventListener('readystatechange', (()=>{ a.readyState === XMLHttpRequest.DONE && r.removeEventListener('abort', e); })); } if (Il(a.upload, e.onUploadProgress), Il(a, e.onDownloadProgress), e.formData) {
              const t = e.formData,
                a = new FormData(),
                r = (e, t)=>{ t && Object.prototype.hasOwnProperty.call(t, 'value') && Object.prototype.hasOwnProperty.call(t, 'options') ? a.append(e, t.value, t.options) : a.append(e, t); }; for (const e of Object.keys(t)) { const a = t[e]; if (Array.isArray(a)) for (let t = 0; t < a.length; t++)r(e, a[t]); else r(e, a); }e.body = a, e.formData = void 0; const s = e.headers.get('Content-Type'); s && s.indexOf('multipart/form-data') !== -1 && e.headers.remove('Content-Type');
            }a.open(e.method, e.url), a.timeout = e.timeout, a.withCredentials = e.withCredentials; for (const t of e.headers.headersArray())a.setRequestHeader(t.name, t.value); return a.responseType = ((t = e.streamResponseStatusCodes) === null || void 0 === t ? void 0 : t.size) || e.streamResponseBody ? 'blob' : 'text', a.send(void 0 === e.body ? null : e.body), a.responseType === 'blob' ? new Promise(((t, r)=>{
              !(function (e, t, a, r) {
                e.addEventListener('readystatechange', (()=>{
                  var s; if (e.readyState === XMLHttpRequest.HEADERS_RECEIVED) {
                    if (t.streamResponseBody || ((s = t.streamResponseStatusCodes) === null || void 0 === s ? void 0 : s.has(e.status))) {
                      const r = new Promise(((a, r)=>{ e.addEventListener('load', (()=>{ a(e.response); })), Al(t, e, r); })); a({
                        request: t, status: e.status, headers: Hl(e), blobBody: r
                      });
                    } else {
                      e.addEventListener('load', (()=>{
                        if (e.response) {
                          const s = new FileReader(); s.onload = function (r) {
                            var s; const i = (s = r.target) === null || void 0 === s ? void 0 : s.result; a({
                              request: t, status: e.status, headers: Hl(e), bodyAsText: i
                            });
                          }, s.onerror = function (e) { r(s.error); }, s.readAsText(e.response, 'UTF-8');
                        } else a({ request: t, status: e.status, headers: Hl(e) });
                      }));
                    }
                  }
                }));
              }(a, e, t, r)), Al(e, a, r);
            })) : new Promise((function (t, r) {
              a.addEventListener('load', (()=>t({
                request: e, status: a.status, headers: Hl(a), bodyAsText: a.responseText
              }))), Al(e, a, r);
            }));
          }
        } function Il(e, t) { t && e.addEventListener('progress', (e=>t({ loadedBytes: e.loaded }))); } function Hl(e) {
          const t = new Ol(),
            a = e.getAllResponseHeaders().trim().split(/[\r\n]+/); for (const e of a) {
            const a = e.indexOf(':'),
              r = e.slice(0, a),
              s = e.slice(a + 2); t.set(r, s);
          } return t;
        } function Al(e, t, a) { t.addEventListener('error', (()=>a(new wm(`Failed to send request to ${e.url}`, wm.REQUEST_SEND_ERROR, void 0, e)))); const r = new Xm('The operation was aborted.'); t.addEventListener('abort', (()=>a(r))), t.addEventListener('timeout', (()=>a(r))); } const kl = new Tl(); function Ll(e) { if (!e || typeof e !== 'object') return !1; const t = e; return Array.isArray(t.factories) && typeof t.options === 'object' && typeof t.toServiceClientOptions === 'function'; } class Dl {
          constructor(e, t = {}) { this.factories = e, this.options = Object.assign(Object.assign({}, t), { httpClient: t.httpClient || kl }); }
  
          toServiceClientOptions() { return { httpClient: this.options.httpClient, requestPolicyFactories: this.factories }; }
        } function _l(e, t = {}) {
          void 0 === e && (e = new l()); const a = new Ml(t.userAgentOptions),
            r = [gm({ userAgent: a.telemetryString }), (s = t.keepAliveOptions, { create: (e, t)=>new Nm(e, t, s || xm) }), a, bm(), new Sl(), new Rl(t.retryOptions), Am(void 0, { xmlCharKey: '#' }), _m({ logger: Ym.info, allowedHeaderNames: Ao, allowedQueryParameters: ko })]; var s; return S && (r.push(w(t.proxyOptions)), r.push({ create: (e, t)=>{ throw Um; } })), r.push(z(e) ? Nl(Zm(e, Eo), e) : e), new Dl(r, t);
        } class jl extends Error {constructor(e) { super(e), this.name = 'PollerStoppedError', Object.setPrototypeOf(this, jl.prototype); }} class Ul extends Error {constructor(e) { super(e), this.name = 'PollerCancelledError', Object.setPrototypeOf(this, Ul.prototype); }} class Vl extends class {
          constructor(e) { this.stopped = !0, this.pollProgressCallbacks = [], this.operation = e, this.promise = new Promise(((e, t)=>{ this.resolve = e, this.reject = t; })), this.promise.catch((()=>{})); }
  
          async startPolling() { for (this.stopped && (this.stopped = !1); !this.isStopped() && !this.isDone();) await this.poll(), await this.delay(); }
  
          async pollOnce(e = {}) { try { this.isDone() || (this.operation = await this.operation.update({ abortSignal: e.abortSignal, fireProgress: this.fireProgress.bind(this) }), this.isDone() && this.resolve && this.resolve(this.operation.state.result)); } catch (e) { throw this.operation.state.error = e, this.reject && this.reject(e), e; } }
  
          fireProgress(e) { for (const t of this.pollProgressCallbacks)t(e); }
  
          async cancelOnce(e = {}) { this.operation = await this.operation.cancel(e), this.reject && this.reject(new Ul('Poller cancelled')); }
  
          poll(e = {}) { if (!this.pollOncePromise) { this.pollOncePromise = this.pollOnce(e); const t = ()=>{ this.pollOncePromise = void 0; }; this.pollOncePromise.then(t, t).catch(this.reject); } return this.pollOncePromise; }
  
          async pollUntilDone() { return this.stopped && this.startPolling().catch(this.reject), this.promise; }
  
          onProgress(e) { return this.pollProgressCallbacks.push(e), ()=>{ this.pollProgressCallbacks = this.pollProgressCallbacks.filter((t=>t !== e)); }; }
  
          isDone() { const e = this.operation.state; return Boolean(e.isCompleted || e.isCancelled || e.error); }
  
          stopPolling() { this.stopped || (this.stopped = !0, this.reject && this.reject(new jl('This poller is already stopped'))); }
  
          isStopped() { return this.stopped; }
  
          cancelOperation(e = {}) { if (this.stopped || (this.stopped = !0), this.cancelPromise) { if (e.abortSignal) throw new Error('A cancel request is currently pending'); } else this.cancelPromise = this.cancelOnce(e); return this.cancelPromise; }
  
          getOperationState() { return this.operation.state; }
  
          getResult() { return this.operation.state.result; }
  
          toString() { return this.operation.toString(); }
        } {
          constructor(e) {
            const {
              blobClient: t, copySource: a, intervalInMs: r = 15e3, onProgress: s, resumeFrom: i, startCopyFromURLOptions: n
            } = e; let o; i && (o = JSON.parse(i).state), super(Gl(Object.assign(Object.assign({}, o), { blobClient: t, copySource: a, startCopyFromURLOptions: n }))), typeof s === 'function' && this.onProgress(s), this.intervalInMs = r;
          }
  
          delay() { return Wm(this.intervalInMs); }
        } const Fl = async function (e = {}) {
            const t = this.state,
              { copyId: a } = t; return t.isCompleted ? Gl(t) : a ? (await t.blobClient.abortCopyFromURL(a, { abortSignal: e.abortSignal }), t.isCancelled = !0, Gl(t)) : (t.isCancelled = !0, Gl(t));
          },
          $l = async function (e = {}) {
            const t = this.state,
              { blobClient: a, copySource: r, startCopyFromURLOptions: s } = t; if (t.isStarted) {
              if (!t.isCompleted) {
                try {
                  const a = await t.blobClient.getProperties({ abortSignal: e.abortSignal }),
                    { copyStatus: r, copyProgress: s } = a,
                    i = t.copyProgress; s && (t.copyProgress = s), r === 'pending' && s !== i && typeof e.fireProgress === 'function' ? e.fireProgress(t) : r === 'success' ? (t.result = a, t.isCompleted = !0) : r === 'failed' && (t.error = new Error(`Blob copy failed with reason: "${a.copyStatusDescription || 'unknown'}"`), t.isCompleted = !0);
                } catch (e) { t.error = e, t.isCompleted = !0; }
              }
            } else { t.isStarted = !0; const e = await a.startCopyFromURL(r, s); t.copyId = e.copyId, e.copyStatus === 'success' && (t.result = e, t.isCompleted = !0); } return Gl(t);
          },
          Kl = function () { return JSON.stringify({ state: this.state }, ((e, t)=>{ if (e !== 'blobClient') return t; })); }; function Gl(e) {
          return {
            state: Object.assign({}, e), cancel: Fl, toString: Kl, update: $l
          };
        } function Ql(e) { if (e.offset < 0) throw new RangeError('Range.offset cannot be smaller than 0.'); if (e.count && e.count <= 0) throw new RangeError('Range.count must be larger than 0. Leave it undefined if you want a range from offset to the end.'); return e.count ? `bytes=${e.offset}-${e.offset + e.count - 1}` : `bytes=${e.offset}-`; } const Xl = ['GET', 'HEAD']; class Wl extends s {
          constructor(e, t, a = 20) { super(e, t), this.maxRetries = a; }
  
          sendRequest(e) { return this._nextPolicy.sendRequest(e).then((e=>Jl(this, e, 0))); }
        } function Jl(e, t, a) {
          const { request: r, status: s } = t,
            i = t.headers.get('location'); if (i && (s === 300 || s === 301 && Xl.includes(r.method) || s === 302 && Xl.includes(r.method) || s === 303 && r.method === 'POST' || s === 307) && (!e.maxRetries || a < e.maxRetries)) { const t = q.parse(r.url); return t.setPath(i), r.url = t.toString(), s === 303 && (r.method = 'GET', delete r.body), e._nextPolicy.sendRequest(r).then((t=>Jl(e, t, a + 1))); } return Promise.resolve(t);
        } function Zl(e) { return typeof e === 'number'; } function Yl(e, t, a, r, s) { return !!t(r, s) && a.retryCount < e; } function ed(e, t = { retryCount: 0, retryInterval: 0 }, a) { a && (t.error && (a.innerError = t.error), t.error = a), t.retryCount++; let r = Math.pow(2, t.retryCount - 1) - 1; return r *= 0.8 * e.retryInterval + Math.floor(Math.random() * (0.4 * e.retryInterval)), t.retryInterval = Math.min(e.minRetryInterval + r, e.maxRetryInterval), t; } var td; !(function (e) { e[e.Exponential = 0] = 'Exponential'; }(td || (td = {}))); class ad extends s {
          constructor(e, t, a, r, s) { super(e, t), this.retryCount = Zl(a) ? a : 3, this.retryInterval = Zl(r) ? r : 3e4, this.maxRetryInterval = Zl(s) ? s : 9e4; }
  
          sendRequest(e) { return this._nextPolicy.sendRequest(e.clone()).then((t=>rd(this, e, t))).catch((t=>rd(this, e, t.response, void 0, t))); }
        } async function rd(e, t, a, r, s) { r = ed({ retryInterval: e.retryInterval, minRetryInterval: 0, maxRetryInterval: e.maxRetryInterval }, r, s); const i = t.abortSignal && t.abortSignal.aborted; if (i || !Yl(e.retryCount, (function (e) { const t = e == null ? void 0 : e.status; return !(t === 503 && (a == null ? void 0 : a.headers.get(Fm)) || void 0 === t || t < 500 && t !== 408 || t === 501 || t === 505); }), r, a)) { if (i || s || !a) throw r.error || new wm('Failed to send the request.', wm.REQUEST_SEND_ERROR, a && a.status, a && a.request, a); return a; }um.info(`Retrying request in ${r.retryInterval}`); try { await Wm(r.retryInterval); const a = await e._nextPolicy.sendRequest(t.clone()); return rd(e, t, a, r); } catch (s) { return rd(e, t, a, r, s); } } function sd(e) { return id(e.parameterPath, e.mapper); } function id(e, t) { let a; return a = typeof e === 'string' ? e : Array.isArray(e) ? e.join('.') : t.serializedName, a; } class nd {
          constructor(e, t, a, r, s, i, n, o, m, l, d, c, p, u, y) { this.streamResponseBody = i, this.streamResponseStatusCodes = y, this.url = e || '', this.method = t || 'GET', this.headers = ql(s) ? s : new Ol(s), this.body = a, this.query = r, this.formData = void 0, this.withCredentials = n || !1, this.abortSignal = o, this.timeout = m || 0, this.onUploadProgress = l, this.onDownloadProgress = d, this.proxySettings = c, this.keepAlive = p, this.decompressResponse = u, this.requestId = this.headers.get('x-ms-client-request-id') || C(); }
  
          validateRequestProperties() { if (!this.method) throw new Error('WebResource.method is required.'); if (!this.url) throw new Error('WebResource.url is required.'); }
  
          prepare(e) {
            if (!e) throw new Error('options object is required'); if (void 0 === e.method || e.method === null || typeof e.method.valueOf() !== 'string') throw new Error('options.method must be a string.'); if (e.url && e.pathTemplate) throw new Error('options.url and options.pathTemplate are mutually exclusive. Please provide exactly one of them.'); if (!(void 0 !== e.pathTemplate && e.pathTemplate !== null && typeof e.pathTemplate.valueOf() === 'string' || void 0 !== e.url && e.url !== null && typeof e.url.valueOf() === 'string')) throw new Error('Please provide exactly one of options.pathTemplate or options.url.'); if (e.url) { if (typeof e.url !== 'string') throw new Error('options.url must be of type "string".'); this.url = e.url; } if (e.method) { const t = ['GET', 'PUT', 'HEAD', 'DELETE', 'OPTIONS', 'POST', 'PATCH', 'TRACE']; if (t.indexOf(e.method.toUpperCase()) === -1) throw new Error('The provided method "' + e.method + '" is invalid. Supported HTTP methods are: ' + JSON.stringify(t)); } if (this.method = e.method.toUpperCase(), e.pathTemplate) {
              const { pathTemplate: t, pathParameters: a } = e; if (typeof t !== 'string') throw new Error('options.pathTemplate must be of type "string".'); e.baseUrl || (e.baseUrl = 'https://management.azure.com'); const r = e.baseUrl; let s = r + (r.endsWith('/') ? '' : '/') + (t.startsWith('/') ? t.slice(1) : t); const i = s.match(/({[\w-]*\s*[\w-]*})/gi); if (i && i.length) {
                if (!a) throw new Error(`pathTemplate: ${t} has been provided. Hence, options.pathParameters must also be provided.`); i.forEach((function (e) {
                  const r = e.slice(1, -1),
                    i = a[r]; if (i == null || typeof i !== 'string' && typeof i !== 'object') { const e = JSON.stringify(a, void 0, 2); throw new Error(`pathTemplate: ${t} contains the path parameter ${r} however, it is not present in parameters: ${e}.The value of the path parameter can either be a "string" of the form { ${r}: "some sample value" } or it can be an "object" of the form { "${r}": { value: "some sample value", skipUrlEncoding: true } }.`); } if (typeof i.valueOf() === 'string' && (s = s.replace(e, encodeURIComponent(i))), typeof i.valueOf() === 'object') { if (!i.value) throw new Error(`options.pathParameters[${r}] is of type "object" but it does not contain a "value" property.`); s = i.skipUrlEncoding ? s.replace(e, i.value) : s.replace(e, encodeURIComponent(i.value)); }
                }));
              } this.url = s;
            } if (e.queryParameters) { const t = e.queryParameters; if (typeof t !== 'object') throw new Error('options.queryParameters must be of type object. It should be a JSON object of "query-parameter-name" as the key and the "query-parameter-value" as the value. The "query-parameter-value" may be fo type "string" or an "object" of the form { value: "query-parameter-value", skipUrlEncoding: true }.'); this.url && this.url.indexOf('?') === -1 && (this.url += '?'); const a = []; this.query = {}; for (const e in t) { const r = t[e]; if (r) if (typeof r === 'string')a.push(e + '=' + encodeURIComponent(r)), this.query[e] = encodeURIComponent(r); else if (typeof r === 'object') { if (!r.value) throw new Error(`options.queryParameters[${e}] is of type "object" but it does not contain a "value" property.`); r.skipUrlEncoding ? (a.push(e + '=' + r.value), this.query[e] = r.value) : (a.push(e + '=' + encodeURIComponent(r.value)), this.query[e] = encodeURIComponent(r.value)); } } this.url += a.join('&'); } if (e.headers) { const t = e.headers; for (const a of Object.keys(e.headers)) this.headers.set(a, t[a]); } return this.headers.get('accept-language') || this.headers.set('accept-language', 'en-US'), this.headers.get('x-ms-client-request-id') || e.disableClientRequestId || this.headers.set('x-ms-client-request-id', this.requestId), this.headers.get('Content-Type') || this.headers.set('Content-Type', 'application/json; charset=utf-8'), this.body = e.body, void 0 !== e.body && e.body !== null && (e.bodyIsStream ? (this.headers.get('Transfer-Encoding') || this.headers.set('Transfer-Encoding', 'chunked'), this.headers.get('Content-Type') !== 'application/octet-stream' && this.headers.set('Content-Type', 'application/octet-stream')) : (e.serializationMapper && (this.body = new nt(e.mappers).serialize(e.serializationMapper, e.body, 'requestBody')), e.disableJsonStringifyOnBody || (this.body = JSON.stringify(e.body)))), e.spanOptions && (this.spanOptions = e.spanOptions), e.tracingContext && (this.tracingContext = e.tracingContext), this.abortSignal = e.abortSignal, this.onDownloadProgress = e.onDownloadProgress, this.onUploadProgress = e.onUploadProgress, this;
          }
  
          clone() { const e = new nd(this.url, this.method, this.body, this.query, this.headers && this.headers.clone(), this.streamResponseBody, this.withCredentials, this.abortSignal, this.timeout, this.onUploadProgress, this.onDownloadProgress, this.proxySettings, this.keepAlive, this.decompressResponse, this.streamResponseStatusCodes); return this.formData && (e.formData = this.formData), this.operationSpec && (e.operationSpec = this.operationSpec), this.shouldDeserialize && (e.shouldDeserialize = this.shouldDeserialize), this.operationResponseGetter && (e.operationResponseGetter = this.operationResponseGetter), e; }
        } const od = function () { return 'x-ms-useragent'; }; function md() {
          const e = [{ key: 'core-http', value: '2.2.3' }],
            t = (function () { const e = self.navigator; return [{ key: 'OS', value: (e.oscpu || e.platform).replace(' ', '') }]; }()); return (function (e, t = ' ', a = '/') { return e.map((e=>{ const t = e.value ? `${a}${e.value}` : ''; return `${e.key}${t}`; })).join(t); }(e.concat(t)));
        } class ld extends s {
          constructor(e, t, a, r) { super(e, t), this._nextPolicy = e, this._options = t, this.headerKey = a, this.headerValue = r; }
  
          sendRequest(e) { return this.addUserAgentHeader(e), this._nextPolicy.sendRequest(e); }
  
          addUserAgentHeader(e) { e.headers || (e.headers = new Ol()), !e.headers.get(this.headerKey) && this.headerValue && e.headers.set(this.headerKey, this.headerValue); }
        } const dd = URL; let cd; class pd extends s {
          constructor(e, t, a = 30) { super(e, t), this._retryTimeout = a; }
  
          sendRequest(e) {
            return this._nextPolicy.sendRequest(e.clone()).then((t=>(function (e, t, a) {
              if (a.status === 409) {
                const r = (function (e) {
                  let t,
                    a; if (e) { try { a = JSON.parse(e); } catch (e) {} if (a && a.error && a.error.message && a.error.code && a.error.code === 'MissingSubscriptionRegistration') { const e = a.error.message.match(/.*'(.*)'/i); e && (t = e.pop()); } } return t;
                }(a.bodyAsText)); if (r) {
                  const s = (function (e) { let t; const a = e.match(/.*\/subscriptions\/[a-f0-9-]+\//gi); if (!a || !a[0]) throw new Error(`Unable to extract subscriptionId from the given url - ${e}.`); return t = a[0], t; }(t.url)); return (async function (e, t, a, r) {
                    const s = `${t}providers/${a}/register?api-version=2016-02-01`,
                      i = `${t}providers/${a}?api-version=2016-02-01`,
                      n = ud(r); if (n.method = 'POST', n.url = s, (await e._nextPolicy.sendRequest(n)).status !== 200) throw new Error(`Autoregistration of ${a} failed. Please try registering manually.`); return yd(e, i, r);
                  }(e, s, r, t)).catch((()=>!1)).then((r=>r ? (t.headers.set('x-ms-client-request-id', C()), e._nextPolicy.sendRequest(t.clone())) : a));
                }
              } return Promise.resolve(a);
            }(this, e, t))));
          }
        } function ud(e, t = !1) { const a = e.clone(); return t && (a.url = e.url), a.headers.set('x-ms-client-request-id', C()), a.headers.set('Content-Type', 'application/json; charset=utf-8'), a; } async function yd(e, t, a) {
          const r = ud(a); r.url = t, r.method = 'GET'; const s = await e._nextPolicy.sendRequest(r),
            i = s.parsedBody; return !(!s.parsedBody || !i.registrationState || i.registrationState !== 'Registered') || (await Wm(1e3 * e._retryTimeout), yd(e, t, a));
        } class gd extends s {
          constructor(e, t, a) { super(e, t), this.authenticationProvider = a; }
  
          signRequest(e) { return this.authenticationProvider.signRequest(e); }
  
          sendRequest(e) { return this.signRequest(e).then((e=>this._nextPolicy.sendRequest(e))); }
        } class hd extends s {
          constructor(e, t, a, r, s, i) { super(e, t), this.retryCount = Zl(a) ? a : 3, this.retryInterval = Zl(r) ? r : 3e4, this.minRetryInterval = Zl(s) ? s : 3e3, this.maxRetryInterval = Zl(i) ? i : 9e4; }
  
          sendRequest(e) { return this._nextPolicy.sendRequest(e.clone()).catch((t=>xd(this, e, t.response, t))); }
        } async function xd(e, t, a, r, s) { if (s = ed(e, s, r), !Yl(e.retryCount, (function (e, t) { return !(!t || !t.code || t.code !== 'ETIMEDOUT' && t.code !== 'ESOCKETTIMEDOUT' && t.code !== 'ECONNREFUSED' && t.code !== 'ECONNRESET' && t.code !== 'ENOENT'); }), s, a, r)) return r ? Promise.reject(s.error) : a; try { return await Wm(s.retryInterval), e._nextPolicy.sendRequest(t.clone()); } catch (r) { return xd(e, t, a, r, s); } } const Nd = { TooManyRequests: 429, ServiceUnavailable: 503 },
          bd = 'The operation was aborted.'; class fd extends s {
          constructor(e, t, a) { super(e, t), this.numberOfRetries = 0, this._handleResponse = a || this._defaultResponseHandler; }
  
          async sendRequest(e) { const t = await this._nextPolicy.sendRequest(e.clone()); return t.status !== Nd.TooManyRequests && t.status !== Nd.ServiceUnavailable ? t : this._handleResponse(e, t); }
  
          async _defaultResponseHandler(e, t) { var a; const r = t.headers.get(Fm); if (r) { const t = fd.parseRetryAfterHeader(r); if (t) { if (this.numberOfRetries += 1, await Wm(t, void 0, { abortSignal: e.abortSignal, abortErrorMsg: bd }), (a = e.abortSignal) === null || void 0 === a ? void 0 : a.aborted) throw new Xm(bd); return this.numberOfRetries < 3 ? this.sendRequest(e) : this._nextPolicy.sendRequest(e); } } return t; }
  
          static parseRetryAfterHeader(e) { const t = Number(e); return Number.isNaN(t) ? fd.parseDateRetryAfterHeader(e) : 1e3 * t; }
  
          static parseDateRetryAfterHeader(e) {
            try {
              const t = Date.now(),
                a = Date.parse(e) - t; return Number.isNaN(a) ? void 0 : a;
            } catch (e) {}
          }
        } function Sd(e, t) { let a; return typeof e === 'string' ? a = e : (a = t(), typeof e === 'function' && (a = e(a))), a; } function Cd(e, t, a, r) { return vd(e, t, a.parameterPath, a.mapper, r); } function vd(e, t, a, r, s) {
          var i; let n; typeof a === 'string' && (a = [a]); const o = (i = t.options) === null || void 0 === i ? void 0 : i.serializerOptions; if (Array.isArray(a)) { if (a.length > 0) { if (r.isConstant)n = r.defaultValue; else { let s = Pd(t, a); s.propertyFound || (s = Pd(e, a)); let i = !1; s.propertyFound || (i = r.required || a[0] === 'options' && a.length === 2), n = i ? r.defaultValue : s.propertyValue; } const i = id(a, r); s.serialize(r, n, i, o); } } else {
            r.required && (n = {}); for (const i in a) {
              const m = r.type.modelProperties[i],
                l = a[i],
                d = vd(e, t, l, m, s),
                c = id(l, m); s.serialize(m, d, c, o), d != null && (n || (n = {}), n[i] = d);
            }
          } return n;
        } function Pd(e, t) { const a = { propertyFound: !1 }; let r = 0; for (;r < t.length; ++r) { const a = t[r]; if (e == null || !(a in e)) break; e = e[a]; } return r === t.length && (a.propertyValue = e, a.propertyFound = !0), a; } function zd(e, t) {
          const a = e.parsedHeaders,
            r = t && t.bodyMapper,
            s = t=>Object.defineProperty(t, '_response', { value: e }); if (r) {
            const t = r.type.name; if (t === 'Stream') return s(Object.assign(Object.assign({}, a), { blobBody: e.blobBody, readableStreamBody: e.readableStreamBody })); const i = t === 'Composite' && r.type.modelProperties || {},
              n = Object.keys(i).some((e=>i[e].serializedName === '')); if (t === 'Sequence' || n) { const t = [...e.parsedBody || []]; for (const a of Object.keys(i))i[a].serializedName && (t[a] = e.parsedBody[a]); if (a) for (const e of Object.keys(a))t[e] = a[e]; return s(t), t; } if (t === 'Composite' || t === 'Dictionary') return s(Object.assign(Object.assign({}, a), e.parsedBody));
          } return r || e.request.method === 'HEAD' || typeof (i = e.parsedBody) !== 'object' && typeof i !== 'function' || i === null ? s(Object.assign(Object.assign({}, a), { body: e.parsedBody })) : s(Object.assign(Object.assign({}, a), e.parsedBody)); var i;
        } class Rd extends class {
          constructor(e, t) {
            let a; if (t || (t = {}), this._withCredentials = t.withCredentials || !1, this._httpClient = t.httpClient || (cd || (cd = new Tl()), cd), this._requestPolicyOptions = new i(t.httpPipelineLogger), Array.isArray(t.requestPolicyFactories))um.info('ServiceClient: using custom request policies'), a = t.requestPolicyFactories; else {
              let s; if (z(e)) {
                um.info('ServiceClient: creating bearer token authentication policy from provided credentials'); const a = ()=>{
                  let a; const r = this,
                    s = t; return { create(t, i) { const n = (function (e, t) { if (e == null ? void 0 : e.credentialScopes) { const t = e.credentialScopes; return Array.isArray(t) ? t.map((e=>new dd(e).toString())) : new dd(t).toString(); } if (t) return `${t}/.default`; }(s, r.baseUri)); if (!n) throw new Error('When using credential, the ServiceClient must contain a baseUri or a credentialScopes in ServiceClientOptions. Unable to create a bearerTokenAuthenticationPolicy'); return a == null && (a = Zm(e, n)), a.create(t, i); } };
                }; s = a();
              } else if (e && typeof e.signRequest === 'function')um.info('ServiceClient: creating signing policy from provided credentials'), r = e, s = { create: (e, t)=>new gd(e, t, r) }; else if (e != null) throw new Error('The credentials argument must implement the TokenCredential interface'); if (um.info('ServiceClient: using default request policies'), a = (function (e, t) {
                const a = []; t.generateClientRequestIdHeader && a.push(bm(t.clientRequestIdHeaderName)), e && a.push(e); const r = Sd(t.userAgentHeaderName, od),
                  s = Sd(t.userAgent, md); return r && s && a.push(function (e) {
                  const t = e && e.key != null ? e.key : 'x-ms-useragent',
                    a = e && e.value != null ? e.value : md(); return { create: (e, r)=>new ld(e, r, t, a) };
                }({ key: r, value: s })), a.push(function (e = 20) { return { create: (t, a)=>new Wl(t, a, e) }; }()), a.push(function (e = 30) { return { create: (t, a)=>new pd(t, a, e) }; }(t.rpRegistrationRetryTimeout)), t.noRetryPolicy || (a.push({ create: (e, t)=>new ad(e, t, undefined, undefined, undefined) }), a.push({ create: (e, t)=>new hd(e, t, void 0, void 0, void 0, void 0) }), a.push({ create: (e, t)=>new fd(e, t) })), a.push(Am(t.deserializationContentTypes)), S && a.push(w(t.proxySettings)), a.push(_m({ logger: um.info })), a;
              }(s, t)), t.requestPolicyFactories) { const e = t.requestPolicyFactories(a); e && (a = e); }
            } var r; this._requestPolicyFactories = a;
          }
  
          sendRequest(e) { if (e == null || typeof e !== 'object') throw new Error('options cannot be null or undefined and it must be of type object.'); let t; try { !(function (e) { if (e && typeof e === 'object') { const t = e; if (typeof t.url === 'string' && typeof t.method === 'string' && typeof t.headers === 'object' && ql(t.headers) && typeof t.validateRequestProperties === 'function' && typeof t.prepare === 'function' && typeof t.clone === 'function') return !0; } return !1; }(e)) ? (t = new nd(), t = t.prepare(e)) : (e.validateRequestProperties(), t = e); } catch (e) { return Promise.reject(e); }let a = this._httpClient; if (this._requestPolicyFactories && this._requestPolicyFactories.length > 0) for (let e = this._requestPolicyFactories.length - 1; e >= 0; --e)a = this._requestPolicyFactories[e].create(a, this._requestPolicyOptions); return a.sendRequest(t); }
  
          async sendOperationRequest(e, t, a) {
            var r; typeof e.options === 'function' && (a = e.options, e.options = void 0); const s = (r = e.options) === null || void 0 === r ? void 0 : r.serializerOptions,
              i = new nd(); let n; try {
              const a = t.baseUrl || this.baseUri; if (!a) throw new Error('If operationSpec.baseUrl is not specified, then the ServiceClient must have a baseUri string property that contains the base URL to use.'); i.method = t.httpMethod, i.operationSpec = t; const r = q.parse(a); if (t.path && r.appendPath(t.path), t.urlParameters && t.urlParameters.length > 0) for (const a of t.urlParameters) { let i = Cd(this, e, a, t.serializer); i = t.serializer.serialize(a.mapper, i, sd(a), s), a.skipEncoding || (i = encodeURIComponent(i)), r.replaceAll(`{${a.mapper.serializedName || sd(a)}}`, i); } if (t.queryParameters && t.queryParameters.length > 0) for (const a of t.queryParameters) { let i = Cd(this, e, a, t.serializer); if (i != null) { if (i = t.serializer.serialize(a.mapper, i, sd(a), s), void 0 !== a.collectionFormat && a.collectionFormat !== null) if (a.collectionFormat === Os.Multi) { if (i.length === 0) continue; for (const e in i) { const t = i[e]; i[e] = t == null ? '' : t.toString(); } } else a.collectionFormat !== Os.Ssv && a.collectionFormat !== Os.Tsv || (i = i.join(a.collectionFormat)); if (!a.skipEncoding) if (Array.isArray(i)) for (const e in i) void 0 !== i[e] && i[e] !== null && (i[e] = encodeURIComponent(i[e])); else i = encodeURIComponent(i); void 0 !== a.collectionFormat && a.collectionFormat !== null && a.collectionFormat !== Os.Multi && a.collectionFormat !== Os.Ssv && a.collectionFormat !== Os.Tsv && (i = i.join(a.collectionFormat)), r.setQueryParameter(a.mapper.serializedName || sd(a), i); } }i.url = r.toString(); const o = t.contentType || this.requestContentType; if (o && t.requestBody && i.headers.set('Content-Type', o), t.headerParameters) for (const a of t.headerParameters) { let r = Cd(this, e, a, t.serializer); if (r != null) { r = t.serializer.serialize(a.mapper, r, sd(a), s); const e = a.mapper.headerCollectionPrefix; if (e) for (const t of Object.keys(r))i.headers.set(e + t, r[t]); else i.headers.set(a.mapper.serializedName || sd(a), r); } } const m = e.options; if (m) { if (m.customHeaders) for (const e in m.customHeaders)i.headers.set(e, m.customHeaders[e]); m.abortSignal && (i.abortSignal = m.abortSignal), m.timeout && (i.timeout = m.timeout), m.onUploadProgress && (i.onUploadProgress = m.onUploadProgress), m.onDownloadProgress && (i.onDownloadProgress = m.onDownloadProgress), m.spanOptions && (i.spanOptions = m.spanOptions), m.tracingContext && (i.tracingContext = m.tracingContext), void 0 !== m.shouldDeserialize && m.shouldDeserialize !== null && (i.shouldDeserialize = m.shouldDeserialize); }let l,
                p; i.withCredentials = this._withCredentials, (function (e, t, a, r) {
                var s,
                  i,
                  n,
                  o,
                  m,
                  l; const p = (i = (s = a.options) === null || void 0 === s ? void 0 : s.serializerOptions) !== null && void 0 !== i ? i : {},
                  u = { rootName: (n = p.rootName) !== null && void 0 !== n ? n : '', includeRoot: (o = p.includeRoot) !== null && void 0 !== o && o, xmlCharKey: (m = p.xmlCharKey) !== null && void 0 !== m ? m : c },
                  y = p.xmlCharKey; if (r.requestBody && r.requestBody.mapper) {
                  t.body = Cd(e, a, r.requestBody, r.serializer); const s = r.requestBody.mapper,
                    {
                      required: i, xmlName: n, xmlElementName: o, serializedName: m, xmlNamespace: c, xmlNamespacePrefix: p
                    } = s,
                    g = s.type.name; try {
                    if (void 0 !== t.body && t.body !== null || i) {
                      const e = sd(r.requestBody); t.body = r.serializer.serialize(s, t.body, e, u); const a = g === gt.Stream; if (r.isXML) {
                        const e = p ? `xmlns:${p}` : 'xmlns',
                          r = (function (e, t, a, r, s) { if (e && !['Composite', 'Sequence', 'Dictionary'].includes(a)) { const a = {}; return a[s.xmlCharKey] = r, a[d] = { [t]: e }, a; } return r; }(c, e, g, t.body, u)); g === gt.Sequence ? t.body = Tm((function (e, t, a, r) { if (Array.isArray(e) || (e = [e]), !a || !r) return { [t]: e }; const s = { [t]: e }; return s[d] = { [a]: r }, s; }(r, o || n || m, e, c)), { rootName: n || m, xmlCharKey: y }) : a || (t.body = Tm(r, { rootName: n || m, xmlCharKey: y }));
                      } else { if (g === gt.String && (((l = r.contentType) === null || void 0 === l ? void 0 : l.match('text/plain')) || r.mediaType === 'text')) return; a || (t.body = JSON.stringify(t.body)); }
                    }
                  } catch (e) { throw new Error(`Error "${e.message}" occurred in serializing the payload - ${JSON.stringify(m, void 0, '  ')}.`); }
                } else if (r.formDataParameters && r.formDataParameters.length > 0) { t.formData = {}; for (const s of r.formDataParameters) { const i = Cd(e, a, s, r.serializer); if (i != null) { const e = s.mapper.serializedName || sd(s); t.formData[e] = r.serializer.serialize(s.mapper, i, sd(s), u); } } }
              }(this, i, e, t)), void 0 === i.streamResponseStatusCodes && (i.streamResponseStatusCodes = (function (e) { const t = new Set(); for (const a in e.responses) { const r = e.responses[a]; r.bodyMapper && r.bodyMapper.type.name === gt.Stream && t.add(Number(a)); } return t; }(t))); try { l = await this.sendRequest(i); } catch (e) { p = e; }p ? (p.response && (p.details = zd(p.response, t.responses[p.statusCode] || t.responses.default)), n = Promise.reject(p)) : n = Promise.resolve(zd(l, t.responses[l.status]));
            } catch (e) { n = Promise.reject(e); } const o = a; return o && n.then((e=>o(null, e._response.parsedBody, e._response.request, e._response))).catch((e=>o(e))), n;
          }
        } {constructor(e, t) { if (void 0 === e) throw new Error("'url' cannot be null"); if (t || (t = {}), !t.userAgent) { const e = md(); t.userAgent = `azure-storage-blob/12.8.0 ${e}`; } super(void 0, t), this.requestContentType = 'application/json; charset=utf-8', this.baseUri = t.endpoint || '{url}', this.url = e, this.version = t.version || '2020-10-02'; }} class wd {
          constructor(e, t) {
            this.url = (function (e) {
              const t = q.parse(e); let a = t.getPath(); return a = a || '/', a = encodeURIComponent(a).replace(/%2F/g, '/').replace(/'/g, '%27').replace(/\+/g, '%20')
                .replace(/%25/g, '%'), t.setPath(a), t.toString();
            }(e)), this.accountName = cl(e), this.pipeline = t, this.storageClientContext = new Rd(this.url, t.toServiceClientOptions()), this.isHttps = dl((function (e) { return q.parse(e).getScheme(); }(this.url)) || '', 'https'), this.credential = new l(); for (const e of this.pipeline.factories)S && e instanceof Je || e instanceof l ? this.credential = e : z(e.credential) && (this.credential = e.credential); this.storageClientContext.requestContentType = void 0;
          }
        } var Ed,
          qd = a(590); !(function (e) { e[e.Good = 0] = 'Good', e[e.Error = 1] = 'Error'; }(Ed || (Ed = {}))); class Od {
          constructor(e = 5) { if (this.actives = 0, this.completed = 0, this.offset = 0, this.operations = [], this.state = Ed.Good, e < 1) throw new RangeError('concurrency must be larger than 0'); this.concurrency = e, this.emitter = new qd.EventEmitter(); }
  
          addOperation(e) { this.operations.push((async ()=>{ try { this.actives++, await e(), this.actives--, this.completed++, this.parallelExecute(); } catch (e) { this.emitter.emit('error', e); } })); }
  
          async do() { return this.operations.length === 0 ? Promise.resolve() : (this.parallelExecute(), new Promise(((e, t)=>{ this.emitter.on('finish', e), this.emitter.on('error', (e=>{ this.state = Ed.Error, t(e); })); }))); }
  
          nextOperation() { return this.offset < this.operations.length ? this.operations[this.offset++] : null; }
  
          parallelExecute() { if (this.state !== Ed.Error) if (this.completed >= this.operations.length) this.emitter.emit('finish'); else for (;this.actives < this.concurrency;) { const e = this.nextOperation(); if (!e) return; e(); } }
        } class Bd {} const Md = Vo({ packagePrefix: 'Azure.Storage.Blob', namespace: 'Microsoft.Storage' }); function Td(e) {
          var t,
            a; return { spanOptions: (t = e == null ? void 0 : e.tracingOptions) === null || void 0 === t ? void 0 : t.spanOptions, tracingContext: (a = e == null ? void 0 : e.tracingOptions) === null || void 0 === a ? void 0 : a.tracingContext };
        } class Id {
          constructor() { this.read = !1, this.add = !1, this.create = !1, this.write = !1, this.delete = !1, this.deleteVersion = !1, this.tag = !1, this.move = !1, this.execute = !1, this.setImmutabilityPolicy = !1; }
  
          static parse(e) { const t = new Id(); for (const a of e) switch (a) { case 'r': t.read = !0; break; case 'a': t.add = !0; break; case 'c': t.create = !0; break; case 'w': t.write = !0; break; case 'd': t.delete = !0; break; case 'x': t.deleteVersion = !0; break; case 't': t.tag = !0; break; case 'm': t.move = !0; break; case 'e': t.execute = !0; break; case 'i': t.setImmutabilityPolicy = !0; break; default: throw new RangeError(`Invalid permission: ${a}`); } return t; }
  
          static from(e) { const t = new Id(); return e.read && (t.read = !0), e.add && (t.add = !0), e.create && (t.create = !0), e.write && (t.write = !0), e.delete && (t.delete = !0), e.deleteVersion && (t.deleteVersion = !0), e.tag && (t.tag = !0), e.move && (t.move = !0), e.execute && (t.execute = !0), e.setImmutabilityPolicy && (t.setImmutabilityPolicy = !0), t; }
  
          toString() { const e = []; return this.read && e.push('r'), this.add && e.push('a'), this.create && e.push('c'), this.write && e.push('w'), this.delete && e.push('d'), this.deleteVersion && e.push('x'), this.tag && e.push('t'), this.move && e.push('m'), this.execute && e.push('e'), this.setImmutabilityPolicy && e.push('i'), e.join(''); }
        } class Hd {
          constructor() { this.read = !1, this.add = !1, this.create = !1, this.write = !1, this.delete = !1, this.deleteVersion = !1, this.list = !1, this.tag = !1, this.move = !1, this.execute = !1, this.setImmutabilityPolicy = !1; }
  
          static parse(e) { const t = new Hd(); for (const a of e) switch (a) { case 'r': t.read = !0; break; case 'a': t.add = !0; break; case 'c': t.create = !0; break; case 'w': t.write = !0; break; case 'd': t.delete = !0; break; case 'l': t.list = !0; break; case 't': t.tag = !0; break; case 'x': t.deleteVersion = !0; break; case 'm': t.move = !0; break; case 'e': t.execute = !0; break; case 'i': t.setImmutabilityPolicy = !0; break; default: throw new RangeError(`Invalid permission ${a}`); } return t; }
  
          static from(e) { const t = new Hd(); return e.read && (t.read = !0), e.add && (t.add = !0), e.create && (t.create = !0), e.write && (t.write = !0), e.delete && (t.delete = !0), e.list && (t.list = !0), e.deleteVersion && (t.deleteVersion = !0), e.tag && (t.tag = !0), e.move && (t.move = !0), e.execute && (t.execute = !0), e.setImmutabilityPolicy && (t.setImmutabilityPolicy = !0), t; }
  
          toString() { const e = []; return this.read && e.push('r'), this.add && e.push('a'), this.create && e.push('c'), this.write && e.push('w'), this.delete && e.push('d'), this.deleteVersion && e.push('x'), this.list && e.push('l'), this.tag && e.push('t'), this.move && e.push('m'), this.execute && e.push('e'), this.setImmutabilityPolicy && e.push('i'), e.join(''); }
        } class Ad {} function kd(e) { return e.end ? `${e.start}-${e.end}` : e.start; } var Ld; !(function (e) { e.Https = 'https', e.HttpsAndHttp = 'https,http'; }(Ld || (Ld = {}))); class Dd {
          constructor(e, t, a, r, s, i, n, o, m, l, d, c, p, u, y, g, h, x, N) { this.version = e, this.signature = t, void 0 !== a && typeof a !== 'string' ? (this.permissions = a.permissions, this.services = a.services, this.resourceTypes = a.resourceTypes, this.protocol = a.protocol, this.startsOn = a.startsOn, this.expiresOn = a.expiresOn, this.ipRangeInner = a.ipRange, this.identifier = a.identifier, this.resource = a.resource, this.cacheControl = a.cacheControl, this.contentDisposition = a.contentDisposition, this.contentEncoding = a.contentEncoding, this.contentLanguage = a.contentLanguage, this.contentType = a.contentType, a.userDelegationKey && (this.signedOid = a.userDelegationKey.signedObjectId, this.signedTenantId = a.userDelegationKey.signedTenantId, this.signedStartsOn = a.userDelegationKey.signedStartsOn, this.signedExpiresOn = a.userDelegationKey.signedExpiresOn, this.signedService = a.userDelegationKey.signedService, this.signedVersion = a.userDelegationKey.signedVersion, this.preauthorizedAgentObjectId = a.preauthorizedAgentObjectId, this.correlationId = a.correlationId)) : (this.services = r, this.resourceTypes = s, this.expiresOn = o, this.permissions = a, this.protocol = i, this.startsOn = n, this.ipRangeInner = m, this.identifier = l, this.resource = d, this.cacheControl = c, this.contentDisposition = p, this.contentEncoding = u, this.contentLanguage = y, this.contentType = g, h && (this.signedOid = h.signedObjectId, this.signedTenantId = h.signedTenantId, this.signedStartsOn = h.signedStartsOn, this.signedExpiresOn = h.signedExpiresOn, this.signedService = h.signedService, this.signedVersion = h.signedVersion, this.preauthorizedAgentObjectId = x, this.correlationId = N)); }
  
          get ipRange() { if (this.ipRangeInner) return { end: this.ipRangeInner.end, start: this.ipRangeInner.start }; }
  
          toString() {
            const e = ['sv', 'ss', 'srt', 'spr', 'st', 'se', 'sip', 'si', 'skoid', 'sktid', 'skt', 'ske', 'sks', 'skv', 'sr', 'sp', 'sig', 'rscc', 'rscd', 'rsce', 'rscl', 'rsct', 'saoid', 'scid'],
              t = []; for (const a of e) switch (a) { case 'sv': this.tryAppendQueryParameter(t, a, this.version); break; case 'ss': this.tryAppendQueryParameter(t, a, this.services); break; case 'srt': this.tryAppendQueryParameter(t, a, this.resourceTypes); break; case 'spr': this.tryAppendQueryParameter(t, a, this.protocol); break; case 'st': this.tryAppendQueryParameter(t, a, this.startsOn ? ml(this.startsOn, !1) : void 0); break; case 'se': this.tryAppendQueryParameter(t, a, this.expiresOn ? ml(this.expiresOn, !1) : void 0); break; case 'sip': this.tryAppendQueryParameter(t, a, this.ipRange ? kd(this.ipRange) : void 0); break; case 'si': this.tryAppendQueryParameter(t, a, this.identifier); break; case 'skoid': this.tryAppendQueryParameter(t, a, this.signedOid); break; case 'sktid': this.tryAppendQueryParameter(t, a, this.signedTenantId); break; case 'skt': this.tryAppendQueryParameter(t, a, this.signedStartsOn ? ml(this.signedStartsOn, !1) : void 0); break; case 'ske': this.tryAppendQueryParameter(t, a, this.signedExpiresOn ? ml(this.signedExpiresOn, !1) : void 0); break; case 'sks': this.tryAppendQueryParameter(t, a, this.signedService); break; case 'skv': this.tryAppendQueryParameter(t, a, this.signedVersion); break; case 'sr': this.tryAppendQueryParameter(t, a, this.resource); break; case 'sp': this.tryAppendQueryParameter(t, a, this.permissions); break; case 'sig': this.tryAppendQueryParameter(t, a, this.signature); break; case 'rscc': this.tryAppendQueryParameter(t, a, this.cacheControl); break; case 'rscd': this.tryAppendQueryParameter(t, a, this.contentDisposition); break; case 'rsce': this.tryAppendQueryParameter(t, a, this.contentEncoding); break; case 'rscl': this.tryAppendQueryParameter(t, a, this.contentLanguage); break; case 'rsct': this.tryAppendQueryParameter(t, a, this.contentType); break; case 'saoid': this.tryAppendQueryParameter(t, a, this.preauthorizedAgentObjectId); break; case 'scid': this.tryAppendQueryParameter(t, a, this.correlationId); } return t.join('&');
          }
  
          tryAppendQueryParameter(e, t, a) { a && (t = encodeURIComponent(t), a = encodeURIComponent(a), t.length > 0 && a.length > 0 && e.push(`${t}=${a}`)); }
        } function _d(e, t, a) {
          const r = e.version ? e.version : zo,
            s = t instanceof Je ? t : void 0; let i; if (void 0 === s && void 0 !== a && (i = new Ad(a, t)), void 0 === s && void 0 === i) throw TypeError('Invalid sharedKeyCredential, userDelegationKey or accountName.'); if (r >= '2018-11-09') {
            return void 0 !== s ? (function (e, t) {
              if (!((e = Ud(e)).identifier || e.permissions && e.expiresOn)) throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided."); let a,
                r = 'c',
                s = e.snapshotTime; e.blobName && (r = 'b', e.snapshotTime ? r = 'bs' : e.versionId && (r = 'bv', s = e.versionId)), e.permissions && (a = e.blobName ? Id.parse(e.permissions.toString()).toString() : Hd.parse(e.permissions.toString()).toString()); const i = [a || '', e.startsOn ? ml(e.startsOn, !1) : '', e.expiresOn ? ml(e.expiresOn, !1) : '', jd(t.accountName, e.containerName, e.blobName), e.identifier, e.ipRange ? kd(e.ipRange) : '', e.protocol ? e.protocol : '', e.version, r, s, e.cacheControl ? e.cacheControl : '', e.contentDisposition ? e.contentDisposition : '', e.contentEncoding ? e.contentEncoding : '', e.contentLanguage ? e.contentLanguage : '', e.contentType ? e.contentType : ''].join('\n'),
                n = t.computeHMACSHA256(i); return new Dd(e.version, n, a, void 0, void 0, e.protocol, e.startsOn, e.expiresOn, e.ipRange, e.identifier, r, e.cacheControl, e.contentDisposition, e.contentEncoding, e.contentLanguage, e.contentType);
            }(e, s)) : r >= '2020-02-10' ? (function (e, t) {
              if (!(e = Ud(e)).permissions || !e.expiresOn) throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS."); let a,
                r = 'c',
                s = e.snapshotTime; e.blobName && (r = 'b', e.snapshotTime ? r = 'bs' : e.versionId && (r = 'bv', s = e.versionId)), e.permissions && (a = e.blobName ? Id.parse(e.permissions.toString()).toString() : Hd.parse(e.permissions.toString()).toString()); const i = [a || '', e.startsOn ? ml(e.startsOn, !1) : '', e.expiresOn ? ml(e.expiresOn, !1) : '', jd(t.accountName, e.containerName, e.blobName), t.userDelegationKey.signedObjectId, t.userDelegationKey.signedTenantId, t.userDelegationKey.signedStartsOn ? ml(t.userDelegationKey.signedStartsOn, !1) : '', t.userDelegationKey.signedExpiresOn ? ml(t.userDelegationKey.signedExpiresOn, !1) : '', t.userDelegationKey.signedService, t.userDelegationKey.signedVersion, e.preauthorizedAgentObjectId, void 0, e.correlationId, e.ipRange ? kd(e.ipRange) : '', e.protocol ? e.protocol : '', e.version, r, s, e.cacheControl, e.contentDisposition, e.contentEncoding, e.contentLanguage, e.contentType].join('\n'),
                n = t.computeHMACSHA256(i); return new Dd(e.version, n, a, void 0, void 0, e.protocol, e.startsOn, e.expiresOn, e.ipRange, e.identifier, r, e.cacheControl, e.contentDisposition, e.contentEncoding, e.contentLanguage, e.contentType, t.userDelegationKey, e.preauthorizedAgentObjectId, e.correlationId);
            }(e, i)) : (function (e, t) {
              if (!(e = Ud(e)).permissions || !e.expiresOn) throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS."); let a,
                r = 'c',
                s = e.snapshotTime; e.blobName && (r = 'b', e.snapshotTime ? r = 'bs' : e.versionId && (r = 'bv', s = e.versionId)), e.permissions && (a = e.blobName ? Id.parse(e.permissions.toString()).toString() : Hd.parse(e.permissions.toString()).toString()); const i = [a || '', e.startsOn ? ml(e.startsOn, !1) : '', e.expiresOn ? ml(e.expiresOn, !1) : '', jd(t.accountName, e.containerName, e.blobName), t.userDelegationKey.signedObjectId, t.userDelegationKey.signedTenantId, t.userDelegationKey.signedStartsOn ? ml(t.userDelegationKey.signedStartsOn, !1) : '', t.userDelegationKey.signedExpiresOn ? ml(t.userDelegationKey.signedExpiresOn, !1) : '', t.userDelegationKey.signedService, t.userDelegationKey.signedVersion, e.ipRange ? kd(e.ipRange) : '', e.protocol ? e.protocol : '', e.version, r, s, e.cacheControl, e.contentDisposition, e.contentEncoding, e.contentLanguage, e.contentType].join('\n'),
                n = t.computeHMACSHA256(i); return new Dd(e.version, n, a, void 0, void 0, e.protocol, e.startsOn, e.expiresOn, e.ipRange, e.identifier, r, e.cacheControl, e.contentDisposition, e.contentEncoding, e.contentLanguage, e.contentType, t.userDelegationKey);
            }(e, i));
          } if (r >= '2015-04-05') {
            if (void 0 !== s) {
              return (function (e, t) {
                if (!((e = Ud(e)).identifier || e.permissions && e.expiresOn)) throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided."); let a,
                  r = 'c'; e.blobName && (r = 'b'), e.permissions && (a = e.blobName ? Id.parse(e.permissions.toString()).toString() : Hd.parse(e.permissions.toString()).toString()); const s = [a || '', e.startsOn ? ml(e.startsOn, !1) : '', e.expiresOn ? ml(e.expiresOn, !1) : '', jd(t.accountName, e.containerName, e.blobName), e.identifier, e.ipRange ? kd(e.ipRange) : '', e.protocol ? e.protocol : '', e.version, e.cacheControl ? e.cacheControl : '', e.contentDisposition ? e.contentDisposition : '', e.contentEncoding ? e.contentEncoding : '', e.contentLanguage ? e.contentLanguage : '', e.contentType ? e.contentType : ''].join('\n'),
                  i = t.computeHMACSHA256(s); return new Dd(e.version, i, a, void 0, void 0, e.protocol, e.startsOn, e.expiresOn, e.ipRange, e.identifier, r, e.cacheControl, e.contentDisposition, e.contentEncoding, e.contentLanguage, e.contentType);
              }(e, s));
            } throw new RangeError("'version' must be >= '2018-11-09' when generating user delegation SAS using user delegation key.");
          } throw new RangeError("'version' must be >= '2015-04-05'.");
        } function jd(e, t, a) { const r = [`/blob/${e}/${t}`]; return a && r.push(`/${a}`), r.join(''); } function Ud(e) { const t = e.version ? e.version : zo; if (e.snapshotTime && t < '2018-11-09') throw RangeError("'version' must be >= '2018-11-09' when providing 'snapshotTime'."); if (void 0 === e.blobName && e.snapshotTime) throw RangeError("Must provide 'blobName' when providing 'snapshotTime'."); if (e.versionId && t < '2019-10-10') throw RangeError("'version' must be >= '2019-10-10' when providing 'versionId'."); if (void 0 === e.blobName && e.versionId) throw RangeError("Must provide 'blobName' when providing 'versionId'."); if (e.permissions && e.permissions.setImmutabilityPolicy && t < '2020-08-04') throw RangeError("'version' must be >= '2020-08-04' when provided 'i' permission."); if (e.permissions && e.permissions.deleteVersion && t < '2019-10-10') throw RangeError("'version' must be >= '2019-10-10' when providing 'x' permission."); if (e.permissions && e.permissions.tag && t < '2019-12-12') throw RangeError("'version' must be >= '2019-12-12' when providing 't' permission."); if (t < '2020-02-10' && e.permissions && (e.permissions.move || e.permissions.execute)) throw RangeError("'version' must be >= '2020-02-10' when providing the 'm' or 'e' permission."); if (t < '2020-02-10' && (e.preauthorizedAgentObjectId || e.correlationId)) throw RangeError("'version' must be >= '2020-02-10' when providing 'preauthorizedAgentObjectId' or 'correlationId'."); return e.version = t, e; } class Vd {
          constructor(e) { this.client = e; }
  
          create(e) { const t = { options: rt(e || {}) }; return this.client.sendOperationRequest(t, $d); }
  
          getProperties(e) { const t = { options: rt(e || {}) }; return this.client.sendOperationRequest(t, Kd); }
  
          delete(e) { const t = { options: rt(e || {}) }; return this.client.sendOperationRequest(t, Gd); }
  
          setMetadata(e) { const t = { options: rt(e || {}) }; return this.client.sendOperationRequest(t, Qd); }
  
          getAccessPolicy(e) { const t = { options: rt(e || {}) }; return this.client.sendOperationRequest(t, Xd); }
  
          setAccessPolicy(e) { const t = { options: rt(e || {}) }; return this.client.sendOperationRequest(t, Wd); }
  
          restore(e) { const t = { options: rt(e || {}) }; return this.client.sendOperationRequest(t, Jd); }
  
          rename(e, t) { const a = { sourceContainerName: e, options: rt(t || {}) }; return this.client.sendOperationRequest(a, Zd); }
  
          submitBatch(e, t, a, r) {
            const s = {
              contentLength: e, multipartContentType: t, body: a, options: rt(r || {})
            }; return this.client.sendOperationRequest(s, Yd);
          }
  
          acquireLease(e) { const t = { options: rt(e || {}) }; return this.client.sendOperationRequest(t, ec); }
  
          releaseLease(e, t) { const a = { leaseId: e, options: rt(t || {}) }; return this.client.sendOperationRequest(a, tc); }
  
          renewLease(e, t) { const a = { leaseId: e, options: rt(t || {}) }; return this.client.sendOperationRequest(a, ac); }
  
          breakLease(e) { const t = { options: rt(e || {}) }; return this.client.sendOperationRequest(t, rc); }
  
          changeLease(e, t, a) { const r = { leaseId: e, proposedLeaseId: t, options: rt(a || {}) }; return this.client.sendOperationRequest(r, sc); }
  
          listBlobFlatSegment(e) { const t = { options: rt(e || {}) }; return this.client.sendOperationRequest(t, ic); }
  
          listBlobHierarchySegment(e, t) { const a = { delimiter: e, options: rt(t || {}) }; return this.client.sendOperationRequest(a, nc); }
  
          getAccountInfo(e) { const t = { options: rt(e || {}) }; return this.client.sendOperationRequest(t, oc); }
        } const Fd = new nt(t, !0),
          $d = {
            path: '/{containerName}', httpMethod: 'PUT', responses: { 201: { headersMapper: Na }, default: { bodyMapper: Ct, headersMapper: ba } }, queryParameters: [ks, Zs], urlParameters: [Is], headerParameters: [Ls, Ds, _s, Ys, ei, { parameterPath: ['options', 'containerEncryptionScope', 'defaultEncryptionScope'], mapper: { serializedName: 'x-ms-default-encryption-scope', xmlName: 'x-ms-default-encryption-scope', type: { name: 'String' } } }, { parameterPath: ['options', 'containerEncryptionScope', 'preventEncryptionScopeOverride'], mapper: { serializedName: 'x-ms-deny-encryption-scope-override', xmlName: 'x-ms-deny-encryption-scope-override', type: { name: 'Boolean' } } }], isXML: !0, serializer: Fd
          },
          Kd = {
            path: '/{containerName}', httpMethod: 'GET', responses: { 200: { headersMapper: fa }, default: { bodyMapper: Ct, headersMapper: Sa } }, queryParameters: [ks, Zs], urlParameters: [Is], headerParameters: [Ls, Ds, _s, ti], isXML: !0, serializer: Fd
          },
          Gd = {
            path: '/{containerName}', httpMethod: 'DELETE', responses: { 202: { headersMapper: Ca }, default: { bodyMapper: Ct, headersMapper: va } }, queryParameters: [ks, Zs], urlParameters: [Is], headerParameters: [Ls, Ds, _s, ti, ai, ri], isXML: !0, serializer: Fd
          },
          Qd = {
            path: '/{containerName}', httpMethod: 'PUT', responses: { 200: { headersMapper: Pa }, default: { bodyMapper: Ct, headersMapper: za } }, queryParameters: [ks, Zs, si], urlParameters: [Is], headerParameters: [Ls, Ds, _s, Ys, ti, ai], isXML: !0, serializer: Fd
          },
          Xd = {
            path: '/{containerName}',
            httpMethod: 'GET',
            responses: {
              200: {
                bodyMapper: {
                  type: { name: 'Sequence', element: { type: { name: 'Composite', className: 'SignedIdentifier' } } }, serializedName: 'SignedIdentifiers', xmlName: 'SignedIdentifiers', xmlIsWrapped: !0, xmlElementName: 'SignedIdentifier'
                },
                headersMapper: Ra
              },
              default: { bodyMapper: Ct, headersMapper: wa }
            },
            queryParameters: [ks, Zs, ii],
            urlParameters: [Is],
            headerParameters: [Ls, Ds, _s, ti],
            isXML: !0,
            serializer: Fd
          },
          Wd = {
            path: '/{containerName}',
            httpMethod: 'PUT',
            responses: { 200: { headersMapper: Ea }, default: { bodyMapper: Ct, headersMapper: qa } },
            requestBody: {
              parameterPath: ['options', 'containerAcl'],
              mapper: {
                serializedName: 'containerAcl', xmlName: 'SignedIdentifiers', xmlIsWrapped: !0, xmlElementName: 'SignedIdentifier', type: { name: 'Sequence', element: { type: { name: 'Composite', className: 'SignedIdentifier' } } }
              }
            },
            queryParameters: [ks, Zs, ii],
            urlParameters: [Is],
            headerParameters: [Bs, Ts, Ls, Ds, ei, ti, ai, ri],
            isXML: !0,
            contentType: 'application/xml; charset=utf-8',
            mediaType: 'xml',
            serializer: Fd
          },
          Jd = {
            path: '/{containerName}', httpMethod: 'PUT', responses: { 201: { headersMapper: Oa }, default: { bodyMapper: Ct, headersMapper: Ba } }, queryParameters: [ks, Zs, ni], urlParameters: [Is], headerParameters: [Ls, Ds, _s, { parameterPath: ['options', 'deletedContainerName'], mapper: { serializedName: 'x-ms-deleted-container-name', xmlName: 'x-ms-deleted-container-name', type: { name: 'String' } } }, { parameterPath: ['options', 'deletedContainerVersion'], mapper: { serializedName: 'x-ms-deleted-container-version', xmlName: 'x-ms-deleted-container-version', type: { name: 'String' } } }], isXML: !0, serializer: Fd
          },
          Zd = {
            path: '/{containerName}',
            httpMethod: 'PUT',
            responses: { 200: { headersMapper: Ma }, default: { bodyMapper: Ct, headersMapper: Ta } },
            queryParameters: [ks, Zs, {
              parameterPath: 'comp',
              mapper: {
                defaultValue: 'rename', isConstant: !0, serializedName: 'comp', type: { name: 'String' }
              }
            }],
            urlParameters: [Is],
            headerParameters: [Ls, Ds, _s, {
              parameterPath: 'sourceContainerName',
              mapper: {
                serializedName: 'x-ms-source-container-name', required: !0, xmlName: 'x-ms-source-container-name', type: { name: 'String' }
              }
            }, { parameterPath: ['options', 'sourceLeaseId'], mapper: { serializedName: 'x-ms-source-lease-id', xmlName: 'x-ms-source-lease-id', type: { name: 'String' } } }],
            isXML: !0,
            serializer: Fd
          },
          Yd = {
            path: '/{containerName}', httpMethod: 'POST', responses: { 202: { bodyMapper: { type: { name: 'Stream' }, serializedName: 'parsedResponse' }, headersMapper: Ia }, default: { bodyMapper: Ct, headersMapper: Ha } }, requestBody: Qs, queryParameters: [ks, Xs, Zs], urlParameters: [Is], headerParameters: [Bs, Ts, Ls, Ds, Ws, Js], isXML: !0, contentType: 'application/xml; charset=utf-8', mediaType: 'xml', serializer: Fd
          },
          ec = {
            path: '/{containerName}', httpMethod: 'PUT', responses: { 201: { headersMapper: Aa }, default: { bodyMapper: Ct, headersMapper: ka } }, queryParameters: [ks, Zs, oi], urlParameters: [Is], headerParameters: [Ls, Ds, _s, ai, ri, mi, li, di], isXML: !0, serializer: Fd
          },
          tc = {
            path: '/{containerName}', httpMethod: 'PUT', responses: { 200: { headersMapper: La }, default: { bodyMapper: Ct, headersMapper: Da } }, queryParameters: [ks, Zs, oi], urlParameters: [Is], headerParameters: [Ls, Ds, _s, ai, ri, ci, pi], isXML: !0, serializer: Fd
          },
          ac = {
            path: '/{containerName}', httpMethod: 'PUT', responses: { 200: { headersMapper: _a }, default: { bodyMapper: Ct, headersMapper: ja } }, queryParameters: [ks, Zs, oi], urlParameters: [Is], headerParameters: [Ls, Ds, _s, ai, ri, pi, ui], isXML: !0, serializer: Fd
          },
          rc = {
            path: '/{containerName}', httpMethod: 'PUT', responses: { 202: { headersMapper: Ua }, default: { bodyMapper: Ct, headersMapper: Va } }, queryParameters: [ks, Zs, oi], urlParameters: [Is], headerParameters: [Ls, Ds, _s, ai, ri, yi, gi], isXML: !0, serializer: Fd
          },
          sc = {
            path: '/{containerName}', httpMethod: 'PUT', responses: { 200: { headersMapper: Fa }, default: { bodyMapper: Ct, headersMapper: $a } }, queryParameters: [ks, Zs, oi], urlParameters: [Is], headerParameters: [Ls, Ds, _s, ai, ri, pi, hi, xi], isXML: !0, serializer: Fd
          },
          ic = {
            path: '/{containerName}', httpMethod: 'GET', responses: { 200: { bodyMapper: At, headersMapper: Ka }, default: { bodyMapper: Ct, headersMapper: Ga } }, queryParameters: [ks, js, Us, Vs, Fs, Zs, Ni], urlParameters: [Is], headerParameters: [Ls, Ds, _s], isXML: !0, serializer: Fd
          },
          nc = {
            path: '/{containerName}',
            httpMethod: 'GET',
            responses: { 200: { bodyMapper: _t, headersMapper: Qa }, default: { bodyMapper: Ct, headersMapper: Xa } },
            queryParameters: [ks, js, Us, Vs, Fs, Zs, Ni, {
              parameterPath: 'delimiter',
              mapper: {
                serializedName: 'delimiter', required: !0, xmlName: 'delimiter', type: { name: 'String' }
              }
            }],
            urlParameters: [Is],
            headerParameters: [Ls, Ds, _s],
            isXML: !0,
            serializer: Fd
          },
          oc = {
            path: '/{containerName}', httpMethod: 'GET', responses: { 200: { headersMapper: Wa }, default: { bodyMapper: Ct, headersMapper: Ja } }, queryParameters: [As, Gs], urlParameters: [Is], headerParameters: [Ls, _s], isXML: !0, serializer: Fd
          }; class mc {
          constructor(e, t) { const a = new Rd(e.url, e.pipeline.toServiceClientOptions()); this._url = e.url, void 0 === e.name ? (this._isContainer = !0, this._containerOrBlobOperation = new Vd(a)) : (this._isContainer = !1, this._containerOrBlobOperation = new Pn(a)), t || (t = C()), this._leaseId = t; }
  
          get leaseId() { return this._leaseId; }
  
          get url() { return this._url; }
  
          async acquireLease(e, t = {}) {
            var a,
              r,
              s,
              i,
              n,
              o; const { span: m, updatedOptions: l } = Md('BlobLeaseClient-acquireLease', t); if (this._isContainer && (((a = t.conditions) === null || void 0 === a ? void 0 : a.ifMatch) && ((r = t.conditions) === null || void 0 === r ? void 0 : r.ifMatch) !== Ho || ((s = t.conditions) === null || void 0 === s ? void 0 : s.ifNoneMatch) && ((i = t.conditions) === null || void 0 === i ? void 0 : i.ifNoneMatch) !== Ho || ((n = t.conditions) === null || void 0 === n ? void 0 : n.tagConditions))) throw new RangeError('The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.'); try {
              return await this._containerOrBlobOperation.acquireLease(Object.assign({
                abortSignal: t.abortSignal, duration: e, modifiedAccessConditions: Object.assign(Object.assign({}, t.conditions), { ifTags: (o = t.conditions) === null || void 0 === o ? void 0 : o.tagConditions }), proposedLeaseId: this._leaseId
              }, Td(l)));
            } catch (e) { throw m.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { m.end(); }
          }
  
          async changeLease(e, t = {}) {
            var a,
              r,
              s,
              i,
              n,
              o; const { span: m, updatedOptions: l } = Md('BlobLeaseClient-changeLease', t); if (this._isContainer && (((a = t.conditions) === null || void 0 === a ? void 0 : a.ifMatch) && ((r = t.conditions) === null || void 0 === r ? void 0 : r.ifMatch) !== Ho || ((s = t.conditions) === null || void 0 === s ? void 0 : s.ifNoneMatch) && ((i = t.conditions) === null || void 0 === i ? void 0 : i.ifNoneMatch) !== Ho || ((n = t.conditions) === null || void 0 === n ? void 0 : n.tagConditions))) throw new RangeError('The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.'); try { const a = await this._containerOrBlobOperation.changeLease(this._leaseId, e, Object.assign({ abortSignal: t.abortSignal, modifiedAccessConditions: Object.assign(Object.assign({}, t.conditions), { ifTags: (o = t.conditions) === null || void 0 === o ? void 0 : o.tagConditions }) }, Td(l))); return this._leaseId = e, a; } catch (e) { throw m.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { m.end(); }
          }
  
          async releaseLease(e = {}) {
            var t,
              a,
              r,
              s,
              i,
              n; const { span: o, updatedOptions: m } = Md('BlobLeaseClient-releaseLease', e); if (this._isContainer && (((t = e.conditions) === null || void 0 === t ? void 0 : t.ifMatch) && ((a = e.conditions) === null || void 0 === a ? void 0 : a.ifMatch) !== Ho || ((r = e.conditions) === null || void 0 === r ? void 0 : r.ifNoneMatch) && ((s = e.conditions) === null || void 0 === s ? void 0 : s.ifNoneMatch) !== Ho || ((i = e.conditions) === null || void 0 === i ? void 0 : i.tagConditions))) throw new RangeError('The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.'); try { return await this._containerOrBlobOperation.releaseLease(this._leaseId, Object.assign({ abortSignal: e.abortSignal, modifiedAccessConditions: Object.assign(Object.assign({}, e.conditions), { ifTags: (n = e.conditions) === null || void 0 === n ? void 0 : n.tagConditions }) }, Td(m))); } catch (e) { throw o.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { o.end(); }
          }
  
          async renewLease(e = {}) {
            var t,
              a,
              r,
              s,
              i,
              n; const { span: o, updatedOptions: m } = Md('BlobLeaseClient-renewLease', e); if (this._isContainer && (((t = e.conditions) === null || void 0 === t ? void 0 : t.ifMatch) && ((a = e.conditions) === null || void 0 === a ? void 0 : a.ifMatch) !== Ho || ((r = e.conditions) === null || void 0 === r ? void 0 : r.ifNoneMatch) && ((s = e.conditions) === null || void 0 === s ? void 0 : s.ifNoneMatch) !== Ho || ((i = e.conditions) === null || void 0 === i ? void 0 : i.tagConditions))) throw new RangeError('The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.'); try { return await this._containerOrBlobOperation.renewLease(this._leaseId, Object.assign({ abortSignal: e.abortSignal, modifiedAccessConditions: Object.assign(Object.assign({}, e.conditions), { ifTags: (n = e.conditions) === null || void 0 === n ? void 0 : n.tagConditions }) }, Td(m))); } catch (e) { throw o.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { o.end(); }
          }
  
          async breakLease(e, t = {}) {
            var a,
              r,
              s,
              i,
              n,
              o; const { span: m, updatedOptions: l } = Md('BlobLeaseClient-breakLease', t); if (this._isContainer && (((a = t.conditions) === null || void 0 === a ? void 0 : a.ifMatch) && ((r = t.conditions) === null || void 0 === r ? void 0 : r.ifMatch) !== Ho || ((s = t.conditions) === null || void 0 === s ? void 0 : s.ifNoneMatch) && ((i = t.conditions) === null || void 0 === i ? void 0 : i.ifNoneMatch) !== Ho || ((n = t.conditions) === null || void 0 === n ? void 0 : n.tagConditions))) throw new RangeError('The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.'); try { const a = Object.assign({ abortSignal: t.abortSignal, breakPeriod: e, modifiedAccessConditions: Object.assign(Object.assign({}, t.conditions), { ifTags: (o = t.conditions) === null || void 0 === o ? void 0 : o.tagConditions }) }, Td(l)); return await this._containerOrBlobOperation.breakLease(a); } catch (e) { throw m.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { m.end(); }
          }
        } class lc extends wd {
          constructor(e, t, a, r) {
            let s,
              i; if (r = r || {}, Ll(t))i = e, s = t; else if (S && t instanceof Je || t instanceof l || z(t))i = e, s = _l(t, r = a); else if (t || typeof t === 'string') {
              if (!t || typeof t !== 'string' || !a || typeof a !== 'string') throw new Error('Expecting non-empty strings for containerName and blobName parameters'); { const n = t,
                o = a,
                m = tl(e); if (m.kind === 'AccountConnString') { if (!S) throw new Error('Account connection string is only supported in Node.js environment'); { const e = new Je(m.accountName, m.accountKey); i = al(al(m.url, encodeURIComponent(n)), encodeURIComponent(o)), r.proxyOptions = void m.proxyUri, s = _l(e, r); } } else { if (m.kind !== 'SASConnString') throw new Error('Connection string must be either an Account connection string or a SAS connection string'); i = al(al(m.url, encodeURIComponent(n)), encodeURIComponent(o)) + '?' + m.accountSas, s = _l(new l(), r); } }
            } else i = e, s = _l(new l(), r); super(i, s), ({ blobName: this._name, containerName: this._containerName } = this.getBlobAndContainerNamesFromUrl()), this.blobContext = new Pn(this.storageClientContext), this._snapshot = sl(this.url, Oo), this._versionId = sl(this.url, Bo);
          }
  
          get name() { return this._name; }
  
          get containerName() { return this._containerName; }
  
          withSnapshot(e) { return new lc(rl(this.url, Oo, e.length === 0 ? void 0 : e), this.pipeline); }
  
          withVersion(e) { return new lc(rl(this.url, Bo, e.length === 0 ? void 0 : e), this.pipeline); }
  
          getAppendBlobClient() { return new dc(this.url, this.pipeline); }
  
          getBlockBlobClient() { return new cc(this.url, this.pipeline); }
  
          getPageBlobClient() { return new pc(this.url, this.pipeline); }
  
          async download(e = 0, t, a = {}) {
            var r; a.conditions = a.conditions || {}, a.conditions = a.conditions || {}, jo(a.customerProvidedKey, this.isHttps); const { span: s, updatedOptions: i } = Md('BlobClient-download', a); try {
              const n = await this.blobContext.download(Object.assign({
                  abortSignal: a.abortSignal, leaseAccessConditions: a.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, a.conditions), { ifTags: (r = a.conditions) === null || void 0 === r ? void 0 : r.tagConditions }), requestOptions: { onDownloadProgress: S ? void 0 : a.onProgress }, range: e !== 0 || t ? Ql({ offset: e, count: t }) : void 0, rangeGetContentMD5: a.rangeGetContentMD5, rangeGetContentCRC64: a.rangeGetContentCrc64, snapshot: a.snapshot, cpkInfo: a.customerProvidedKey
                }, Td(i))),
                o = Object.assign(Object.assign({}, n), { _response: n._response, objectReplicationDestinationPolicyId: n.objectReplicationPolicyId, objectReplicationSourceProperties: xl(n.objectReplicationRules) }); if (!S) return o; if ((void 0 === a.maxRetryRequests || a.maxRetryRequests < 0) && (a.maxRetryRequests = 5), void 0 === n.contentLength) throw new RangeError("File download response doesn't contain valid content length header"); if (!n.etag) throw new RangeError("File download response doesn't contain valid etag header"); return new 1(o, (async t=>{
                var r; const s = {
                  leaseAccessConditions: a.conditions,
                  modifiedAccessConditions: {
                    ifMatch: a.conditions.ifMatch || n.etag, ifModifiedSince: a.conditions.ifModifiedSince, ifNoneMatch: a.conditions.ifNoneMatch, ifUnmodifiedSince: a.conditions.ifUnmodifiedSince, ifTags: (r = a.conditions) === null || void 0 === r ? void 0 : r.tagConditions
                  },
                  range: Ql({ count: e + n.contentLength - t, offset: t }),
                  rangeGetContentMD5: a.rangeGetContentMD5,
                  rangeGetContentCRC64: a.rangeGetContentCrc64,
                  snapshot: a.snapshot,
                  cpkInfo: a.customerProvidedKey
                }; return (await this.blobContext.download(Object.assign({ abortSignal: a.abortSignal }, s))).readableStreamBody;
              }), e, n.contentLength, { maxRetryRequests: a.maxRetryRequests, onProgress: a.onProgress });
            } catch (e) { throw s.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { s.end(); }
          }
  
          async exists(e = {}) {
            const { span: t, updatedOptions: a } = Md('BlobClient-exists', e); try {
              return jo(e.customerProvidedKey, this.isHttps), await this.getProperties({
                abortSignal: e.abortSignal, customerProvidedKey: e.customerProvidedKey, conditions: e.conditions, tracingOptions: a.tracingOptions
              }), !0;
            } catch (e) { if (e.statusCode === 404) return t.setStatus({ code: Xe.ERROR, message: 'Expected exception when checking blob existence' }), !1; throw t.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { t.end(); }
          }
  
          async getProperties(e = {}) {
            var t; const { span: a, updatedOptions: r } = Md('BlobClient-getProperties', e); try {
              e.conditions = e.conditions || {}, jo(e.customerProvidedKey, this.isHttps); const s = await this.blobContext.getProperties(Object.assign({
                abortSignal: e.abortSignal, leaseAccessConditions: e.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, e.conditions), { ifTags: (t = e.conditions) === null || void 0 === t ? void 0 : t.tagConditions }), cpkInfo: e.customerProvidedKey
              }, Td(r))); return Object.assign(Object.assign({}, s), { _response: s._response, objectReplicationDestinationPolicyId: s.objectReplicationPolicyId, objectReplicationSourceProperties: xl(s.objectReplicationRules) });
            } catch (e) { throw a.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { a.end(); }
          }
  
          async delete(e = {}) {
            var t; const { span: a, updatedOptions: r } = Md('BlobClient-delete', e); e.conditions = e.conditions || {}; try {
              return await this.blobContext.delete(Object.assign({
                abortSignal: e.abortSignal, deleteSnapshots: e.deleteSnapshots, leaseAccessConditions: e.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, e.conditions), { ifTags: (t = e.conditions) === null || void 0 === t ? void 0 : t.tagConditions })
              }, Td(r)));
            } catch (e) { throw a.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { a.end(); }
          }
  
          async deleteIfExists(e = {}) {
            var t,
              a; const { span: r, updatedOptions: s } = Md('BlobClient-deleteIfExists', e); try { const e = await this.delete(s); return Object.assign(Object.assign({ succeeded: !0 }, e), { _response: e._response }); } catch (e) { if (((t = e.details) === null || void 0 === t ? void 0 : t.errorCode) === 'BlobNotFound') return r.setStatus({ code: Xe.ERROR, message: 'Expected exception when deleting a blob or snapshot only if it exists.' }), Object.assign(Object.assign({ succeeded: !1 }, (a = e.response) === null || void 0 === a ? void 0 : a.parsedHeaders), { _response: e.response }); throw r.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { r.end(); }
          }
  
          async undelete(e = {}) { const { span: t, updatedOptions: a } = Md('BlobClient-undelete', e); try { return await this.blobContext.undelete(Object.assign({ abortSignal: e.abortSignal }, Td(a))); } catch (e) { throw t.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { t.end(); } }
  
          async setHTTPHeaders(e, t = {}) {
            var a; const { span: r, updatedOptions: s } = Md('BlobClient-setHTTPHeaders', t); t.conditions = t.conditions || {}; try {
              return jo(t.customerProvidedKey, this.isHttps), await this.blobContext.setHttpHeaders(Object.assign({
                abortSignal: t.abortSignal, blobHttpHeaders: e, leaseAccessConditions: t.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, t.conditions), { ifTags: (a = t.conditions) === null || void 0 === a ? void 0 : a.tagConditions })
              }, Td(s)));
            } catch (e) { throw r.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { r.end(); }
          }
  
          async setMetadata(e, t = {}) {
            var a; const { span: r, updatedOptions: s } = Md('BlobClient-setMetadata', t); t.conditions = t.conditions || {}; try {
              return jo(t.customerProvidedKey, this.isHttps), await this.blobContext.setMetadata(Object.assign({
                abortSignal: t.abortSignal, leaseAccessConditions: t.conditions, metadata: e, modifiedAccessConditions: Object.assign(Object.assign({}, t.conditions), { ifTags: (a = t.conditions) === null || void 0 === a ? void 0 : a.tagConditions }), cpkInfo: t.customerProvidedKey, encryptionScope: t.encryptionScope
              }, Td(s)));
            } catch (e) { throw r.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { r.end(); }
          }
  
          async setTags(e, t = {}) { var a; const { span: r, updatedOptions: s } = Md('BlobClient-setTags', t); try { return await this.blobContext.setTags(Object.assign(Object.assign({ abortSignal: t.abortSignal, leaseAccessConditions: t.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, t.conditions), { ifTags: (a = t.conditions) === null || void 0 === a ? void 0 : a.tagConditions }) }, Td(s)), { tags: yl(e) })); } catch (e) { throw r.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { r.end(); } }
  
          async getTags(e = {}) { var t; const { span: a, updatedOptions: r } = Md('BlobClient-getTags', e); try { const s = await this.blobContext.getTags(Object.assign({ abortSignal: e.abortSignal, leaseAccessConditions: e.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, e.conditions), { ifTags: (t = e.conditions) === null || void 0 === t ? void 0 : t.tagConditions }) }, Td(r))); return Object.assign(Object.assign({}, s), { _response: s._response, tags: gl({ blobTagSet: s.blobTagSet }) || {} }); } catch (e) { throw a.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { a.end(); } }
  
          getBlobLeaseClient(e) { return new mc(this, e); }
  
          async createSnapshot(e = {}) {
            var t; const { span: a, updatedOptions: r } = Md('BlobClient-createSnapshot', e); e.conditions = e.conditions || {}; try {
              return jo(e.customerProvidedKey, this.isHttps), await this.blobContext.createSnapshot(Object.assign({
                abortSignal: e.abortSignal, leaseAccessConditions: e.conditions, metadata: e.metadata, modifiedAccessConditions: Object.assign(Object.assign({}, e.conditions), { ifTags: (t = e.conditions) === null || void 0 === t ? void 0 : t.tagConditions }), cpkInfo: e.customerProvidedKey, encryptionScope: e.encryptionScope
              }, Td(r)));
            } catch (e) { throw a.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { a.end(); }
          }
  
          async beginCopyFromURL(e, t = {}) {
            const a = new Vl({
              blobClient: { abortCopyFromURL: (...e)=>this.abortCopyFromURL(...e), getProperties: (...e)=>this.getProperties(...e), startCopyFromURL: (...e)=>this.startCopyFromURL(...e) }, copySource: e, intervalInMs: t.intervalInMs, onProgress: t.onProgress, resumeFrom: t.resumeFrom, startCopyFromURLOptions: t
            }); return await a.poll(), a;
          }
  
          async abortCopyFromURL(e, t = {}) { const { span: a, updatedOptions: r } = Md('BlobClient-abortCopyFromURL', t); try { return await this.blobContext.abortCopyFromURL(e, Object.assign({ abortSignal: t.abortSignal, leaseAccessConditions: t.conditions }, Td(r))); } catch (e) { throw a.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { a.end(); } }
  
          async syncCopyFromURL(e, t = {}) {
            var a,
              r,
              s; const { span: i, updatedOptions: n } = Md('BlobClient-syncCopyFromURL', t); t.conditions = t.conditions || {}, t.sourceConditions = t.sourceConditions || {}; try {
              return await this.blobContext.copyFromURL(e, Object.assign({
                abortSignal: t.abortSignal,
                metadata: t.metadata,
                leaseAccessConditions: t.conditions,
                modifiedAccessConditions: Object.assign(Object.assign({}, t.conditions), { ifTags: (a = t.conditions) === null || void 0 === a ? void 0 : a.tagConditions }),
                sourceModifiedAccessConditions: {
                  sourceIfMatch: t.sourceConditions.ifMatch, sourceIfModifiedSince: t.sourceConditions.ifModifiedSince, sourceIfNoneMatch: t.sourceConditions.ifNoneMatch, sourceIfUnmodifiedSince: t.sourceConditions.ifUnmodifiedSince
                },
                sourceContentMD5: t.sourceContentMD5,
                copySourceAuthorization: bl(t.sourceAuthorization),
                blobTagsString: ul(t.tags),
                immutabilityPolicyExpiry: (r = t.immutabilityPolicy) === null || void 0 === r ? void 0 : r.expiriesOn,
                immutabilityPolicyMode: (s = t.immutabilityPolicy) === null || void 0 === s ? void 0 : s.policyMode,
                legalHold: t.legalHold
              }, Td(n)));
            } catch (e) { throw i.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { i.end(); }
          }
  
          async setAccessTier(e, t = {}) {
            var a; const { span: r, updatedOptions: s } = Md('BlobClient-setAccessTier', t); try {
              return await this.blobContext.setTier(_o(e), Object.assign({
                abortSignal: t.abortSignal, leaseAccessConditions: t.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, t.conditions), { ifTags: (a = t.conditions) === null || void 0 === a ? void 0 : a.tagConditions }), rehydratePriority: t.rehydratePriority
              }, Td(s)));
            } catch (e) { throw r.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { r.end(); }
          }
  
          async downloadToBuffer(e, t, a, r = {}) {
            let s,
              i = 0,
              n = 0,
              o = r; e instanceof Buffer ? (s = e, i = t || 0, n = typeof a === 'number' ? a : 0) : (i = typeof e === 'number' ? e : 0, n = typeof t === 'number' ? t : 0, o = a || {}); const { span: m, updatedOptions: l } = Md('BlobClient-downloadToBuffer', o); try {
              if (o.blockSize || (o.blockSize = 0), o.blockSize < 0) throw new RangeError('blockSize option must be >= 0'); if (o.blockSize === 0 && (o.blockSize = wo), i < 0) throw new RangeError('offset option must be >= 0'); if (n && n <= 0) throw new RangeError('count option must be greater than 0'); if (o.conditions || (o.conditions = {}), !n) { const e = await this.getProperties(Object.assign(Object.assign({}, o), { tracingOptions: Object.assign(Object.assign({}, o.tracingOptions), Td(l)) })); if (n = e.contentLength - i, n < 0) throw new RangeError(`offset ${i} shouldn't be larger than blob size ${e.contentLength}`); } if (!s) try { s = Buffer.alloc(n); } catch (e) { throw new Error(`Unable to allocate the buffer of size: ${n}(in bytes). Please try passing your own buffer to the "downloadToBuffer" method or try using other methods like "download" or "downloadToFile".\t ${e.message}`); } if (s.length < n) throw new RangeError(`The buffer's size should be equal to or larger than the request count of bytes: ${n}`); let e = 0; const t = new Od(o.concurrency); for (let a = i; a < i + n; a += o.blockSize) {
                t.addOperation((async ()=>{
                  let t = i + n; a + o.blockSize < t && (t = a + o.blockSize), (await this.download(a, t - a, {
                    abortSignal: o.abortSignal, conditions: o.conditions, maxRetryRequests: o.maxRetryRequestsPerBlock, customerProvidedKey: o.customerProvidedKey, tracingOptions: Object.assign(Object.assign({}, o.tracingOptions), Td(l))
                  })).readableStreamBody, await void 0, e += t - a, o.onProgress && o.onProgress({ loadedBytes: e });
                }));
              } return await t.do(), s;
            } catch (e) { throw m.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { m.end(); }
          }
  
          async downloadToFile(e, t = 0, a, r = {}) { const { span: s, updatedOptions: i } = Md('BlobClient-downloadToFile', r); try { const e = await this.download(t, a, Object.assign(Object.assign({}, r), { tracingOptions: Object.assign(Object.assign({}, r.tracingOptions), Td(i)) })); return e.readableStreamBody && await void e.readableStreamBody, e.blobDownloadStream = void 0, e; } catch (e) { throw s.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { s.end(); } }
  
          getBlobAndContainerNamesFromUrl() {
            let e,
              t; try { const a = q.parse(this.url); if (a.getHost().split('.')[1] === 'blob') { const r = a.getPath().match('/([^/]*)(/(.*))?'); e = r[1], t = r[3]; } else if (pl(a)) { const r = a.getPath().match('/([^/]*)/([^/]*)(/(.*))?'); e = r[2], t = r[4]; } else { const r = a.getPath().match('/([^/]*)(/(.*))?'); e = r[1], t = r[3]; } if (e = decodeURIComponent(e), t = decodeURIComponent(t), t = t.replace(/\\/g, '/'), !e) throw new Error('Provided containerName is invalid.'); return { blobName: t, containerName: e }; } catch (e) { throw new Error('Unable to extract blobName and containerName with provided information.'); }
          }
  
          async startCopyFromURL(e, t = {}) {
            var a,
              r,
              s; const { span: i, updatedOptions: n } = Md('BlobClient-startCopyFromURL', t); t.conditions = t.conditions || {}, t.sourceConditions = t.sourceConditions || {}; try {
              return await this.blobContext.startCopyFromURL(e, Object.assign({
                abortSignal: t.abortSignal,
                leaseAccessConditions: t.conditions,
                metadata: t.metadata,
                modifiedAccessConditions: Object.assign(Object.assign({}, t.conditions), { ifTags: (a = t.conditions) === null || void 0 === a ? void 0 : a.tagConditions }),
                sourceModifiedAccessConditions: {
                  sourceIfMatch: t.sourceConditions.ifMatch, sourceIfModifiedSince: t.sourceConditions.ifModifiedSince, sourceIfNoneMatch: t.sourceConditions.ifNoneMatch, sourceIfUnmodifiedSince: t.sourceConditions.ifUnmodifiedSince, sourceIfTags: t.sourceConditions.tagConditions
                },
                immutabilityPolicyExpiry: (r = t.immutabilityPolicy) === null || void 0 === r ? void 0 : r.expiriesOn,
                immutabilityPolicyMode: (s = t.immutabilityPolicy) === null || void 0 === s ? void 0 : s.policyMode,
                legalHold: t.legalHold,
                rehydratePriority: t.rehydratePriority,
                tier: _o(t.tier),
                blobTagsString: ul(t.tags),
                sealBlob: t.sealBlob
              }, Td(n)));
            } catch (e) { throw i.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { i.end(); }
          }
  
          generateSasUrl(e) {
            return new Promise((t=>{
              if (!(this.credential instanceof Je)) throw new RangeError('Can only generate the SAS when the client is initialized with a shared key credential'); const a = _d(Object.assign({
                containerName: this._containerName, blobName: this._name, snapshotTime: this._snapshot, versionId: this._versionId
              }, e), this.credential).toString(); t(ol(this.url, a));
            }));
          }
  
          async deleteImmutabilityPolicy(e) { const { span: t, updatedOptions: a } = Md('BlobClient-deleteImmutabilityPolicy', e); try { return await this.blobContext.deleteImmutabilityPolicy(Object.assign({ abortSignal: e == null ? void 0 : e.abortSignal }, Td(a))); } catch (e) { throw t.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { t.end(); } }
  
          async setImmutabilityPolicy(e, t) {
            const { span: a, updatedOptions: r } = Md('BlobClient-setImmutabilityPolicy', t); try {
              return await this.blobContext.setImmutabilityPolicy(Object.assign({
                abortSignal: t == null ? void 0 : t.abortSignal, immutabilityPolicyExpiry: e.expiriesOn, immutabilityPolicyMode: e.policyMode, modifiedAccessConditions: t == null ? void 0 : t.modifiedAccessCondition
              }, Td(r)));
            } catch (e) { throw a.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { a.end(); }
          }
  
          async setLegalHold(e, t) { const { span: a, updatedOptions: r } = Md('BlobClient-setLegalHold', t); try { return await this.blobContext.setLegalHold(e, Object.assign({ abortSignal: t == null ? void 0 : t.abortSignal }, Td(r))); } catch (e) { throw a.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { a.end(); } }
        } class dc extends lc {
          constructor(e, t, a, r) {
            let s,
              i; if (r = r || {}, Ll(t))i = e, s = t; else if (S && t instanceof Je || t instanceof l || z(t))i = e, s = _l(t, r = a); else if (t || typeof t === 'string') {
              if (!t || typeof t !== 'string' || !a || typeof a !== 'string') throw new Error('Expecting non-empty strings for containerName and blobName parameters'); { const n = t,
                o = a,
                m = tl(e); if (m.kind === 'AccountConnString') { if (!S) throw new Error('Account connection string is only supported in Node.js environment'); { const e = new Je(m.accountName, m.accountKey); i = al(al(m.url, encodeURIComponent(n)), encodeURIComponent(o)), r.proxyOptions = void m.proxyUri, s = _l(e, r); } } else { if (m.kind !== 'SASConnString') throw new Error('Connection string must be either an Account connection string or a SAS connection string'); i = al(al(m.url, encodeURIComponent(n)), encodeURIComponent(o)) + '?' + m.accountSas, s = _l(new l(), r); } }
            } else i = e, s = _l(new l(), r); super(i, s), this.appendBlobContext = new Wn(this.storageClientContext);
          }
  
          withSnapshot(e) { return new dc(rl(this.url, Oo, e.length === 0 ? void 0 : e), this.pipeline); }
  
          async create(e = {}) {
            var t,
              a,
              r; const { span: s, updatedOptions: i } = Md('AppendBlobClient-create', e); e.conditions = e.conditions || {}; try {
              return jo(e.customerProvidedKey, this.isHttps), await this.appendBlobContext.create(0, Object.assign({
                abortSignal: e.abortSignal, blobHttpHeaders: e.blobHTTPHeaders, leaseAccessConditions: e.conditions, metadata: e.metadata, modifiedAccessConditions: Object.assign(Object.assign({}, e.conditions), { ifTags: (t = e.conditions) === null || void 0 === t ? void 0 : t.tagConditions }), cpkInfo: e.customerProvidedKey, encryptionScope: e.encryptionScope, immutabilityPolicyExpiry: (a = e.immutabilityPolicy) === null || void 0 === a ? void 0 : a.expiriesOn, immutabilityPolicyMode: (r = e.immutabilityPolicy) === null || void 0 === r ? void 0 : r.policyMode, legalHold: e.legalHold, blobTagsString: ul(e.tags)
              }, Td(i)));
            } catch (e) { throw s.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { s.end(); }
          }
  
          async createIfNotExists(e = {}) {
            var t,
              a; const { span: r, updatedOptions: s } = Md('AppendBlobClient-createIfNotExists', e),
              i = { ifNoneMatch: '*' }; try { const e = await this.create(Object.assign(Object.assign({}, s), { conditions: i })); return Object.assign(Object.assign({ succeeded: !0 }, e), { _response: e._response }); } catch (e) { if (((t = e.details) === null || void 0 === t ? void 0 : t.errorCode) === 'BlobAlreadyExists') return r.setStatus({ code: Xe.ERROR, message: 'Expected exception when creating a blob only if it does not already exist.' }), Object.assign(Object.assign({ succeeded: !1 }, (a = e.response) === null || void 0 === a ? void 0 : a.parsedHeaders), { _response: e.response }); throw r.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { r.end(); }
          }
  
          async seal(e = {}) {
            var t; const { span: a, updatedOptions: r } = Md('AppendBlobClient-seal', e); e.conditions = e.conditions || {}; try {
              return await this.appendBlobContext.seal(Object.assign({
                abortSignal: e.abortSignal, appendPositionAccessConditions: e.conditions, leaseAccessConditions: e.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, e.conditions), { ifTags: (t = e.conditions) === null || void 0 === t ? void 0 : t.tagConditions })
              }, Td(r)));
            } catch (e) { throw a.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { a.end(); }
          }
  
          async appendBlock(e, t, a = {}) {
            var r; const { span: s, updatedOptions: i } = Md('AppendBlobClient-appendBlock', a); a.conditions = a.conditions || {}; try {
              return jo(a.customerProvidedKey, this.isHttps), await this.appendBlobContext.appendBlock(t, e, Object.assign({
                abortSignal: a.abortSignal, appendPositionAccessConditions: a.conditions, leaseAccessConditions: a.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, a.conditions), { ifTags: (r = a.conditions) === null || void 0 === r ? void 0 : r.tagConditions }), requestOptions: { onUploadProgress: a.onProgress }, transactionalContentMD5: a.transactionalContentMD5, transactionalContentCrc64: a.transactionalContentCrc64, cpkInfo: a.customerProvidedKey, encryptionScope: a.encryptionScope
              }, Td(i)));
            } catch (e) { throw s.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { s.end(); }
          }
  
          async appendBlockFromURL(e, t, a, r = {}) {
            var s; const { span: i, updatedOptions: n } = Md('AppendBlobClient-appendBlockFromURL', r); r.conditions = r.conditions || {}, r.sourceConditions = r.sourceConditions || {}; try {
              return jo(r.customerProvidedKey, this.isHttps), await this.appendBlobContext.appendBlockFromUrl(e, 0, Object.assign({
                abortSignal: r.abortSignal,
                sourceRange: Ql({ offset: t, count: a }),
                sourceContentMD5: r.sourceContentMD5,
                sourceContentCrc64: r.sourceContentCrc64,
                leaseAccessConditions: r.conditions,
                appendPositionAccessConditions: r.conditions,
                modifiedAccessConditions: Object.assign(Object.assign({}, r.conditions), { ifTags: (s = r.conditions) === null || void 0 === s ? void 0 : s.tagConditions }),
                sourceModifiedAccessConditions: {
                  sourceIfMatch: r.sourceConditions.ifMatch, sourceIfModifiedSince: r.sourceConditions.ifModifiedSince, sourceIfNoneMatch: r.sourceConditions.ifNoneMatch, sourceIfUnmodifiedSince: r.sourceConditions.ifUnmodifiedSince
                },
                copySourceAuthorization: bl(r.sourceAuthorization),
                cpkInfo: r.customerProvidedKey,
                encryptionScope: r.encryptionScope
              }, Td(n)));
            } catch (e) { throw i.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { i.end(); }
          }
        } class cc extends lc {
          constructor(e, t, a, r) {
            let s,
              i; if (r = r || {}, Ll(t))i = e, s = t; else if (S && t instanceof Je || t instanceof l || z(t))i = e, s = _l(t, r = a); else if (t || typeof t === 'string') {
              if (!t || typeof t !== 'string' || !a || typeof a !== 'string') throw new Error('Expecting non-empty strings for containerName and blobName parameters'); { const n = t,
                o = a,
                m = tl(e); if (m.kind === 'AccountConnString') { if (!S) throw new Error('Account connection string is only supported in Node.js environment'); { const e = new Je(m.accountName, m.accountKey); i = al(al(m.url, encodeURIComponent(n)), encodeURIComponent(o)), r.proxyOptions = void m.proxyUri, s = _l(e, r); } } else { if (m.kind !== 'SASConnString') throw new Error('Connection string must be either an Account connection string or a SAS connection string'); i = al(al(m.url, encodeURIComponent(n)), encodeURIComponent(o)) + '?' + m.accountSas, s = _l(new l(), r); } }
            } else i = e, s = _l(new l(), r); super(i, s), this.blockBlobContext = new ro(this.storageClientContext), this._blobContext = new Pn(this.storageClientContext);
          }
  
          withSnapshot(e) { return new cc(rl(this.url, Oo, e.length === 0 ? void 0 : e), this.pipeline); }
  
          async query(e, t = {}) {
            var a; jo(t.customerProvidedKey, this.isHttps); const { span: r, updatedOptions: s } = Md('BlockBlobClient-query', t); try {
              if (!S) throw new Error('This operation currently is only supported in Node.js.'); const i = await this._blobContext.query(Object.assign({
                abortSignal: t.abortSignal,
                queryRequest: {
                  queryType: 'SQL', expression: e, inputSerialization: hl(t.inputTextConfiguration), outputSerialization: hl(t.outputTextConfiguration)
                },
                leaseAccessConditions: t.conditions,
                modifiedAccessConditions: Object.assign(Object.assign({}, t.conditions), { ifTags: (a = t.conditions) === null || void 0 === a ? void 0 : a.tagConditions })
              }, Td(s))); return new We(i, { abortSignal: t.abortSignal, onProgress: t.onProgress, onError: t.onError });
            } catch (e) { throw r.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { r.end(); }
          }
  
          async upload(e, t, a = {}) {
            var r,
              s,
              i; a.conditions = a.conditions || {}; const { span: n, updatedOptions: o } = Md('BlockBlobClient-upload', a); try {
              return jo(a.customerProvidedKey, this.isHttps), await this.blockBlobContext.upload(t, e, Object.assign({
                abortSignal: a.abortSignal, blobHttpHeaders: a.blobHTTPHeaders, leaseAccessConditions: a.conditions, metadata: a.metadata, modifiedAccessConditions: Object.assign(Object.assign({}, a.conditions), { ifTags: (r = a.conditions) === null || void 0 === r ? void 0 : r.tagConditions }), requestOptions: { onUploadProgress: a.onProgress }, cpkInfo: a.customerProvidedKey, encryptionScope: a.encryptionScope, immutabilityPolicyExpiry: (s = a.immutabilityPolicy) === null || void 0 === s ? void 0 : s.expiriesOn, immutabilityPolicyMode: (i = a.immutabilityPolicy) === null || void 0 === i ? void 0 : i.policyMode, legalHold: a.legalHold, tier: _o(a.tier), blobTagsString: ul(a.tags)
              }, Td(o)));
            } catch (e) { throw n.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { n.end(); }
          }
  
          async syncUploadFromURL(e, t = {}) {
            var a,
              r,
              s,
              i,
              n; t.conditions = t.conditions || {}; const { span: o, updatedOptions: m } = Md('BlockBlobClient-syncUploadFromURL', t); try {
              return jo(t.customerProvidedKey, this.isHttps), await this.blockBlobContext.putBlobFromUrl(0, e, Object.assign(Object.assign(Object.assign({}, t), {
                blobHttpHeaders: t.blobHTTPHeaders,
                leaseAccessConditions: t.conditions,
                modifiedAccessConditions: Object.assign(Object.assign({}, t.conditions), { ifTags: t.conditions.tagConditions }),
                sourceModifiedAccessConditions: {
                  sourceIfMatch: (a = t.sourceConditions) === null || void 0 === a ? void 0 : a.ifMatch, sourceIfModifiedSince: (r = t.sourceConditions) === null || void 0 === r ? void 0 : r.ifModifiedSince, sourceIfNoneMatch: (s = t.sourceConditions) === null || void 0 === s ? void 0 : s.ifNoneMatch, sourceIfUnmodifiedSince: (i = t.sourceConditions) === null || void 0 === i ? void 0 : i.ifUnmodifiedSince, sourceIfTags: (n = t.sourceConditions) === null || void 0 === n ? void 0 : n.tagConditions
                },
                cpkInfo: t.customerProvidedKey,
                copySourceAuthorization: bl(t.sourceAuthorization),
                tier: _o(t.tier),
                blobTagsString: ul(t.tags)
              }), Td(m)));
            } catch (e) { throw o.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { o.end(); }
          }
  
          async stageBlock(e, t, a, r = {}) {
            const { span: s, updatedOptions: i } = Md('BlockBlobClient-stageBlock', r); try {
              return jo(r.customerProvidedKey, this.isHttps), await this.blockBlobContext.stageBlock(e, a, t, Object.assign({
                abortSignal: r.abortSignal, leaseAccessConditions: r.conditions, requestOptions: { onUploadProgress: r.onProgress }, transactionalContentMD5: r.transactionalContentMD5, transactionalContentCrc64: r.transactionalContentCrc64, cpkInfo: r.customerProvidedKey, encryptionScope: r.encryptionScope
              }, Td(i)));
            } catch (e) { throw s.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { s.end(); }
          }
  
          async stageBlockFromURL(e, t, a = 0, r, s = {}) {
            const { span: i, updatedOptions: n } = Md('BlockBlobClient-stageBlockFromURL', s); try {
              return jo(s.customerProvidedKey, this.isHttps), await this.blockBlobContext.stageBlockFromURL(e, 0, t, Object.assign({
                abortSignal: s.abortSignal, leaseAccessConditions: s.conditions, sourceContentMD5: s.sourceContentMD5, sourceContentCrc64: s.sourceContentCrc64, sourceRange: a !== 0 || r ? Ql({ offset: a, count: r }) : void 0, cpkInfo: s.customerProvidedKey, encryptionScope: s.encryptionScope, copySourceAuthorization: bl(s.sourceAuthorization)
              }, Td(n)));
            } catch (e) { throw i.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { i.end(); }
          }
  
          async commitBlockList(e, t = {}) {
            var a,
              r,
              s; t.conditions = t.conditions || {}; const { span: i, updatedOptions: n } = Md('BlockBlobClient-commitBlockList', t); try {
              return jo(t.customerProvidedKey, this.isHttps), await this.blockBlobContext.commitBlockList({ latest: e }, Object.assign({
                abortSignal: t.abortSignal, blobHttpHeaders: t.blobHTTPHeaders, leaseAccessConditions: t.conditions, metadata: t.metadata, modifiedAccessConditions: Object.assign(Object.assign({}, t.conditions), { ifTags: (a = t.conditions) === null || void 0 === a ? void 0 : a.tagConditions }), cpkInfo: t.customerProvidedKey, encryptionScope: t.encryptionScope, immutabilityPolicyExpiry: (r = t.immutabilityPolicy) === null || void 0 === r ? void 0 : r.expiriesOn, immutabilityPolicyMode: (s = t.immutabilityPolicy) === null || void 0 === s ? void 0 : s.policyMode, legalHold: t.legalHold, tier: _o(t.tier), blobTagsString: ul(t.tags)
              }, Td(n)));
            } catch (e) { throw i.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { i.end(); }
          }
  
          async getBlockList(e, t = {}) { var a; const { span: r, updatedOptions: s } = Md('BlockBlobClient-getBlockList', t); try { const i = await this.blockBlobContext.getBlockList(e, Object.assign({ abortSignal: t.abortSignal, leaseAccessConditions: t.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, t.conditions), { ifTags: (a = t.conditions) === null || void 0 === a ? void 0 : a.tagConditions }) }, Td(s))); return i.committedBlocks || (i.committedBlocks = []), i.uncommittedBlocks || (i.uncommittedBlocks = []), i; } catch (e) { throw r.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { r.end(); } }
  
          async uploadData(e, t = {}) { const { span: a, updatedOptions: r } = Md('BlockBlobClient-uploadData', t); try { if (S) { let t; return e instanceof Buffer ? t = e : e instanceof ArrayBuffer ? t = Buffer.from(e) : (e = e, t = Buffer.from(e.buffer, e.byteOffset, e.byteLength)), this.uploadSeekableInternal(((e, a)=>t.slice(e, e + a)), t.byteLength, r); } { const t = new Blob([e]); return this.uploadSeekableInternal(((e, a)=>t.slice(e, e + a)), t.size, r); } } catch (e) { throw a.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { a.end(); } }
  
          async uploadBrowserData(e, t = {}) { const { span: a, updatedOptions: r } = Md('BlockBlobClient-uploadBrowserData', t); try { const t = new Blob([e]); return await this.uploadSeekableInternal(((e, a)=>t.slice(e, e + a)), t.size, r); } catch (e) { throw a.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { a.end(); } }
  
          async uploadSeekableInternal(e, t, a = {}) {
            if (a.blockSize || (a.blockSize = 0), a.blockSize < 0 || a.blockSize > 4194304e3) throw new RangeError('blockSize option must be >= 0 and <= 4194304000'); if (a.maxSingleShotSize === 0 || a.maxSingleShotSize || (a.maxSingleShotSize = Ro), a.maxSingleShotSize < 0 || a.maxSingleShotSize > Ro) throw new RangeError('maxSingleShotSize option must be >= 0 and <= 268435456'); if (a.blockSize === 0) { if (t > 2097152e8) throw new RangeError(`${t} is too larger to upload to a block blob.`); t > a.maxSingleShotSize && (a.blockSize = Math.ceil(t / 5e4), a.blockSize < wo && (a.blockSize = wo)); }a.blobHTTPHeaders || (a.blobHTTPHeaders = {}), a.conditions || (a.conditions = {}); const { span: r, updatedOptions: s } = Md('BlockBlobClient-uploadSeekableInternal', a); try {
              if (t <= a.maxSingleShotSize) return await this.upload(e(0, t), t, s); const i = Math.floor((t - 1) / a.blockSize) + 1; if (i > 5e4) throw new RangeError("The buffer's size is too big or the BlockSize is too small;the number of blocks must be <= 50000"); const n = [],
                o = C(); let m = 0; const l = new Od(a.concurrency); for (let r = 0; r < i; r++) {
                l.addOperation((async ()=>{
                  const l = ll(o, r),
                    d = a.blockSize * r,
                    c = (r === i - 1 ? t : d + a.blockSize) - d; n.push(l), await this.stageBlock(l, e(d, c), c, {
                    abortSignal: a.abortSignal, conditions: a.conditions, encryptionScope: a.encryptionScope, tracingOptions: s.tracingOptions
                  }), m += c, a.onProgress && a.onProgress({ loadedBytes: m });
                }));
              } return await l.do(), this.commitBlockList(n, s);
            } catch (e) { throw r.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { r.end(); }
          }
  
          async uploadFile(e, t = {}) { const { span: a, updatedOptions: r } = Md('BlockBlobClient-uploadFile', t); try { const e = (await void 0).size; return await this.uploadSeekableInternal(((e, t)=>()=>{}), e, Object.assign(Object.assign({}, t), { tracingOptions: Object.assign(Object.assign({}, t.tracingOptions), Td(r)) })); } catch (e) { throw a.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { a.end(); } }
  
          async uploadStream(e, t = 8388608, a = 5, r = {}) {
            r.blobHTTPHeaders || (r.blobHTTPHeaders = {}), r.conditions || (r.conditions = {}); const { span: s, updatedOptions: i } = Md('BlockBlobClient-uploadStream', r); try {
              let n = 0; const o = C(); let m = 0; const l = [],
                d = new Bd(e, t, a, (async (e, t)=>{ const a = ll(o, n); l.push(a), n++, await this.stageBlock(a, e, t, { conditions: r.conditions, encryptionScope: r.encryptionScope, tracingOptions: i.tracingOptions }), m += t, r.onProgress && r.onProgress({ loadedBytes: m }); }), Math.ceil(a / 4 * 3)); return await d.do(), await this.commitBlockList(l, Object.assign(Object.assign({}, r), { tracingOptions: Object.assign(Object.assign({}, r.tracingOptions), Td(i)) }));
            } catch (e) { throw s.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { s.end(); }
          }
        } class pc extends lc {
          constructor(e, t, a, r) {
            let s,
              i; if (r = r || {}, Ll(t))i = e, s = t; else if (S && t instanceof Je || t instanceof l || z(t))i = e, s = _l(t, r = a); else if (t || typeof t === 'string') {
              if (!t || typeof t !== 'string' || !a || typeof a !== 'string') throw new Error('Expecting non-empty strings for containerName and blobName parameters'); { const n = t,
                o = a,
                m = tl(e); if (m.kind === 'AccountConnString') { if (!S) throw new Error('Account connection string is only supported in Node.js environment'); { const e = new Je(m.accountName, m.accountKey); i = al(al(m.url, encodeURIComponent(n)), encodeURIComponent(o)), r.proxyOptions = void m.proxyUri, s = _l(e, r); } } else { if (m.kind !== 'SASConnString') throw new Error('Connection string must be either an Account connection string or a SAS connection string'); i = al(al(m.url, encodeURIComponent(n)), encodeURIComponent(o)) + '?' + m.accountSas, s = _l(new l(), r); } }
            } else i = e, s = _l(new l(), r); super(i, s), this.pageBlobContext = new uo(this.storageClientContext);
          }
  
          withSnapshot(e) { return new pc(rl(this.url, Oo, e.length === 0 ? void 0 : e), this.pipeline); }
  
          async create(e, t = {}) {
            var a,
              r,
              s; t.conditions = t.conditions || {}; const { span: i, updatedOptions: n } = Md('PageBlobClient-create', t); try {
              return jo(t.customerProvidedKey, this.isHttps), await this.pageBlobContext.create(0, e, Object.assign({
                abortSignal: t.abortSignal, blobHttpHeaders: t.blobHTTPHeaders, blobSequenceNumber: t.blobSequenceNumber, leaseAccessConditions: t.conditions, metadata: t.metadata, modifiedAccessConditions: Object.assign(Object.assign({}, t.conditions), { ifTags: (a = t.conditions) === null || void 0 === a ? void 0 : a.tagConditions }), cpkInfo: t.customerProvidedKey, encryptionScope: t.encryptionScope, immutabilityPolicyExpiry: (r = t.immutabilityPolicy) === null || void 0 === r ? void 0 : r.expiriesOn, immutabilityPolicyMode: (s = t.immutabilityPolicy) === null || void 0 === s ? void 0 : s.policyMode, legalHold: t.legalHold, tier: _o(t.tier), blobTagsString: ul(t.tags)
              }, Td(n)));
            } catch (e) { throw i.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { i.end(); }
          }
  
          async createIfNotExists(e, t = {}) {
            var a,
              r; const { span: s, updatedOptions: i } = Md('PageBlobClient-createIfNotExists', t); try {
              const a = { ifNoneMatch: '*' },
                r = await this.create(e, Object.assign(Object.assign({}, t), { conditions: a, tracingOptions: i.tracingOptions })); return Object.assign(Object.assign({ succeeded: !0 }, r), { _response: r._response });
            } catch (e) { if (((a = e.details) === null || void 0 === a ? void 0 : a.errorCode) === 'BlobAlreadyExists') return s.setStatus({ code: Xe.ERROR, message: 'Expected exception when creating a blob only if it does not already exist.' }), Object.assign(Object.assign({ succeeded: !1 }, (r = e.response) === null || void 0 === r ? void 0 : r.parsedHeaders), { _response: e.response }); throw s.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { s.end(); }
          }
  
          async uploadPages(e, t, a, r = {}) {
            var s; r.conditions = r.conditions || {}; const { span: i, updatedOptions: n } = Md('PageBlobClient-uploadPages', r); try {
              return jo(r.customerProvidedKey, this.isHttps), await this.pageBlobContext.uploadPages(a, e, Object.assign({
                abortSignal: r.abortSignal, leaseAccessConditions: r.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, r.conditions), { ifTags: (s = r.conditions) === null || void 0 === s ? void 0 : s.tagConditions }), requestOptions: { onUploadProgress: r.onProgress }, range: Ql({ offset: t, count: a }), sequenceNumberAccessConditions: r.conditions, transactionalContentMD5: r.transactionalContentMD5, transactionalContentCrc64: r.transactionalContentCrc64, cpkInfo: r.customerProvidedKey, encryptionScope: r.encryptionScope
              }, Td(n)));
            } catch (e) { throw i.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { i.end(); }
          }
  
          async uploadPagesFromURL(e, t, a, r, s = {}) {
            var i; s.conditions = s.conditions || {}, s.sourceConditions = s.sourceConditions || {}; const { span: n, updatedOptions: o } = Md('PageBlobClient-uploadPagesFromURL', s); try {
              return jo(s.customerProvidedKey, this.isHttps), await this.pageBlobContext.uploadPagesFromURL(e, Ql({ offset: t, count: r }), 0, Ql({ offset: a, count: r }), Object.assign({
                abortSignal: s.abortSignal,
                sourceContentMD5: s.sourceContentMD5,
                sourceContentCrc64: s.sourceContentCrc64,
                leaseAccessConditions: s.conditions,
                sequenceNumberAccessConditions: s.conditions,
                modifiedAccessConditions: Object.assign(Object.assign({}, s.conditions), { ifTags: (i = s.conditions) === null || void 0 === i ? void 0 : i.tagConditions }),
                sourceModifiedAccessConditions: {
                  sourceIfMatch: s.sourceConditions.ifMatch, sourceIfModifiedSince: s.sourceConditions.ifModifiedSince, sourceIfNoneMatch: s.sourceConditions.ifNoneMatch, sourceIfUnmodifiedSince: s.sourceConditions.ifUnmodifiedSince
                },
                cpkInfo: s.customerProvidedKey,
                encryptionScope: s.encryptionScope,
                copySourceAuthorization: bl(s.sourceAuthorization)
              }, Td(o)));
            } catch (e) { throw n.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { n.end(); }
          }
  
          async clearPages(e = 0, t, a = {}) {
            var r; a.conditions = a.conditions || {}; const { span: s, updatedOptions: i } = Md('PageBlobClient-clearPages', a); try {
              return await this.pageBlobContext.clearPages(0, Object.assign({
                abortSignal: a.abortSignal, leaseAccessConditions: a.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, a.conditions), { ifTags: (r = a.conditions) === null || void 0 === r ? void 0 : r.tagConditions }), range: Ql({ offset: e, count: t }), sequenceNumberAccessConditions: a.conditions, cpkInfo: a.customerProvidedKey, encryptionScope: a.encryptionScope
              }, Td(i)));
            } catch (e) { throw s.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { s.end(); }
          }
  
          async getPageRanges(e = 0, t, a = {}) {
            var r; a.conditions = a.conditions || {}; const { span: s, updatedOptions: i } = Md('PageBlobClient-getPageRanges', a); try {
              return await this.pageBlobContext.getPageRanges(Object.assign({
                abortSignal: a.abortSignal, leaseAccessConditions: a.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, a.conditions), { ifTags: (r = a.conditions) === null || void 0 === r ? void 0 : r.tagConditions }), range: Ql({ offset: e, count: t })
              }, Td(i))).then(Uo);
            } catch (e) { throw s.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { s.end(); }
          }
  
          async getPageRangesDiff(e, t, a, r = {}) {
            var s; r.conditions = r.conditions || {}; const { span: i, updatedOptions: n } = Md('PageBlobClient-getPageRangesDiff', r); try {
              return await this.pageBlobContext.getPageRangesDiff(Object.assign({
                abortSignal: r.abortSignal, leaseAccessConditions: r.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, r.conditions), { ifTags: (s = r.conditions) === null || void 0 === s ? void 0 : s.tagConditions }), prevsnapshot: a, range: Ql({ offset: e, count: t })
              }, Td(n))).then(Uo);
            } catch (e) { throw i.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { i.end(); }
          }
  
          async getPageRangesDiffForManagedDisks(e, t, a, r = {}) {
            var s; r.conditions = r.conditions || {}; const { span: i, updatedOptions: n } = Md('PageBlobClient-GetPageRangesDiffForManagedDisks', r); try {
              return await this.pageBlobContext.getPageRangesDiff(Object.assign({
                abortSignal: r.abortSignal, leaseAccessConditions: r.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, r.conditions), { ifTags: (s = r.conditions) === null || void 0 === s ? void 0 : s.tagConditions }), prevSnapshotUrl: a, range: Ql({ offset: e, count: t })
              }, Td(n))).then(Uo);
            } catch (e) { throw i.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { i.end(); }
          }
  
          async resize(e, t = {}) {
            var a; t.conditions = t.conditions || {}; const { span: r, updatedOptions: s } = Md('PageBlobClient-resize', t); try {
              return await this.pageBlobContext.resize(e, Object.assign({
                abortSignal: t.abortSignal, leaseAccessConditions: t.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, t.conditions), { ifTags: (a = t.conditions) === null || void 0 === a ? void 0 : a.tagConditions }), encryptionScope: t.encryptionScope
              }, Td(s)));
            } catch (e) { throw r.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { r.end(); }
          }
  
          async updateSequenceNumber(e, t, a = {}) {
            var r; a.conditions = a.conditions || {}; const { span: s, updatedOptions: i } = Md('PageBlobClient-updateSequenceNumber', a); try {
              return await this.pageBlobContext.updateSequenceNumber(e, Object.assign({
                abortSignal: a.abortSignal, blobSequenceNumber: t, leaseAccessConditions: a.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, a.conditions), { ifTags: (r = a.conditions) === null || void 0 === r ? void 0 : r.tagConditions })
              }, Td(i)));
            } catch (e) { throw s.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { s.end(); }
          }
  
          async startCopyIncremental(e, t = {}) { var a; const { span: r, updatedOptions: s } = Md('PageBlobClient-startCopyIncremental', t); try { return await this.pageBlobContext.copyIncremental(e, Object.assign({ abortSignal: t.abortSignal, modifiedAccessConditions: Object.assign(Object.assign({}, t.conditions), { ifTags: (a = t.conditions) === null || void 0 === a ? void 0 : a.tagConditions }) }, Td(s))); } catch (e) { throw r.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { r.end(); } }
        } var uc; !(function (e) { e[e.LOCKED = 0] = 'LOCKED', e[e.UNLOCKED = 1] = 'UNLOCKED'; }(uc || (uc = {}))); class yc {
          static async lock(e) { return new Promise((t=>{ void 0 === this.keys[e] || this.keys[e] === uc.UNLOCKED ? (this.keys[e] = uc.LOCKED, t()) : this.onUnlockEvent(e, (()=>{ this.keys[e] = uc.LOCKED, t(); })); })); }
  
          static async unlock(e) { return new Promise((t=>{ this.keys[e] === uc.LOCKED && this.emitUnlockEvent(e), delete this.keys[e], t(); })); }
  
          static onUnlockEvent(e, t) { void 0 === this.listeners[e] ? this.listeners[e] = [t] : this.listeners[e].push(t); }
  
          static emitUnlockEvent(e) { if (void 0 !== this.listeners[e] && this.listeners[e].length > 0) { const t = this.listeners[e].shift(); setImmediate((()=>{ t.call(this); })); } }
        }yc.keys = {}, yc.listeners = {}; class gc {
          constructor() { this.batch = 'batch', this.batchRequest = new hc(); }
  
          getMultiPartContentType() { return this.batchRequest.getMultipartContentType(); }
  
          getHttpRequestBody() { return this.batchRequest.getHttpRequestBody(); }
  
          getSubRequests() { return this.batchRequest.getSubRequests(); }
  
          async addSubRequestInternal(e, t) { await yc.lock(this.batch); try { this.batchRequest.preAddSubRequest(e), await t(), this.batchRequest.postAddSubRequest(e); } finally { await yc.unlock(this.batch); } }
  
          setBatchType(e) { if (this.batchType || (this.batchType = e), this.batchType !== e) throw new RangeError(`BlobBatch only supports one operation type per batch and it already is being used for ${this.batchType} operations.`); }
  
          async deleteBlob(e, t, a) {
            let r,
              s; if (typeof e === 'string' && (S && t instanceof Je || t instanceof l || z(t)))r = e, s = t; else { if (!(e instanceof lc)) throw new RangeError('Invalid arguments. Either url and credential, or BlobClient need be provided.'); r = e.url, s = e.credential, a = t; }a || (a = {}); const { span: i, updatedOptions: n } = Md('BatchDeleteRequest-addSubRequest', a); try { this.setBatchType('delete'), await this.addSubRequestInternal({ url: r, credential: s }, (async ()=>{ await new lc(r, this.batchRequest.createPipeline(s)).delete(n); })); } catch (e) { throw i.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { i.end(); }
          }
  
          async setBlobAccessTier(e, t, a, r) {
            let s,
              i,
              n; if (typeof e === 'string' && (S && t instanceof Je || t instanceof l || z(t)))s = e, i = t, n = a; else { if (!(e instanceof lc)) throw new RangeError('Invalid arguments. Either url and credential, or BlobClient need be provided.'); s = e.url, i = e.credential, n = t, r = a; }r || (r = {}); const { span: o, updatedOptions: m } = Md('BatchSetTierRequest-addSubRequest', r); try { this.setBatchType('setAccessTier'), await this.addSubRequestInternal({ url: s, credential: i }, (async ()=>{ await new lc(s, this.batchRequest.createPipeline(i)).setAccessTier(n, m); })); } catch (e) { throw o.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { o.end(); }
          }
        } class hc {
          constructor() { this.operationCount = 0, this.body = ''; const e = C(); this.boundary = `batch_${e}`, this.subRequestPrefix = `--${this.boundary}\r\nContent-Type: application/http\r\nContent-Transfer-Encoding: binary`, this.multipartContentType = `multipart/mixed; boundary=${this.boundary}`, this.batchRequestEnding = `--${this.boundary}--`, this.subRequests = new Map(); }
  
          createPipeline(e) {
            const t = e instanceof l,
              a = 3 + (t ? 0 : 1),
              r = new Array(a); return r[0] = Am(), r[1] = new fc(), t || (r[2] = z(e) ? Nl(Zm(e, Eo), e) : e), r[a - 1] = new Nc(this), new Dl(r, {});
          }
  
          appendSubRequestToBody(e) { this.body += [this.subRequestPrefix, `Content-ID: ${this.operationCount}`, '', `${e.method.toString()} ${nl(e.url)} HTTP/1.1\r\n`].join('\r\n'); for (const t of e.headers.headersArray()) this.body += `${t.name}: ${t.value}\r\n`; this.body += '\r\n'; }
  
          preAddSubRequest(e) { if (this.operationCount >= 256) throw new RangeError('Cannot exceed 256 sub requests in a single batch'); const t = il(e.url); if (!t || t === '') throw new RangeError(`Invalid url for sub request: '${e.url}'`); }
  
          postAddSubRequest(e) { this.subRequests.set(this.operationCount, e), this.operationCount++; }
  
          getHttpRequestBody() { return `${this.body}${this.batchRequestEnding}\r\n`; }
  
          getMultipartContentType() { return this.multipartContentType; }
  
          getSubRequests() { return this.subRequests; }
        } class xc extends s {
          constructor(e, t, a) { super(t, a), this.dummyResponse = { request: new nd(), status: 200, headers: new Ol() }, this.batchRequest = e; }
  
          async sendRequest(e) { return await this.batchRequest.appendSubRequestToBody(e), this.dummyResponse; }
        } class Nc {
          constructor(e) { this.batchRequest = e; }
  
          create(e, t) { return new xc(this.batchRequest, e, t); }
        } class bc extends s {
          constructor(e, t) { super(e, t); }
  
          async sendRequest(e) { let t = ''; for (const a of e.headers.headersArray())dl(a.name, 'x-ms-version') && (t = a.name); return t !== '' && e.headers.remove(t), this._nextPolicy.sendRequest(e); }
        } class fc {create(e, t) { return new bc(e, t); }} const Sc = ': '; class Cc {
          constructor(e, t) { if (!e || !e.contentType) throw new RangeError("batchResponse is malformed or doesn't contain valid content-type."); if (!t || t.size === 0) throw new RangeError('Invalid state: subRequests is not provided or size is 0.'); this.batchResponse = e, this.subRequests = t, this.responseBatchBoundary = this.batchResponse.contentType.split('=')[1], this.perResponsePrefix = `--${this.responseBatchBoundary}\r\n`, this.batchResponseEnding = `--${this.responseBatchBoundary}--`; }
  
          async parseBatchResponse() {
            if (this.batchResponse._response.status !== 202) throw new Error(`Invalid state: batch request failed with status: '${this.batchResponse._response.status}'.`); const e = (await (async function (e) { return (async function (e) { const t = new FileReader(); return new Promise(((a, r)=>{ t.onloadend = e=>{ a(e.target.result); }, t.onerror = r, t.readAsText(e); })); }(await e.blobBody)); }(this.batchResponse))).split(this.batchResponseEnding)[0].split(this.perResponsePrefix).slice(1),
              t = e.length; if (t !== this.subRequests.size && t !== 1) throw new Error("Invalid state: sub responses' count is not equal to sub requests' count."); const a = new Array(t); let r = 0,
              s = 0; for (let i = 0; i < t; i++) {
              const t = e[i],
                n = {}; n.headers = new Ol(); const o = t.split('\r\n'); let m = !1,
                l = !1,
                d = !1,
                c = -1; for (const e of o) if (m) if (e.trim() !== '') if (l)n.bodyAsText || (n.bodyAsText = ''), n.bodyAsText += e; else { if (e.indexOf(Sc) === -1) throw new Error(`Invalid state: find non-empty line '${e}' without HTTP header delimiter ': '.`); const t = e.split(Sc); n.headers.set(t[0], t[1]), t[0] === 'x-ms-error-code' && (n.errorCode = t[1], d = !0); } else l || (l = !0); else if (e.startsWith(To) && (c = parseInt(e.split(Sc)[1])), e.startsWith('HTTP/1.1')) { m = !0; const t = e.split(' '); n.status = parseInt(t[1]), n.statusMessage = t.slice(2).join(' '); }c !== -1 && Number.isInteger(c) && c >= 0 && c < this.subRequests.size && void 0 === a[c] ? (n._request = this.subRequests.get(c), a[c] = n) : Ym.error(`subResponses[${i}] is dropped as the Content-ID is not found or invalid, Content-ID: ${c}`), d ? s++ : r++;
            } return { subResponses: a, subResponsesSucceededCount: r, subResponsesFailedCount: s };
          }
        } class vc {
          constructor(e) { this.client = e; }
  
          setProperties(e, t) { const a = { blobServiceProperties: e, options: rt(t || {}) }; return this.client.sendOperationRequest(a, zc); }
  
          getProperties(e) { const t = { options: rt(e || {}) }; return this.client.sendOperationRequest(t, Rc); }
  
          getStatistics(e) { const t = { options: rt(e || {}) }; return this.client.sendOperationRequest(t, wc); }
  
          listContainersSegment(e) { const t = { options: rt(e || {}) }; return this.client.sendOperationRequest(t, Ec); }
  
          getUserDelegationKey(e, t) { const a = { keyInfo: e, options: rt(t || {}) }; return this.client.sendOperationRequest(a, qc); }
  
          getAccountInfo(e) { const t = { options: rt(e || {}) }; return this.client.sendOperationRequest(t, Oc); }
  
          submitBatch(e, t, a, r) {
            const s = {
              contentLength: e, multipartContentType: t, body: a, options: rt(r || {})
            }; return this.client.sendOperationRequest(s, Bc);
          }
  
          filterBlobs(e) { const t = { options: rt(e || {}) }; return this.client.sendOperationRequest(t, Mc); }
        } const Pc = new nt(t, !0),
          zc = {
            path: '/', httpMethod: 'PUT', responses: { 202: { headersMapper: aa }, default: { bodyMapper: Ct, headersMapper: ra } }, requestBody: Ms, queryParameters: [Hs, As, ks], urlParameters: [Is], headerParameters: [Bs, Ts, Ls, Ds], isXML: !0, contentType: 'application/xml; charset=utf-8', mediaType: 'xml', serializer: Pc
          },
          Rc = {
            path: '/', httpMethod: 'GET', responses: { 200: { bodyMapper: ht, headersMapper: sa }, default: { bodyMapper: Ct, headersMapper: ia } }, queryParameters: [Hs, As, ks], urlParameters: [Is], headerParameters: [Ls, Ds, _s], isXML: !0, serializer: Pc
          },
          wc = {
            path: '/',
            httpMethod: 'GET',
            responses: { 200: { bodyMapper: vt, headersMapper: na }, default: { bodyMapper: Ct, headersMapper: oa } },
            queryParameters: [Hs, ks, {
              parameterPath: 'comp',
              mapper: {
                defaultValue: 'stats', isConstant: !0, serializedName: 'comp', type: { name: 'String' }
              }
            }],
            urlParameters: [Is],
            headerParameters: [Ls, Ds, _s],
            isXML: !0,
            serializer: Pc
          },
          Ec = {
            path: '/', httpMethod: 'GET', responses: { 200: { bodyMapper: zt, headersMapper: ma }, default: { bodyMapper: Ct, headersMapper: la } }, queryParameters: [ks, js, Us, Vs, Fs, $s], urlParameters: [Is], headerParameters: [Ls, Ds, _s], isXML: !0, serializer: Pc
          },
          qc = {
            path: '/',
            httpMethod: 'POST',
            responses: { 200: { bodyMapper: qt, headersMapper: da }, default: { bodyMapper: Ct, headersMapper: ca } },
            requestBody: Ks,
            queryParameters: [Hs, ks, {
              parameterPath: 'comp',
              mapper: {
                defaultValue: 'userdelegationkey', isConstant: !0, serializedName: 'comp', type: { name: 'String' }
              }
            }],
            urlParameters: [Is],
            headerParameters: [Bs, Ts, Ls, Ds],
            isXML: !0,
            contentType: 'application/xml; charset=utf-8',
            mediaType: 'xml',
            serializer: Pc
          },
          Oc = {
            path: '/', httpMethod: 'GET', responses: { 200: { headersMapper: pa }, default: { bodyMapper: Ct, headersMapper: ua } }, queryParameters: [As, Gs], urlParameters: [Is], headerParameters: [Ls, _s], isXML: !0, serializer: Pc
          },
          Bc = {
            path: '/', httpMethod: 'POST', responses: { 202: { bodyMapper: { type: { name: 'Stream' }, serializedName: 'parsedResponse' }, headersMapper: ya }, default: { bodyMapper: Ct, headersMapper: ga } }, requestBody: Qs, queryParameters: [ks, Xs], urlParameters: [Is], headerParameters: [Bs, Ts, Ls, Ds, Ws, Js], isXML: !0, contentType: 'application/xml; charset=utf-8', mediaType: 'xml', serializer: Pc
          },
          Mc = {
            path: '/',
            httpMethod: 'GET',
            responses: { 200: { bodyMapper: Ot, headersMapper: ha }, default: { bodyMapper: Ct, headersMapper: xa } },
            queryParameters: [ks, Vs, Fs, {
              parameterPath: 'comp',
              mapper: {
                defaultValue: 'blobs', isConstant: !0, serializedName: 'comp', type: { name: 'String' }
              }
            }, { parameterPath: ['options', 'where'], mapper: { serializedName: 'where', xmlName: 'where', type: { name: 'String' } } }],
            urlParameters: [Is],
            headerParameters: [Ls, Ds, _s],
            isXML: !0,
            serializer: Pc
          }; class Tc {
          constructor(e, t, a) {
            let r; r = Ll(t) ? t : _l(t || new l(), a); const s = new Rd(e, r.toServiceClientOptions()),
              i = il(e); this.serviceOrContainerContext = i && i !== '/' ? new Vd(s) : new vc(s);
          }
  
          createBatch() { return new gc(); }
  
          async deleteBlobs(e, t, a) { const r = new gc(); for (const s of e) typeof s === 'string' ? await r.deleteBlob(s, t, a) : await r.deleteBlob(s, t); return this.submitBatch(r); }
  
          async setBlobsAccessTier(e, t, a, r) { const s = new gc(); for (const i of e) typeof i === 'string' ? await s.setBlobAccessTier(i, t, a, r) : await s.setBlobAccessTier(i, t, a); return this.submitBatch(s); }
  
          async submitBatch(e, t = {}) {
            if (!e || e.getSubRequests().size === 0) throw new RangeError('Batch request should contain one or more sub requests.'); const { span: a, updatedOptions: r } = Md('BlobBatchClient-submitBatch', t); try {
              const i = e.getHttpRequestBody(),
                n = await this.serviceOrContainerContext.submitBatch((s = i, new Blob([s]).size), e.getMultiPartContentType(), i, Object.assign(Object.assign({}, t), Td(r))),
                o = new Cc(n, e.getSubRequests()),
                m = await o.parseBatchResponse(); return {
                _response: n._response, contentType: n.contentType, errorCode: n.errorCode, requestId: n.requestId, clientRequestId: n.clientRequestId, version: n.version, subResponses: m.subResponses, subResponsesSucceededCount: m.subResponsesSucceededCount, subResponsesFailedCount: m.subResponsesFailedCount
              };
            } catch (e) { throw a.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { a.end(); } var s;
          }
        } class Ic extends wd {
          constructor(e, t, a) {
            let r,
              s; if (a = a || {}, Ll(t))s = e, r = t; else if (S && t instanceof Je || t instanceof l || z(t))s = e, r = _l(t, a); else if (t || typeof t === 'string') {
              if (!t || typeof t !== 'string') throw new Error('Expecting non-empty strings for containerName parameter'); { const i = t,
                n = tl(e); if (n.kind === 'AccountConnString') { if (!S) throw new Error('Account connection string is only supported in Node.js environment'); { const e = new Je(n.accountName, n.accountKey); s = al(n.url, encodeURIComponent(i)), a.proxyOptions = void n.proxyUri, r = _l(e, a); } } else { if (n.kind !== 'SASConnString') throw new Error('Connection string must be either an Account connection string or a SAS connection string'); s = al(n.url, encodeURIComponent(i)) + '?' + n.accountSas, r = _l(new l(), a); } }
            } else s = e, r = _l(new l(), a); super(s, r), this._containerName = this.getContainerNameFromUrl(), this.containerContext = new Vd(this.storageClientContext);
          }
  
          get containerName() { return this._containerName; }
  
          async create(e = {}) { const { span: t, updatedOptions: a } = Md('ContainerClient-create', e); try { return await this.containerContext.create(Object.assign(Object.assign({}, e), Td(a))); } catch (e) { throw t.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { t.end(); } }
  
          async createIfNotExists(e = {}) {
            var t,
              a; const { span: r, updatedOptions: s } = Md('ContainerClient-createIfNotExists', e); try { const e = await this.create(s); return Object.assign(Object.assign({ succeeded: !0 }, e), { _response: e._response }); } catch (e) { if (((t = e.details) === null || void 0 === t ? void 0 : t.errorCode) === 'ContainerAlreadyExists') return r.setStatus({ code: Xe.ERROR, message: 'Expected exception when creating a container only if it does not already exist.' }), Object.assign(Object.assign({ succeeded: !1 }, (a = e.response) === null || void 0 === a ? void 0 : a.parsedHeaders), { _response: e.response }); throw r.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { r.end(); }
          }
  
          async exists(e = {}) { const { span: t, updatedOptions: a } = Md('ContainerClient-exists', e); try { return await this.getProperties({ abortSignal: e.abortSignal, tracingOptions: a.tracingOptions }), !0; } catch (e) { if (e.statusCode === 404) return t.setStatus({ code: Xe.ERROR, message: 'Expected exception when checking container existence' }), !1; throw t.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { t.end(); } }
  
          getBlobClient(e) { return new lc(al(this.url, encodeURIComponent(e)), this.pipeline); }
  
          getAppendBlobClient(e) { return new dc(al(this.url, encodeURIComponent(e)), this.pipeline); }
  
          getBlockBlobClient(e) { return new cc(al(this.url, encodeURIComponent(e)), this.pipeline); }
  
          getPageBlobClient(e) { return new pc(al(this.url, encodeURIComponent(e)), this.pipeline); }
  
          async getProperties(e = {}) { e.conditions || (e.conditions = {}); const { span: t, updatedOptions: a } = Md('ContainerClient-getProperties', e); try { return await this.containerContext.getProperties(Object.assign(Object.assign({ abortSignal: e.abortSignal }, e.conditions), Td(a))); } catch (e) { throw t.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { t.end(); } }
  
          async delete(e = {}) { e.conditions || (e.conditions = {}); const { span: t, updatedOptions: a } = Md('ContainerClient-delete', e); try { return await this.containerContext.delete(Object.assign({ abortSignal: e.abortSignal, leaseAccessConditions: e.conditions, modifiedAccessConditions: e.conditions }, Td(a))); } catch (e) { throw t.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { t.end(); } }
  
          async deleteIfExists(e = {}) {
            var t,
              a; const { span: r, updatedOptions: s } = Md('ContainerClient-deleteIfExists', e); try { const e = await this.delete(s); return Object.assign(Object.assign({ succeeded: !0 }, e), { _response: e._response }); } catch (e) { if (((t = e.details) === null || void 0 === t ? void 0 : t.errorCode) === 'ContainerNotFound') return r.setStatus({ code: Xe.ERROR, message: 'Expected exception when deleting a container only if it exists.' }), Object.assign(Object.assign({ succeeded: !1 }, (a = e.response) === null || void 0 === a ? void 0 : a.parsedHeaders), { _response: e.response }); throw r.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { r.end(); }
          }
  
          async setMetadata(e, t = {}) {
            if (t.conditions || (t.conditions = {}), t.conditions.ifUnmodifiedSince) throw new RangeError('the IfUnmodifiedSince must have their default values because they are ignored by the blob service'); const { span: a, updatedOptions: r } = Md('ContainerClient-setMetadata', t); try {
              return await this.containerContext.setMetadata(Object.assign({
                abortSignal: t.abortSignal, leaseAccessConditions: t.conditions, metadata: e, modifiedAccessConditions: t.conditions
              }, Td(r)));
            } catch (e) { throw a.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { a.end(); }
          }
  
          async getAccessPolicy(e = {}) {
            e.conditions || (e.conditions = {}); const { span: t, updatedOptions: a } = Md('ContainerClient-getAccessPolicy', e); try {
              const r = await this.containerContext.getAccessPolicy(Object.assign({ abortSignal: e.abortSignal, leaseAccessConditions: e.conditions }, Td(a))),
                s = {
                  _response: r._response, blobPublicAccess: r.blobPublicAccess, date: r.date, etag: r.etag, errorCode: r.errorCode, lastModified: r.lastModified, requestId: r.requestId, clientRequestId: r.clientRequestId, signedIdentifiers: [], version: r.version
                }; for (const e of r) { let t; e.accessPolicy && (t = { permissions: e.accessPolicy.permissions }, e.accessPolicy.expiresOn && (t.expiresOn = new Date(e.accessPolicy.expiresOn)), e.accessPolicy.startsOn && (t.startsOn = new Date(e.accessPolicy.startsOn))), s.signedIdentifiers.push({ accessPolicy: t, id: e.id }); } return s;
            } catch (e) { throw t.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { t.end(); }
          }
  
          async setAccessPolicy(e, t, a = {}) {
            a.conditions = a.conditions || {}; const { span: r, updatedOptions: s } = Md('ContainerClient-setAccessPolicy', a); try {
              const i = []; for (const e of t || [])i.push({ accessPolicy: { expiresOn: e.accessPolicy.expiresOn ? ml(e.accessPolicy.expiresOn) : '', permissions: e.accessPolicy.permissions, startsOn: e.accessPolicy.startsOn ? ml(e.accessPolicy.startsOn) : '' }, id: e.id }); return await this.containerContext.setAccessPolicy(Object.assign({
                abortSignal: a.abortSignal, access: e, containerAcl: i, leaseAccessConditions: a.conditions, modifiedAccessConditions: a.conditions
              }, Td(s)));
            } catch (e) { throw r.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { r.end(); }
          }
  
          getBlobLeaseClient(e) { return new mc(this, e); }
  
          async uploadBlockBlob(e, t, a, r = {}) {
            const { span: s, updatedOptions: i } = Md('ContainerClient-uploadBlockBlob', r); try {
              const r = this.getBlockBlobClient(e),
                n = await r.upload(t, a, i); return { blockBlobClient: r, response: n };
            } catch (e) { throw s.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { s.end(); }
          }
  
          async deleteBlob(e, t = {}) { const { span: a, updatedOptions: r } = Md('ContainerClient-deleteBlob', t); try { let s = this.getBlobClient(e); return t.versionId && (s = s.withVersion(t.versionId)), await s.delete(r); } catch (e) { throw a.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { a.end(); } }
  
          async listBlobFlatSegment(e, t = {}) { const { span: a, updatedOptions: r } = Md('ContainerClient-listBlobFlatSegment', t); try { const s = await this.containerContext.listBlobFlatSegment(Object.assign(Object.assign({ marker: e }, t), Td(r))); return Object.assign(Object.assign({}, s), { _response: s._response, segment: Object.assign(Object.assign({}, s.segment), { blobItems: s.segment.blobItems.map((e=>Object.assign(Object.assign({}, e), { tags: gl(e.blobTags), objectReplicationSourceProperties: xl(e.objectReplicationMetadata) }))) }) }); } catch (e) { throw a.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { a.end(); } }
  
          async listBlobHierarchySegment(e, t, a = {}) { const { span: r, updatedOptions: s } = Md('ContainerClient-listBlobHierarchySegment', a); try { const i = await this.containerContext.listBlobHierarchySegment(e, Object.assign(Object.assign({ marker: t }, a), Td(s))); return Object.assign(Object.assign({}, i), { _response: i._response, segment: Object.assign(Object.assign({}, i.segment), { blobItems: i.segment.blobItems.map((e=>Object.assign(Object.assign({}, e), { tags: gl(e.blobTags), objectReplicationSourceProperties: xl(e.objectReplicationMetadata) }))) }) }); } catch (e) { throw r.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { r.end(); } }
  
          listSegments(e, t = {}) { return et(this, arguments, (function*() { let a; if (e || void 0 === e) do { a = yield Ye(this.listBlobFlatSegment(e, t)), e = a.continuationToken, yield yield Ye(yield Ye(a)); } while (e); })); }
  
          listItems(e = {}) {
            return et(this, arguments, (function*() {
              var t,
                a; try { for (var r, s = at(this.listSegments(void 0, e)); !(r = yield Ye(s.next())).done;) { const e = r.value; yield Ye(yield*tt(at(e.segment.blobItems))); } } catch (e) { t = { error: e }; } finally { try { r && !r.done && (a = s.return) && (yield Ye(a.call(s))); } finally { if (t) throw t.error; } }
            }));
          }
  
          listBlobsFlat(e = {}) {
            const t = []; e.includeCopy && t.push('copy'), e.includeDeleted && t.push('deleted'), e.includeMetadata && t.push('metadata'), e.includeSnapshots && t.push('snapshots'), e.includeVersions && t.push('versions'), e.includeUncommitedBlobs && t.push('uncommittedblobs'), e.includeTags && t.push('tags'), e.includeDeletedWithVersions && t.push('deletedwithversions'), e.includeImmutabilityPolicy && t.push('immutabilitypolicy'), e.includeLegalHold && t.push('legalhold'), e.prefix === '' && (e.prefix = void 0); const a = Object.assign(Object.assign({}, e), t.length > 0 ? { include: t } : {}),
              r = this.listItems(a); return { next: ()=>r.next(), [Symbol.asyncIterator]() { return this; }, byPage: (e = {})=>this.listSegments(e.continuationToken, Object.assign({ maxPageSize: e.maxPageSize }, a)) };
          }
  
          listHierarchySegments(e, t, a = {}) { return et(this, arguments, (function*() { let r; if (t || void 0 === t) do { r = yield Ye(this.listBlobHierarchySegment(e, t, a)), t = r.continuationToken, yield yield Ye(yield Ye(r)); } while (t); })); }
  
          listItemsByHierarchy(e, t = {}) {
            return et(this, arguments, (function*() {
              var a,
                r; try { for (var s, i = at(this.listHierarchySegments(e, void 0, t)); !(s = yield Ye(i.next())).done;) { const e = s.value.segment; if (e.blobPrefixes) for (const t of e.blobPrefixes)yield yield Ye(Object.assign({ kind: 'prefix' }, t)); for (const t of e.blobItems)yield yield Ye(Object.assign({ kind: 'blob' }, t)); } } catch (e) { a = { error: e }; } finally { try { s && !s.done && (r = i.return) && (yield Ye(r.call(i))); } finally { if (a) throw a.error; } }
            }));
          }
  
          listBlobsByHierarchy(e, t = {}) {
            if (e === '') throw new RangeError('delimiter should contain one or more characters'); const a = []; t.includeCopy && a.push('copy'), t.includeDeleted && a.push('deleted'), t.includeMetadata && a.push('metadata'), t.includeSnapshots && a.push('snapshots'), t.includeVersions && a.push('versions'), t.includeUncommitedBlobs && a.push('uncommittedblobs'), t.includeTags && a.push('tags'), t.includeDeletedWithVersions && a.push('deletedwithversions'), t.includeImmutabilityPolicy && a.push('immutabilitypolicy'), t.includeLegalHold && a.push('legalhold'), t.prefix === '' && (t.prefix = void 0); const r = Object.assign(Object.assign({}, t), a.length > 0 ? { include: a } : {}),
              s = this.listItemsByHierarchy(e, r); return { next: async ()=>s.next(), [Symbol.asyncIterator]() { return this; }, byPage: (t = {})=>this.listHierarchySegments(e, t.continuationToken, Object.assign({ maxPageSize: t.maxPageSize }, r)) };
          }
  
          getContainerNameFromUrl() { let e; try { const t = q.parse(this.url); if (e = t.getHost().split('.')[1] === 'blob' ? t.getPath().split('/')[1] : pl(t) ? t.getPath().split('/')[2] : t.getPath().split('/')[1], e = decodeURIComponent(e), !e) throw new Error('Provided containerName is invalid.'); return e; } catch (e) { throw new Error('Unable to extract containerName with provided information.'); } }
  
          generateSasUrl(e) { return new Promise((t=>{ if (!(this.credential instanceof Je)) throw new RangeError('Can only generate the SAS when the client is initialized with a shared key credential'); const a = _d(Object.assign({ containerName: this._containerName }, e), this.credential).toString(); t(ol(this.url, a)); })); }
  
          getBlobBatchClient() { return new Tc(this.url, this.pipeline); }
        }a(697); class Hc {
          constructor() { this.read = !1, this.write = !1, this.delete = !1, this.deleteVersion = !1, this.list = !1, this.add = !1, this.create = !1, this.update = !1, this.process = !1, this.tag = !1, this.filter = !1, this.setImmutabilityPolicy = !1; }
  
          static parse(e) { const t = new Hc(); for (const a of e) switch (a) { case 'r': t.read = !0; break; case 'w': t.write = !0; break; case 'd': t.delete = !0; break; case 'x': t.deleteVersion = !0; break; case 'l': t.list = !0; break; case 'a': t.add = !0; break; case 'c': t.create = !0; break; case 'u': t.update = !0; break; case 'p': t.process = !0; break; case 't': t.tag = !0; break; case 'f': t.filter = !0; break; case 'i': t.setImmutabilityPolicy = !0; break; default: throw new RangeError(`Invalid permission character: ${a}`); } return t; }
  
          static from(e) { const t = new Hc(); return e.read && (t.read = !0), e.write && (t.write = !0), e.delete && (t.delete = !0), e.deleteVersion && (t.deleteVersion = !0), e.filter && (t.filter = !0), e.tag && (t.tag = !0), e.list && (t.list = !0), e.add && (t.add = !0), e.create && (t.create = !0), e.update && (t.update = !0), e.process && (t.process = !0), e.setImmutabilityPolicy && (t.setImmutabilityPolicy = !0), t; }
  
          toString() { const e = []; return this.read && e.push('r'), this.write && e.push('w'), this.delete && e.push('d'), this.deleteVersion && e.push('x'), this.filter && e.push('f'), this.tag && e.push('t'), this.list && e.push('l'), this.add && e.push('a'), this.create && e.push('c'), this.update && e.push('u'), this.process && e.push('p'), this.setImmutabilityPolicy && e.push('i'), e.join(''); }
        } class Ac {
          constructor() { this.service = !1, this.container = !1, this.object = !1; }
  
          static parse(e) { const t = new Ac(); for (const a of e) switch (a) { case 's': t.service = !0; break; case 'c': t.container = !0; break; case 'o': t.object = !0; break; default: throw new RangeError(`Invalid resource type: ${a}`); } return t; }
  
          toString() { const e = []; return this.service && e.push('s'), this.container && e.push('c'), this.object && e.push('o'), e.join(''); }
        } class kc {
          constructor() { this.blob = !1, this.file = !1, this.queue = !1, this.table = !1; }
  
          static parse(e) { const t = new kc(); for (const a of e) switch (a) { case 'b': t.blob = !0; break; case 'f': t.file = !0; break; case 'q': t.queue = !0; break; case 't': t.table = !0; break; default: throw new RangeError(`Invalid service character: ${a}`); } return t; }
  
          toString() { const e = []; return this.blob && e.push('b'), this.table && e.push('t'), this.queue && e.push('q'), this.file && e.push('f'), e.join(''); }
        } class Lc extends wd {
          constructor(e, t, a) { let r; r = Ll(t) ? t : S && t instanceof Je || t instanceof l || z(t) ? _l(t, a) : _l(new l(), a), super(e, r), this.serviceContext = new vc(this.storageClientContext); }
  
          static fromConnectionString(e, t) { t = t || {}; const a = tl(e); if (a.kind === 'AccountConnString') { if (S) { const e = new Je(a.accountName, a.accountKey); t.proxyOptions = void a.proxyUri; const r = _l(e, t); return new Lc(a.url, r); } throw new Error('Account connection string is only supported in Node.js environment'); } if (a.kind === 'SASConnString') { const e = _l(new l(), t); return new Lc(a.url + '?' + a.accountSas, e); } throw new Error('Connection string must be either an Account connection string or a SAS connection string'); }
  
          getContainerClient(e) { return new Ic(al(this.url, encodeURIComponent(e)), this.pipeline); }
  
          async createContainer(e, t = {}) {
            const { span: a, updatedOptions: r } = Md('BlobServiceClient-createContainer', t); try {
              const t = this.getContainerClient(e),
                s = await t.create(r); return { containerClient: t, containerCreateResponse: s };
            } catch (e) { throw a.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { a.end(); }
          }
  
          async deleteContainer(e, t = {}) { const { span: a, updatedOptions: r } = Md('BlobServiceClient-deleteContainer', t); try { const t = this.getContainerClient(e); return await t.delete(r); } catch (e) { throw a.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { a.end(); } }
  
          async undeleteContainer(e, t, a = {}) {
            const { span: r, updatedOptions: s } = Md('BlobServiceClient-undeleteContainer', a); try {
              const i = this.getContainerClient(a.destinationContainerName || e),
                n = new Vd(i.storageClientContext); return { containerClient: i, containerUndeleteResponse: await n.restore(Object.assign({ deletedContainerName: e, deletedContainerVersion: t }, s)) };
            } catch (e) { throw r.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { r.end(); }
          }
  
          async renameContainer(e, t, a = {}) {
            var r; const { span: s, updatedOptions: i } = Md('BlobServiceClient-renameContainer', a); try {
              const n = this.getContainerClient(t),
                o = new Vd(n.storageClientContext); return { containerClient: n, containerRenameResponse: await o.rename(e, Object.assign(Object.assign({}, i), { sourceLeaseId: (r = a.sourceCondition) === null || void 0 === r ? void 0 : r.leaseId })) };
            } catch (e) { throw s.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { s.end(); }
          }
  
          async getProperties(e = {}) { const { span: t, updatedOptions: a } = Md('BlobServiceClient-getProperties', e); try { return await this.serviceContext.getProperties(Object.assign({ abortSignal: e.abortSignal }, Td(a))); } catch (e) { throw t.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { t.end(); } }
  
          async setProperties(e, t = {}) { const { span: a, updatedOptions: r } = Md('BlobServiceClient-setProperties', t); try { return await this.serviceContext.setProperties(e, Object.assign({ abortSignal: t.abortSignal }, Td(r))); } catch (e) { throw a.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { a.end(); } }
  
          async getStatistics(e = {}) { const { span: t, updatedOptions: a } = Md('BlobServiceClient-getStatistics', e); try { return await this.serviceContext.getStatistics(Object.assign({ abortSignal: e.abortSignal }, Td(a))); } catch (e) { throw t.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { t.end(); } }
  
          async getAccountInfo(e = {}) { const { span: t, updatedOptions: a } = Md('BlobServiceClient-getAccountInfo', e); try { return await this.serviceContext.getAccountInfo(Object.assign({ abortSignal: e.abortSignal }, Td(a))); } catch (e) { throw t.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { t.end(); } }
  
          async listContainersSegment(e, t = {}) { const { span: a, updatedOptions: r } = Md('BlobServiceClient-listContainersSegment', t); try { return await this.serviceContext.listContainersSegment(Object.assign(Object.assign(Object.assign({ abortSignal: t.abortSignal, marker: e }, t), { include: typeof t.include === 'string' ? [t.include] : t.include }), Td(r))); } catch (e) { throw a.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { a.end(); } }
  
          async findBlobsByTagsSegment(e, t, a = {}) {
            const { span: r, updatedOptions: s } = Md('BlobServiceClient-findBlobsByTagsSegment', a); try {
              const i = await this.serviceContext.filterBlobs(Object.assign({
                abortSignal: a.abortSignal, where: e, marker: t, maxPageSize: a.maxPageSize
              }, Td(s))); return Object.assign(Object.assign({}, i), { _response: i._response, blobs: i.blobs.map((e=>{ var t; let a = ''; return ((t = e.tags) === null || void 0 === t ? void 0 : t.blobTagSet.length) === 1 && (a = e.tags.blobTagSet[0].value), Object.assign(Object.assign({}, e), { tags: gl(e.tags), tagValue: a }); })) });
            } catch (e) { throw r.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { r.end(); }
          }
  
          findBlobsByTagsSegments(e, t, a = {}) { return et(this, arguments, (function*() { let r; if (t || void 0 === t) do { r = yield Ye(this.findBlobsByTagsSegment(e, t, a)), r.blobs = r.blobs || [], t = r.continuationToken, yield yield Ye(r); } while (t); })); }
  
          findBlobsByTagsItems(e, t = {}) {
            return et(this, arguments, (function*() {
              var a,
                r; try { for (var s, i = at(this.findBlobsByTagsSegments(e, void 0, t)); !(s = yield Ye(i.next())).done;) { const e = s.value; yield Ye(yield*tt(at(e.blobs))); } } catch (e) { a = { error: e }; } finally { try { s && !s.done && (r = i.return) && (yield Ye(r.call(i))); } finally { if (a) throw a.error; } }
            }));
          }
  
          findBlobsByTags(e, t = {}) {
            const a = Object.assign({}, t),
              r = this.findBlobsByTagsItems(e, a); return { next: ()=>r.next(), [Symbol.asyncIterator]() { return this; }, byPage: (t = {})=>this.findBlobsByTagsSegments(e, t.continuationToken, Object.assign({ maxPageSize: t.maxPageSize }, a)) };
          }
  
          listSegments(e, t = {}) { return et(this, arguments, (function*() { let a; if (e || void 0 === e) do { a = yield Ye(this.listContainersSegment(e, t)), a.containerItems = a.containerItems || [], e = a.continuationToken, yield yield Ye(yield Ye(a)); } while (e); })); }
  
          listItems(e = {}) {
            return et(this, arguments, (function*() {
              var t,
                a; try { for (var r, s = at(this.listSegments(void 0, e)); !(r = yield Ye(s.next())).done;) { const e = r.value; yield Ye(yield*tt(at(e.containerItems))); } } catch (e) { t = { error: e }; } finally { try { r && !r.done && (a = s.return) && (yield Ye(a.call(s))); } finally { if (t) throw t.error; } }
            }));
          }
  
          listContainers(e = {}) {
            e.prefix === '' && (e.prefix = void 0); const t = []; e.includeDeleted && t.push('deleted'), e.includeMetadata && t.push('metadata'); const a = Object.assign(Object.assign({}, e), t.length > 0 ? { include: t } : {}),
              r = this.listItems(a); return { next: ()=>r.next(), [Symbol.asyncIterator]() { return this; }, byPage: (e = {})=>this.listSegments(e.continuationToken, Object.assign({ maxPageSize: e.maxPageSize }, a)) };
          }
  
          async getUserDelegationKey(e, t, a = {}) {
            const { span: r, updatedOptions: s } = Md('BlobServiceClient-getUserDelegationKey', a); try {
              const i = await this.serviceContext.getUserDelegationKey({ startsOn: ml(e, !1), expiresOn: ml(t, !1) }, Object.assign({ abortSignal: a.abortSignal }, Td(s))),
                n = {
                  signedObjectId: i.signedObjectId, signedTenantId: i.signedTenantId, signedStartsOn: new Date(i.signedStartsOn), signedExpiresOn: new Date(i.signedExpiresOn), signedService: i.signedService, signedVersion: i.signedVersion, value: i.value
                }; return Object.assign({
                _response: i._response, requestId: i.requestId, clientRequestId: i.clientRequestId, version: i.version, date: i.date, errorCode: i.errorCode
              }, n);
            } catch (e) { throw r.setStatus({ code: Xe.ERROR, message: e.message }), e; } finally { r.end(); }
          }
  
          getBlobBatchClient() { return new Tc(this.url, this.pipeline); }
  
          generateAccountSasUrl(e, t = Hc.parse('r'), a = 'sco', r = {}) {
            if (!(this.credential instanceof Je)) throw RangeError('Can only generate the account SAS when the client is initialized with a shared key credential'); if (void 0 === e) { const t = new Date(); e = new Date(t.getTime() + 36e5); } const s = (function (e, t) {
              const a = e.version ? e.version : zo; if (e.permissions && e.permissions.setImmutabilityPolicy && a < '2020-08-04') throw RangeError("'version' must be >= '2020-08-04' when provided 'i' permission."); if (e.permissions && e.permissions.deleteVersion && a < '2019-10-10') throw RangeError("'version' must be >= '2019-10-10' when provided 'x' permission."); if (e.permissions && e.permissions.tag && a < '2019-12-12') throw RangeError("'version' must be >= '2019-12-12' when provided 't' permission."); if (e.permissions && e.permissions.filter && a < '2019-12-12') throw RangeError("'version' must be >= '2019-12-12' when provided 'f' permission."); const r = Hc.parse(e.permissions.toString()),
                s = kc.parse(e.services).toString(),
                i = Ac.parse(e.resourceTypes).toString(),
                n = [t.accountName, r, s, i, e.startsOn ? ml(e.startsOn, !1) : '', ml(e.expiresOn, !1), e.ipRange ? kd(e.ipRange) : '', e.protocol ? e.protocol : '', a, ''].join('\n'),
                o = t.computeHMACSHA256(n); return new Dd(a, o, r.toString(), s, i, e.protocol, e.startsOn, e.expiresOn, e.ipRange);
            }(Object.assign({
              permissions: t, expiresOn: e, resourceTypes: a, services: kc.parse('b').toString()
            }, r), this.credential)).toString(); return ol(this.url, s);
          }
        } const Dc = {
          AnonymousCredential: l, AnonymousCredentialPolicy: o, AppendBlobClient: dc, BaseRequestPolicy: s, BlobBatch: gc, BlobBatchClient: Tc, BlobClient: lc, BlobLeaseClient: mc, BlobServiceClient: Lc, BlockBlobClient: cc, BlockBlobTier: Lo, ContainerClient: Ic, Credential: m, CredentialPolicy: n, HttpHeaders: Ol, PageBlobClient: pc, Pipeline: Dl, PremiumPageBlobTier: Do, RequestPolicyOptions: i, RestError: wm, StorageBrowserPolicy: fl, StorageBrowserPolicyFactory: Sl, StorageOAuthScopes: Eo, StorageRetryPolicy: zl, StorageRetryPolicyFactory: Rl, StorageRetryPolicyType: Cl, WebResource: nd, deserializationPolicy: Am, isPipelineLike: Ll, logger: Ym, newPipeline: _l
        };
      })(), r.default;
    })();
  })));
  
